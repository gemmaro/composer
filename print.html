<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Composer</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Composer</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gemmaro/composer" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p align="center">
    <a href="https://getcomposer.org">
        <img src="https://getcomposer.org/img/logo-composer-transparent.png" alt="Composer">
    </a>
</p>
<h1 align="center">PHPのための依存関係管理</h1>
<p>ComposerはPHPのプロジェクトの依存関係を宣言し、管理し、インストールする助けになります。</p>
<p>詳細情報とドキュメントについては<a href="https://getcomposer.org/">https://getcomposer.org/</a>を参照してください。</p>
<p><a href="https://github.com/composer/composer/actions"><img src="https://github.com/composer/composer/workflows/Continuous%20Integration/badge.svg?branch=main" alt="Continuous Integration" /></a></p>
<h2 id="インストールと使い方"><a class="header" href="#インストールと使い方">インストールと使い方</a></h2>
<p><a href="https://getcomposer.org/download/">公式の解説</a>に従い、ダウンロード、インストールしてください。</p>
<p>使用方法については<a href="https://getcomposer.org/doc/">ドキュメント</a>を参照してください。</p>
<h2 id="パッケージ"><a class="header" href="#パッケージ">パッケージ</a></h2>
<p><a href="https://packagist.org">Packagist.org</a>に公開されているパッケージがあります。</p>
<p>私有パッケージのホスティングについては<a href="https://packagist.com">私有Packagist</a>をご確認ください。</p>
<h2 id="コミュニティ"><a class="header" href="#コミュニティ">コミュニティ</a></h2>
<p>告知についてはTwitterで<a href="https://twitter.com/packagist">@packagist</a>または<a href="https://twitter.com/seldaek">@seldaek</a>をフォローしたり、<a href="https://twitter.com/search?q=%23composerphp&amp;src=typed_query&amp;f=live">#composerphp</a>ハッシュタグを確認したりしてください。</p>
<p>サポートについては、Stack
Overflowで<a href="https://stackoverflow.com/questions/tagged/composer-php">Composerに関係する良い質問</a>がされてきました。
また、<a href="https://github.com/composer/composer/discussions">GitHubディスカッション</a>も使えます。</p>
<p>本プロジェクトは<a href="https://www.contributor-covenant.org/version/1/4/code-of-conduct/">貢献者の行動規範</a>の元でリリースされている点にご留意ください。
本プロジェクトとコミュニティへ参加すると、これらの条項を遵守することに同意したこととなります。</p>
<h2 id="要件"><a class="header" href="#要件">要件</a></h2>
<h4 id="最新のcomposer"><a class="header" href="#最新のcomposer">最新のComposer</a></h4>
<p>最新版にはPHP 7.2.5以上が必要です。</p>
<h4 id="composer-22-lts長期期間対応"><a class="header" href="#composer-22-lts長期期間対応">Composer 2.2 LTS（長期期間対応）</a></h4>
<p>PHPのバージョン5.3.2から8.1まではComposer (2.2.x)のLTS対応でまだ対応されています。
インストーラの<code>self-update</code>コマンドを走らせると、手元のPHPに見合う適切なComposerのバージョンが自動的に選択されるでしょう。</p>
<h4 id="バイナリの依存関係"><a class="header" href="#バイナリの依存関係">バイナリの依存関係</a></h4>
<ul>
<li><code>7z</code>（ないし<code>7zz</code>）</li>
<li><code>unzip</code>（<code>7z</code>が無い場合）</li>
<li><code>gzip</code></li>
<li><code>tar</code></li>
<li><code>unrar</code></li>
<li><code>xz</code></li>
<li>Git (<code>git</code>)</li>
<li>Mercurial (<code>hg</code>)</li>
<li>Fossil (<code>fossil</code>)</li>
<li>Perforce (<code>p4</code>)</li>
<li>Subversion (<code>svn</code>)</li>
</ul>
<p>大事なことですが、これらのバイナリの依存関係の必要性は個々の用途によって様々です。
しかし殆どの利用者にとっては、Composerに必須な依存関係はたった2つです。
<code>7z</code>（または<code>7zz</code>や<code>unzip</code>）と<code>git</code>です。</p>
<h2 id="作者"><a class="header" href="#作者">作者</a></h2>
<ul>
<li>Nils Adermann | <a href="https://github.com/naderman">GitHub</a>  |
<a href="https://twitter.com/naderman">Twitter</a> | <a href="mailto:naderman@naderman.de">naderman@naderman.de</a> |
<a href="https://naderman.de">naderman.de</a></li>
<li>Jordi Boggiano | <a href="https://github.com/Seldaek">GitHub</a> |
<a href="https://twitter.com/seldaek">Twitter</a> | <a href="mailto:j.boggiano@seld.be">j.boggiano@seld.be</a> |
<a href="https://seld.be">seld.be</a></li>
</ul>
<p>本プロジェクトに参加している<a href="https://github.com/composer/composer/contributors">貢献者</a>の一覧もご参照ください。</p>
<h2 id="セキュリティ報告書"><a class="header" href="#セキュリティ報告書">セキュリティ報告書</a></h2>
<p>慎重を要する問題については全て<a href="mailto:security@packagist.org">security@packagist.org</a>にお送りください。
ありがとうございます。</p>
<h2 id="利用許諾"><a class="header" href="#利用許諾">利用許諾</a></h2>
<p>ComposerはMITライセンスの下で利用が許諾されます。
詳細は<a href="LICENSE">LICENSE</a>をご参照ください。</p>
<h2 id="謝辞"><a class="header" href="#謝辞">謝辞</a></h2>
<ul>
<li>本プロジェクトのSolverについて、openSUSEの<a href="https://en.opensuse.org/openSUSE:Libzypp_satsolver">Libzypp
satsolver</a>のPHP移植を開始しました。</li>
</ul>
<hr />
<p>本和訳にあたっての著作権表示を以下に示します。</p>
<p>Copyright (C) 2013--2015 kohkimakimoto.<br>
Copyright (C) 2022--2024 gemmaro.</p>
<p>この翻訳は<a href="https://github.com/kohkimakimoto">kohkimakimoto</a>氏による翻訳を元に改変を加えています。
同氏の翻訳リポジトリは<a href="https://github.com/kohkimakimoto/getcomposer.org_doc_jp"><code>kohkimakimoto/getcomposer.org_doc_jp</code></a>に、Webサイトは<a href="https://kohkimakimoto.github.io/getcomposer.org_doc_jp/doc/00-intro.html">『Composer ドキュメント日本語訳』の「はじめに」</a>にあります。
コミット<a href="https://github.com/kohkimakimoto/getcomposer.org_doc_jp/commit/9b7073bf08140994039b4c008650a0ce1e3173fb"><code>9b7073bf08140994039b4c008650a0ce1e3173fb</code></a>時点で翻訳されていた範囲は以下の通りです。</p>
<div class="table-wrapper"><table><thead><tr><th>章名</th><th>ファイル</th><th>備考</th></tr></thead><tbody>
<tr><td><a href="https://kohkimakimoto.github.io/getcomposer.org_doc_jp/doc/00-intro.html">イントロダクション</a></td><td><code>doc/00-intro.md</code></td><td></td></tr>
<tr><td><a href="https://kohkimakimoto.github.io/getcomposer.org_doc_jp/doc/01-basic-usage.html">基本的な使い方</a></td><td><code>doc/01-basic-usage.md</code></td><td></td></tr>
<tr><td><a href="https://kohkimakimoto.github.io/getcomposer.org_doc_jp/doc/02-libraries.html">ライブラリ</a></td><td><code>doc/02-libraries.md</code></td><td></td></tr>
<tr><td><a href="https://kohkimakimoto.github.io/getcomposer.org_doc_jp/doc/03-cli.html">コマンドラインインターフェース</a></td><td><code>doc/03-cli.md</code></td><td>「install」節の「オプション」小節まで</td></tr>
<tr><td><a href="https://kohkimakimoto.github.io/getcomposer.org_doc_jp/doc/04-schema.html">composer.json</a></td><td><code>doc/04-schema.md</code></td><td>冒頭部分</td></tr>
<tr><td><a href="https://kohkimakimoto.github.io/getcomposer.org_doc_jp/doc/06-community.html">コミュニティ</a></td><td><code>doc/06-community.md</code></td><td></td></tr>
</tbody></table>
</div>
<p>また、対応するComposer本体のコミットは<a href="https://github.com/composer/composer/commit/a1e4ca4f9bacfd3dc08e0546bff2d30cb006ea27"><code>a1e4ca4f9bacfd3dc08e0546bff2d30cb006ea27</code></a>としました。</p>
<p>本翻訳は上記既訳を最新版に追従することを目的としています。
そのため既訳の修正に加えて新規に追加された原文への訳が含まれます。
本翻訳も原文にしたがい、<a href="https://github.com/composer/composer/blob/main/LICENSE">MITライセンス</a>の下に使用が許諾されます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="導入"><a class="header" href="#導入">導入</a></h1>
<p>ComposerはPHPの依存管理ツールです。
Composerはプロジェクトが依存するライブラリを宣言し管理（インストールやアップデート）できるようにするものです。</p>
<h2 id="依存管理"><a class="header" href="#依存管理">依存管理</a></h2>
<p>ComposerはYumやAptの伝で言うとパッケージ管理ツールでは<strong>ありません</strong>。
「パッケージ」やライブラリを扱いはしますが、プロジェクト毎の管理であって、プロジェクトの内部のディレクトリ（例：<code>vendor</code>）にインストールするのです。
既定では決して大域的にインストールしません。
したがって、依存管理なわけです。
とはいえ便宜上<a href="doc/03-cli.html#global">global</a>コマンドを介して「大域的な」プロジェクトに対応してはいます。</p>
<p>このアイデアは新しいものではありません。
Composerはnodeの<a href="https://www.npmjs.org/">npm</a>やrubyの<a href="https://bundler.io/">bundler</a>に強く影響を受けています。</p>
<p>想像してみてください。</p>
<ol>
<li>大量のライブラリに依存したプロジェクトがある。</li>
<li>別のライブラリに依存するライブラリがある。</li>
</ol>
<p>Composerでは次のことができます。</p>
<ol>
<li>依存するライブラリを宣言できる。</li>
<li>どのパッケージのどのバージョンをインストールする必要があるのかを調べて、インストールする（つまりプロジェクト内にパッケージをダウンロードします）。</li>
<li>1つのコマンドで全ての依存関係を更新できます。</li>
</ol>
<p>依存関係の宣言についての詳細は<a href="doc/01-basic-usage.html">基本的な使い方</a>の章を参照してください。</p>
<h2 id="システム要件"><a class="header" href="#システム要件">システム要件</a></h2>
<p>最新のComposerが動作するためにはPHP 7.2.5が必要です。
歴史的なPHPのバージョンで止まっている場合は長期サポート版 (2.2.x) がまだPHP 5.3.2以上に対応しています。
また、いくつかの細かいPHPの設定とコンパイルフラグも必要ですが、要件が合っていない箇所については、インストーラが警告を出すでしょう。</p>
<p>Composerが効率的に動作するには、幾つかの補助的なアプリケーションが必要です。
これらはパッケージの依存関係を扱う処理をより効率的にするものです。
ファイルを解凍するために、Composerは<code>7z</code>（或いは<code>7zz</code>）、<code>gzip</code>、<code>tar</code>、<code>unrar</code>、<code>unzip</code>、<code>xz</code>のようなツールに依っています。
バージョン管理システムについては、ComposerはFossil、Git、Mercurial、Perforce、Subversionと間断なく協調し、これにより円滑なアプリケーションの操作とライブラリのリポジトリの管理を確実にします。
Composerを使う前にこれらの依存関係が正しくシステムにインストールされていることをご確認ください。</p>
<p>Composerはマルチプラットフォームであり、Windows、Linux、macOSのそれぞれで同じように動作するよう努めています。</p>
<h2 id="linux--unix--macosへのインストール"><a class="header" href="#linux--unix--macosへのインストール">Linux / Unix / macOSへのインストール</a></h2>
<h3 id="実行形式のcomposerをダウンロード"><a class="header" href="#実行形式のcomposerをダウンロード">実行形式のComposerをダウンロード</a></h3>
<p>Composerには便利なインストーラがあり、コマンドラインから直接実行できます。
気兼ねなく<a href="https://getcomposer.org/installer">このファイルをダウンロード</a>したり、インストーラの内部のはたらきについてもっと知りたいと思ったら<a href="https://github.com/composer/getcomposer.org/blob/main/web/installer">GitHub</a>で確認したりしてください。
ソースは単なるPHPです。</p>
<p>平たく言うとComposerのインストールには2つの方法があります。
プロジェクトへローカルに入れる方法と、システム全域の実行ファイルとしてグローバルに入れる方法です。</p>
<h4 id="ローカル"><a class="header" href="#ローカル">ローカル</a></h4>
<p>Composerをローカルにインストールするためには、プロジェクトのディレクトリでインストーラを走らせてください。
解説は<a href="https://getcomposer.org/download/">ダウンロードページ</a>を参照してください。</p>
<p>インストーラははいくつかのPHPの設定内容を確認して、<code>composer.phar</code>を作業ディレクトリにダウンロードします。
このファイルはComposerのバイナリです。
PHAR (PHP archive) はPHPのためのアーカイブ形式であり、コマンドラインから実行できますし、他の方法もあります</p>
<p>ここでComposerを走らせるには<code>php composer.phar</code>としてください。</p>
<p><code>--install-dir</code>オプションを使って特定のディレクトリに、更に<code>--filename</code>オプションを使って命名（改名）しつつ、Composerをインストールできます。
<a href="https://getcomposer.org/download/">ダウンロードページの説明</a>に従ってインストーラを走らせるときは、以下の引数を加えてください。</p>
<pre><code class="language-shell">php composer-setup.php --install-dir=bin --filename=composer
</code></pre>
<p>それから、<code>php bin/composer</code>とするとComposerが走ります。</p>
<h4 id="大域的に使う"><a class="header" href="#大域的に使う">大域的に使う</a></h4>
<p>Composer PHARは好きな場所に置くことができます。
<code>PATH</code>の通った場所に置くことで大域的にアクセスできます。
Unix系のシステムでは実行形式にして<code>php</code>インタプリタを直接使わずに呼び出すこともできます。</p>
<p><a href="https://getcomposer.org/download/">ダウンロードページの説明</a>に従ってインストーラを走らせた後は、以下を走らせてパスにあるディレクトリにcomposer.pharを移動させられます。</p>
<pre><code class="language-shell">mv composer.phar /usr/local/bin/composer
</code></pre>
<p>利用者のためだけにインストールしてルート権限を避けたいようでしたら、代わりに<code>~/.local/bin</code>を使うこともできます。
Linuxディストリビューションでは既定で使えることがあります。</p>
<blockquote>
<p><strong>注意:</strong> 上記がパーミッションによって失敗する場合、sudoで改めて実行する必要があるかもしれません。</p>
</blockquote>
<blockquote>
<p><strong>補足：</strong> macOSのバージョンによって、既定では<code>/usr</code>ディレクトリが存在しないことがあります。
エラー「/usr/local/bin/composer: No such file or directory」が出たら、予め<code>mkdir -p /usr/local/bin</code>としてディレクトリを手作りしなければなりません。</p>
</blockquote>
<blockquote>
<p><strong>補足：</strong> パスを変えることに関しては<a href="https://en.wikipedia.org/wiki/PATH_(variable)">Wikipediaの記事</a>を読んだりお好みの検索エンジンに掛けてみてください。</p>
</blockquote>
<p>これで<code>php composer.phar</code>の代わりに<code>composer</code>とすれば、Composerが走るようになりました。</p>
<h2 id="windowsへインストール"><a class="header" href="#windowsへインストール">Windowsへインストール</a></h2>
<h3 id="インストーラを使う"><a class="header" href="#インストーラを使う">インストーラを使う</a></h3>
<p>Composerをマシンに用意する最も簡単な方法です。</p>
<p><a href="https://getcomposer.org/Composer-Setup.exe">Composer-Setup.exe</a>をダウンロードして実行してください。
最新バージョンのComposerがインストールされパスが設定されるため、どのディレクトリからも<code>composer</code>をコマンドラインから呼ぶことができます。</p>
<blockquote>
<p><strong>補足：</strong> 現在の端末を閉じてください。
新しい端末で使えるか試してみてください。
パスは端末が起動したときにのみ読み込まれるので、一旦閉じるのは大事です。</p>
</blockquote>
<h3 id="手動でインストール"><a class="header" href="#手動でインストール">手動でインストール</a></h3>
<p><code>composer.phar</code>をダウンロードするため、<code>PATH</code>の通っているディレクトリに移動して<a href="https://getcomposer.org/download/">ダウンロードページの説明</a>に従い、インストーラを走らせてください。</p>
<p><code>composer.bat</code>ファイルを<code>composer.phar</code>と同じ場所に新規作成してください。</p>
<p>cmd.exeを使う場合：</p>
<pre><code class="language-shell">C:\bin&gt; echo @php "%~dp0composer.phar" %*&gt;composer.bat
</code></pre>
<p>PowerShellを使う場合：</p>
<pre><code class="language-shell">PS C:\bin&gt; Set-Content composer.bat '@php "%~dp0composer.phar" %*'
</code></pre>
<p>まだPATH環境変数にディレクトリがなければ追加してください。
PATH変数を変えることに関しては<a href="https://www.computerhope.com/issues/ch000549.htm">この記事</a>を参照したりお好みの検索エンジンに掛けてみたりしてください。</p>
<p>現在の端末を閉じてください。
新しい端末で使えるか試してください。</p>
<pre><code class="language-shell">C:\Users\username&gt;composer -V
</code></pre>
<pre><code class="language-text">Composer version 2.4.0 2022-08-16 16:10:48
</code></pre>
<h2 id="dockerイメージ"><a class="header" href="#dockerイメージ">Dockerイメージ</a></h2>
<p>Composerはいくつかの場所でDockerコンテナとして公開されています。
<a href="https://github.com/composer/docker">composer/dockerのREADME</a>で一覧を参照してください。</p>
<p>使用例：</p>
<pre><code class="language-shell">docker pull composer/composer
docker run --rm -it -v "$(pwd):/app" composer/composer install
</code></pre>
<p>既存の<strong>Dockerfile</strong>にComposerを加えるには、単に既にビルドされた小さいサイズのイメージからバイナリファイルを複製できます。</p>
<pre><code class="language-Dockerfile"># 最新リリース
COPY --from=composer/composer:latest-bin /composer /usr/bin/composer

# 特定のリリース
COPY --from=composer/composer:2-bin /composer /usr/bin/composer
</code></pre>
<p>さらなる使い方の情報については<a href="https://hub.docker.com/r/composer/composer">イメージの説明</a>をお読みください。</p>
<p><strong>補足：</strong> Docker固有の問題は<a href="https://github.com/composer/docker/issues">composer/dockerリポジトリ</a>に報告されると良いでしょう。</p>
<p><strong>補足：</strong> 上のイメージ名では<code>composer/composer</code>の代わりに<code>composer</code>を使うこともできます。
名前が短かく、Dockerの公式イメージですが、直接私達が公開したものではないので新しいリリースが数日送れで来ることが普通です。
<strong>重要</strong>：短い別名が付けられたイメージにはバイナリのみの同じものがないため、<code>COPY --from</code>の方法については<code>composer/composer</code>のほうを使う方が良いです。</p>
<h2 id="composerを使う"><a class="header" href="#composerを使う">Composerを使う</a></h2>
<p>これでComposerをインストールしたので使う準備ができました。
簡単な実演があるので次の章に向かいましょう。</p>
<p><a href="doc/01-basic-usage.html">基本的な使い方</a> →</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本的な使い方"><a class="header" href="#基本的な使い方">基本的な使い方</a></h1>
<h2 id="導入-1"><a class="header" href="#導入-1">導入</a></h2>
<p>基礎的な使い方の導入として、ここではログライブラリである<code>monolog/monolog</code>をインストールします。
まだComposerをインストールしていなければ、<a href="doc/00-intro.html">はじめに</a>章を参照してください。</p>
<blockquote>
<p><strong>補足：</strong> 簡潔のために、この導入ではComposerの<a href="doc/00-intro.html#locally">ローカル</a>インストールを実施した前提で進めます。</p>
</blockquote>
<h2 id="composerjson-プロジェクトの立ち上げ"><a class="header" href="#composerjson-プロジェクトの立ち上げ"><code>composer.json</code>: プロジェクトの立ち上げ</a></h2>
<p>プロジェクトでComposerを使い始めるにあたって必要なのは<code>composer.json</code>ファイルだけです。
このファイルにはプロジェクトの依存関係が記述され、他のメタデータも含まれることがあります。
大抵プロジェクトやVCSリポジトリの最上位ディレクトリにあります。
技術的にはComposerをどこで実行することもできますが、パッケージをPackagist.orgに公開したいならば、VCSリポジトリの一番上の階層にファイルがなければなりません。</p>
<h3 id="requireキー"><a class="header" href="#requireキー"><code>require</code>キー</a></h3>
<p>最初に<code>composer.json</code>で指定するものは、<a href="doc/04-schema.html#require"><code>require</code></a>キーです。
Composerにプロジェクトが依存しているパッケージがどれであるかを伝えるものです。</p>
<pre><code class="language-json">{
    "require": {
        "monolog/monolog": "2.0.*"
    }
}
</code></pre>
<p>見ての通り、<a href="doc/04-schema.html#require"><code>require</code></a>は<strong>パッケージ名</strong>（例：<code>monolog/monolog</code>）と
<strong>パッケージバージョン</strong>（例：<code>1.0.*</code>）を対応付けるオブジェクトを取ります。</p>
<p>Composerはこの情報を使って、<a href="doc/04-schema.html#repositories"><code>repositories</code></a>キーからパッケージ「リポジトリ」や、既定のパッケージレジストリである<a href="https://packagist.org">Packagist.org</a>にある正しいファイル一式を探します。
上の例ではこれといったリポジトリは<code>composer.json</code>ファイルに登録されていないので、<code>monolog/monolog</code>パッケージはPackagist.orgに登録されているものと推定されます（詳細は<a href="doc/01-basic-usage.html#packagist">Packagistについて</a>と<a href="doc/05-repositories.html">リポジトリについて</a>を参照）。</p>
<h3 id="パッケージ名"><a class="header" href="#パッケージ名">パッケージ名</a></h3>
<p>パッケージ名はベンダー名とプロジェクト名から成ります。
これらはしばしば同一になります。
すなわち、ベンダー名は命名が衝突するのを避けるためだけにあります。
例えば異なる2人の人物が<code>json</code>という名前のライブラリを<code>igorw/json</code>と<code>seldaek/json</code>とそれぞれ命名して作成できます。</p>
<p>詳細は<a href="doc/02-libraries.html">パッケージの公開とパッケージの命名</a>を読んでください（なお「プラットフォームパッケージ」を依存関係として指定することも可能で、サーバーのソフトウェアの特定のバージョンを要求できます。
<a href="doc/01-basic-usage.html#platform-packages">プラットフォームパッケージ</a>で後述します）。</p>
<h3 id="パッケージバージョン制約"><a class="header" href="#パッケージバージョン制約">パッケージバージョン制約</a></h3>
<p>先の例ではバージョン制約<a href="https://semver.madewithlove.com/?package=monolog%2Fmonolog&amp;constraint=2.0.*"><code>2.0.*</code></a>のMonologパッケージを要求しています。
これが意味するものは<code>2.0</code>の開発ブランチの任意のバージョン、言い換えると2.0以上で2.1より小さい（<code>&gt;=2.0 &lt;2.1</code>）任意のバージョンのことを指します。</p>
<p>バージョンとバージョン間の関連、バージョン制約についてのより詳しい情報は<a href="doc/articles/versions.html">バージョン</a>を読んでください。</p>
<blockquote>
<p><strong>どうやってComposerは正しいファイルをダウンロードしているのか。</strong>
<code>composer.json</code>に依存関係を指定したとき、Composerはまず、<a href="doc/04-schema.html#repositories"><code>repositories</code></a>キーを使って登録された全てのリポジトリを対象に要求されたパッケージの名前を検索します。
もし1つも追加でリポジトリを登録していなかったり、指定したリポジトリにその名前のパッケージがなかったときは、Packagist.org（<a href="doc/01-basic-usage.html#packagist">後述</a>）に落ち着きます。</p>
<p>ComposerがPackagist.orgないし指定したリポジトリで正しいパッケージがあったときは、パッケージのVCSのバージョン機能（つまりブランチとタグ）を使って、指定したバージョン制約に最も合致するものを見付け出そうとします。
必ず<a href="doc/articles/versions.html">バージョンについての記事</a>でバージョンとパッケージについて読んでください。</p>
</blockquote>
<blockquote>
<p><strong>補足：</strong> もしパッケージを要求したもののComposerがパッケージの安定性の理由で例外を投げた場合は、指定したバージョンが既定の最小の安定要件に見合わない可能性があります。
VCSで妥当なパッケージバージョンを探す際、既定では安定リリースのみが考慮されます。</p>
<p>パッケージの開発版、アルファ版、ベータ版、リリース候補のバージョンを要求しようとしたときに、この例外に遭遇するかもしれません。
安定性フラグと<code>minimum-stability</code>キーについての詳細は<a href="doc/04-schema.html">スキーマのページ</a>をお読みください。</p>
</blockquote>
<h2 id="依存物をインストール"><a class="header" href="#依存物をインストール">依存物をインストール</a></h2>
<p>定義された依存関係をプロジェクトに初めてインストールするときは、<a href="doc/03-cli.html#update-u"><code>update</code></a>コマンドを走らせると良いです。</p>
<pre><code class="language-shell">php composer.phar update
</code></pre>
<p>こうするとComposerは2つのことをします。</p>
<ul>
<li><code>composer.json</code>ファイルに挙げられている全ての依存関係を解決して、全てのアッケージとその厳密なバージョンを<code>composer.lock</code>ファイルに書き込みます。
このファイルによりプロジェクトが特定のバージョンに固定されます。
<code>composer.lock</code>ファイルはプロジェクトのリポジトリにコミットすべきです。
そうすればプロジェクトに参画する全員にとって、同じバージョンの依存関係に固定されたものになります（詳細は後述）。
これが<code>update</code>コマンドの主な役割です。</li>
<li>それから暗黙裡に<a href="doc/03-cli.html#install-i"><code>install</code></a>コマンドが走ります。
これにより依存関係のファイルがプロジェクトの<code>vendor</code>ディレクトリにダウンロードされます（<code>vendor</code>ディレクトリはプロジェクトの全てのサードパーティコード用の定番の場所です）。
上の例では最終的にMonologのソースファイルが<code>vendor/monolog/monolog</code>にあることになります。
Monologには<code>psr/log</code>への依存関係があるため、そのパッケージのファイルもまた<code>vendor/</code>の中にあります。</li>
</ul>
<blockquote>
<p><strong>コツ：</strong> gitをプロジェクトで使っているのなら、多分<code>.gitignore</code>に<code>vendor</code>を追加したいでしょう。
実際のところ、バージョン管理されたリポジトリにサードパーティ製のコード全てを追加したくはないので。</p>
</blockquote>
<h3 id="composerlockファイルをバージョン管理にコミットすること"><a class="header" href="#composerlockファイルをバージョン管理にコミットすること"><code>composer.lock</code>ファイルをバージョン管理にコミットすること</a></h3>
<p>このファイルをバージョン管理にコミットすることは大事です。
なぜならこうすることでプロジェクトの準備をする誰もが、自分が使っているものと全く同じバージョンの依存関係を使えるようになるからです。
CIサーバ、実運用マシン、チーム内の他の開発者、万物万人が同じ依存関係で実行するのです。
これにより特定のデプロイでのみ影響する潜在的なバグが低減されます。
たとえ一人で開発していて、6箇月経ってからプロジェクトを再インストールしたとしても、そして依存関係が多くの新しいバージョンをリリースされていたとしても、インストールされた依存関係がちゃんと動くことは疑いありません（<code>update</code>コマンドの使用については以下の補足を参照してください）。</p>
<blockquote>
<p><strong>補足：</strong>
ライブラリの場合、固定ファイルのコミットは不必要です。
<a href="doc/02-libraries.html#lock-file">ライブラリ - 固定ファイル</a>も参照してください。</p>
</blockquote>
<h3 id="composerlockからインストールする"><a class="header" href="#composerlockからインストールする"><code>composer.lock</code>からインストールする</a></h3>
<p>既に<code>composer.lock</code>ファイルがプロジェクトフォルダにあるなら、それは前に自分で<code>update</code>コマンドを走らせたか、プロジェクトの誰かが<code>update</code>コマンドを走らせて<code>composer.lock</code>ファイルをプロジェクトにコミットしたからかのどちらかです（いいことです）。</p>
<p>何れにせよ、<code>composer.lock</code>ファイルが存在しているときに<code>install</code>を走らせると<code>composer.json</code>に挙がっている全ての依存関係を解決してインストールします。
ただしその際はプロジェクトの作業をしている人全員にとってパッケージのバージョンが必ず一貫したものになるように、Composerは<code>composer.lock</code>に挙げられた厳密なバージョンを使用します。
結果として<code>composer.json</code>ファイルで要求された全ての依存関係が取得されるのですが、必ずしも利用できるごく最新のバージョンとはなっていないかもしれません（ファイルが作成された後に、<code>composer.lock</code>ファイルで挙げられた依存関係のより新しいバージョンがリリースされる可能性があります）。
これは設計上意図されたものであり、依存関係での予期しない変更による不具合がプロジェクトで絶対に発生しないようになっています。</p>
<p>そのためVCSリポジトリから新しい変更を取得した後は、Composerの<code>install</code>を走らせて、vendorディレクトリが<code>composer.lock</code>ファイルと同期していることを確かめることをお勧めします。</p>
<pre><code class="language-shell">php composer.phar install
</code></pre>
<p>Composerは既定で再生成可能な構築を有効にします。
つまり同じコマンドを複数回走らせると、自動読み込み器のファイルを含め、（<em>タイムスタンプ以外</em>）同値なファイルを含む<code>vendor/</code>ディレクトリを生成するのです。
厳密な検証過程を要求する環境や、PHPアプリケーションを安全で予測可能なやり方でパッケージ化することを目指すLinuxディストリビューションにおいては、特に有益です。</p>
<h2 id="最新版に依存関係を更新する"><a class="header" href="#最新版に依存関係を更新する">最新版に依存関係を更新する</a></h2>
<p>前述したように、<code>composer.lock</code>ファイルは自動的に依存関係の最新版が取得されるのを防ぎます。
最新のバージョンに更新するには<a href="doc/03-cli.html#update-u"><code>update</code></a>コマンドを使います。
こうすると（<code>composer.json</code>ファイルに沿うように）照合する最新バージョンを取得して新しいバージョンで固定ファイルを更新します。</p>
<pre><code class="language-shell">php composer.phar update
</code></pre>
<blockquote>
<p><strong>補足：</strong> <code>composer.json</code>に依存関係解決に影響し得る変更が加えられた後に<code>composer.lock</code>が更新されていなければ、<code>install</code>コマンドを実行するときに、Composerが警告を表示します。</p>
</blockquote>
<p>1つの依存関係をインストール、更新、削除したいだけなら、引数として明示的に列挙できます。</p>
<pre><code class="language-shell">php composer.phar update monolog/monolog [...]
</code></pre>
<h2 id="packagist"><a class="header" href="#packagist">Packagist</a></h2>
<p><a href="https://packagist.org/">Packagist</a>は主眼のComposerリポジトリです。
Composerリポジトリは基本的にはパッケージの源です。
つまりパッケージを取ってくることができる場所のことです。
Packagistは全ての人が利用できる中央リポジトリであることを目指しています。
要はここで利用できるいかなるパッケージも自動的に<code>require</code>できるということです。
Composerがパッケージを探す場所を追加で指定しなくて良いのです。</p>
<p><a href="https://packagist.org/">packagistのWebサイト</a>では、パッケージを閲覧したり検索したりできます。</p>
<p>Composerを使っているオープンソースプロジェクトはパッケージをPackagist上で公開するべきです。
Composerを使う上で、ライブラリをPackagistに載せる必要はありません。
しかし公開することで、他の開発者がより素早くパッケージを発見して取り入れられるようになります。</p>
<h2 id="プラットフォームパッケージ"><a class="header" href="#プラットフォームパッケージ">プラットフォームパッケージ</a></h2>
<p>Composerにはプラットフォームパッケージがあります。
システムにインストールされる仮想的なパッケージで、実際にはComposerではインストールされないものを指します。
PHP自身やPHP拡張、システムライブライリが含まれます。</p>
<ul>
<li>
<p><code>php</code>は利用者のPHPバージョンを表しており、<code>^7.1</code>のような制約を適用できます。
PHPの64bitバージョンを要求するには、<code>php-64bit</code>パッケージを指定できます。</p>
</li>
<li>
<p><code>hhvm</code>はHHVMランタイムのバージョンを表しており、<code>^2.3</code>のように制約を適用できます。</p>
</li>
<li>
<p><code>ext-&lt;name&gt;</code>とすることでPHPの拡張を要件にできます（中核拡張を含みます）。
バージョニングはかなり一貫性がないことがあるので、大体の場合は制約に<code>*</code>を設定するのと良いです。
拡張パッケージ名の例は<code>ext-gd</code>です。</p>
</li>
<li>
<p><code>lib-&lt;name&gt;</code>はPHPで使われるライブラリのバージョンを制約します。
次のものが利用できます：<code>curl</code>, <code>iconv</code>, <code>icu</code>, <code>libxml</code>, <code>openssl</code>, <code>pcre</code>, <code>uuid</code>,
<code>xsl</code>。</p>
</li>
</ul>
<p><a href="doc/03-cli.html#show"><code>show --platform</code></a>を使うと、ローカルで利用できるプラットフォームパッケージの一覧が得られます。</p>
<h2 id="自動読み込み"><a class="header" href="#自動読み込み">自動読み込み</a></h2>
<p>自動読み込み情報を指定するライブラリ用に、Composerは<code>vendor/autoload.php</code>ファイルを生成します。
単にこのファイルを含めれば、他に手間を掛けずにそれらのライブラリが提供するクラスを使い始められます。</p>
<pre><code class="language-php">require __DIR__ . '/vendor/autoload.php';

$log = new Monolog\Logger('name');
$log-&gt;pushHandler(new Monolog\Handler\StreamHandler('app.log', Monolog\Logger::WARNING));
$log-&gt;warning('Foo');
</code></pre>
<p><code>composer.json</code>に<a href="doc/04-schema.html#autoload"><code>autoload</code></a>フィールドを追加すれば、自分のコードについても自動読み込み器に追加できます。</p>
<pre><code class="language-json">{
    "autoload": {
        "psr-4": {"Acme\\": "src/"}
    }
}
</code></pre>
<p>ここではComposerが<a href="https://www.php-fig.org/psr/psr-4/">PSR-4</a>自動読み込み器を<code>Acme</code>名前空間に登録しています。</p>
<p>名前空間からディレクトリへの対応付けが定義されます。
<code>src</code>ディレクトリはプロジェクトの根幹にあり、同じ階層に<code>vendor</code>もあるとしましょう。
ファイル名の例としては<code>Acme\Foo</code>クラスを含む<code>src/Foo.php</code>があります。</p>
<p><a href="doc/04-schema.html#autoload"><code>autoload</code></a>フィールドを追加した後は、このコマンドを再び走らせなくてはなりません。</p>
<pre><code class="language-shell">php composer.phar dump-autoload
</code></pre>
<p>このコマンドは<code>vendor/autoload.php</code>ファイルを再生成します。
詳細は<a href="doc/03-cli.html#dump-autoload-dumpautoload-"><code>dump-autoload</code></a>節を参照してください。</p>
<p>自動読み込みファイルを含めるとautoloaderインスタンスを返します。
そのためインクルード呼び出しの返り値を変数に保持し、更に名前空間を追加できます。
テストスイート内での自動読み込みクラスに便利です。
例えば以下です。</p>
<pre><code class="language-php">$loader = require __DIR__ . '/vendor/autoload.php';
$loader-&gt;addPsr4('Acme\\Test\\', __DIR__);
</code></pre>
<p>PSR-4自動読み込みに加えて、ComposerはPSR-0、クラスマップ、ファイル自動読み込みにも対応しています。
詳細は<a href="doc/04-schema.html#autoload"><code>autoload</code></a>リファレンスを参照してください。</p>
<p><a href="doc/articles/autoloader-optimization.html">autoloaderの最適化</a>についてのドキュメントも参照してください。</p>
<blockquote>
<p><strong>注意：</strong> Composerは自前の自動読み込み器を提供しています。
もしそれを使いたくない場合は、単に<code>vendor/composer/autoload_*.php</code>ファイルを含められます。
自前の自動読み込み器を設定できる連想配列を返します。</p>
</blockquote>
<p>← <a href="doc/00-intro.html">導入</a>  |  <a href="doc/02-libraries.html">ライブラリ</a> →</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ライブラリ"><a class="header" href="#ライブラリ">ライブラリ</a></h1>
<p>この章ではライブラリをComposerでインストールできるようにする方法を学びます。</p>
<h2 id="全てのプロジェクトはパッケージである"><a class="header" href="#全てのプロジェクトはパッケージである">全てのプロジェクトはパッケージである</a></h2>
<p><code>composer.json</code>をディレクトリに配置した時点で、そのディレクトリはパッケージとなります。
<a href="doc/04-schema.html#require"><code>require</code></a>をプロジェクトに追加すると、他のパッケージに依存したパッケージを作っていることになります。
プロジェクトとライブラリの唯一の違いは、プロジェクトは名前のないパッケージだということです。</p>
<p>インストール可能なパッケージを作成するためには命名する必要があります。
<code>composer.json</code>に<a href="doc/04-schema.html#name"><code>name</code>プロパティ</a>を追加してください。</p>
<pre><code class="language-json">{
    "name": "acme/hello-world",
    "require": {
        "monolog/monolog": "1.0.*"
    }
}
</code></pre>
<p>この例では、プロジェクト名は<code>acme/hello-world</code>です。
<code>acme</code>はベンダー名です。
ベンダー名を与えることは必須です。</p>
<blockquote>
<p><strong>注意：</strong>
もしベンダー名に何をつけていいか分からない場合は、大抵は自分のGitHubの利用者名をつけるといいでしょう。
パッケージ名は全て小文字でなければならず、単語の区切りはダッシュにするのが慣習です。</p>
</blockquote>
<h2 id="ライブラリのバージョン"><a class="header" href="#ライブラリのバージョン">ライブラリのバージョン</a></h2>
<p>まず間違いなくgit, svn, hg, fossilといった何らかの類のバージョン管理システムを使ってライブラリを管理することでしょう。
こうした場合、ComposerはVCSからバージョンを推定するので<code>composer.json</code>ファイルではバージョンを指定すべきでは<strong>ありません</strong>（ComposerがVCSのブランチとタグを使ってバージョン制約を解決する方法について学ぶためには<a href="doc/articles/versions.html">バージョンについての記事</a>を参照してください）。</p>
<p>パッケージの管理を手作業でしている（つまりVCS無しの）場合、<code>composer.json</code>ファイルに<code>version</code>値を加えて、バージョンを明示的に指定する必要があるでしょう。</p>
<pre><code class="language-json">{
    "version": "1.0.0"
}
</code></pre>
<blockquote>
<p><strong>補足：</strong> VCSに埋め込まれているバージョンを加えた場合、バージョンはタグ名と干渉することでしょう。
そうするとComposerはバージョン値を決定できなくなります。</p>
</blockquote>
<h3 id="vcsのバージョン管理"><a class="header" href="#vcsのバージョン管理">VCSのバージョン管理</a></h3>
<p>ComposerはVCSのブランチとタグの機能を使って<a href="doc/04-schema.html#require"><code>require</code></a>フィールドで指定したバージョン制約を特定のファイルの集まりに至るまで解決します。
利用できる妥当なバージョンを決定する際、Composerは全てのタグとブランチを見て、それらの名前を内部的なオプションの一覧に翻訳し、それから与えられたバージョン制約に対して照合します。</p>
<p>Composerがタグとブランチを扱う方法とパッケージのバージョン制約を解決する方法についての詳細は、<a href="doc/articles/versions.html">バージョン</a>の記事をお読みください。</p>
<h2 id="固定ファイル"><a class="header" href="#固定ファイル">固定ファイル</a></h2>
<p>お望みならライブラリに<code>composer.lock</code>ファイルをコミットできます。
チームが常に同じ依存バージョンでテストする際の助けになります。
しかし、この固定ファイルはこれに依存している他のプロジェクトにいかなる影響も齎しません。
主眼のプロジェクトのみに影響します。</p>
<p>もし固定ファイルをコミットしたくなくて、且つgitを使っている場合は、<code>.gitignore</code>に追加してください。</p>
<h2 id="vcsに公開する"><a class="header" href="#vcsに公開する">VCSに公開する</a></h2>
<p><code>composer.json</code>ファイルを含むVCSリポジトリ（バージョン管理システム、例えばgit）があれば、ライブラリは既にcomposerでインストール可能です。
この例ではGitHubで<code>acme/hello-world</code>ライブラリを<code>github.com/username/hello-world</code>として公開するとしましょう。</p>
<p>それでは<code>acme/hello-world</code>パッケージのインストールを試すために、ローカルに新しいプロジェクトを作成しましょう。
私たちはそれを<code>acme/blog</code>と呼ぶことにします。
このブログは<code>acme/hello-world</code>に依存し、更に<code>monolog/monolog</code>に依存するとします。
以下の<code>composer.json</code>を含む新しい<code>blog</code>ディレクトリを作成することで達成されます。</p>
<pre><code class="language-json">{
    "name": "acme/blog",
    "require": {
        "acme/hello-world": "dev-master"
    }
}
</code></pre>
<p>名前はこの場合必須ではありません。
このブログをライブラリとして公開することはないからです。
ここではどの<code>composer.json</code>が説明されているのかを明確にするために加えられています。</p>
<p>このブログアプリに依存物<code>hello-world</code>の所在を知らせる必要があります。
これにはパッケージのリポジトリ指定をこのブログの<code>composer.json</code>に追加します。</p>
<pre><code class="language-json">{
    "name": "acme/blog",
    "repositories": [
        {
            "type": "vcs",
            "url": "https://github.com/username/hello-world"
        }
    ],
    "require": {
        "acme/hello-world": "dev-master"
    }
}
</code></pre>
<p>パッケージリポジトリの挙動や他にどのようなタイプが利用できるかについての詳細は、<a href="doc/05-repositories.html">リポジトリ</a>を参照してください。</p>
<p>これで全てです。
Composerの<a href="doc/03-cli.html#install"><code>install</code></a>コマンドを実行すれば依存関係をインストールできます！</p>
<p><strong>まとめ：</strong>
<code>composer.json</code>を含むあらゆるgit/svn/hg/fossilリポジトリは、<a href="doc/04-schema.html#require"><code>require</code></a>フィールドでパッケージリポジトリを指定して依存関係を宣言することで、プロジェクトに追加できます。</p>
<h2 id="packagistに公開する"><a class="header" href="#packagistに公開する">Packagistに公開する</a></h2>
<p>よろしい、今やパッケージを公開できるようになりました。
しかし、毎回VCSリポジトリを指定するのは厄介なことです。
全ての利用者にそんなことはさせたくないでしょう。</p>
<p><code>monolog/monolog</code>のためのパッケージリポジトリを指定しなかったこととにお気付きかもしれません。
どのような仕組みなのでしょうか？
答えはPackagistです。</p>
<p><a href="https://packagist.org/">Packagist</a>はComposerの主眼のパッケージリポジトリで、 既定で有効になっています。
Packagistで公開されている全てのものは自動的にComposerで利用可能です。
<a href="https://packagist.org/packages/monolog/monolog">monologはPackagistにある</a>ので、追加のリポジトリ指定なくして依存できるのです。</p>
<p><code>hello-world</code>を世界に共有したければ、同様にPackagistに公開するのが良いでしょう。</p>
<p><a href="https://packagist.org">Packagist</a>を開いて"Submit"ボタンを押します。
まだサインアップしていなかったらその旨の表示がされます。
それからVCSリポジトリのURLを送信できます。
送信した時点でPackagistはクローリングを始めます。
完了すると、パッケージは誰でも使えるようになります！</p>
<h2 id="軽量配布パッケージ"><a class="header" href="#軽量配布パッケージ">軽量配布パッケージ</a></h2>
<p>有用でない情報は普通、配布パッケージに含めない方が良いでしょう。
これには<code>.github</code>ディレクトリ、嵩張る例、テストデータなどがあります。</p>
<p><code>.gitattributes</code>ファイルは<code>.gitignore</code>のようなgit固有のファイルです。
またライブラリの根幹ディレクトリにあります。
これが存在してgitで追跡されているとき、局所的な構成と大域的な構成（それぞれ<code>.git/config</code>と<code>~/.gitconfig</code>）がオーバーライドされます。</p>
<p>zipの配布パッケージが肥大化させる望ましくないファイルが入らないようにするには、<code>.gitattributes</code>を使ってください。</p>
<pre><code class="language-text">// .gitattributes
/demo export-ignore
phpunit.xml.dist export-ignore
/.github/ export-ignore
</code></pre>
<p>生成されたzipファイルを手作業で調べて確認するには、次のようにします。</p>
<pre><code class="language-shell">git archive branchName --format zip -o file.zip
</code></pre>
<blockquote>
<p><strong>補足：</strong>
ファイルはgitで追跡されたままであり、zipの配布物に含まれていないだけです。
これはdist（タグ付けされたリリース）でインストールしたパッケージでのみ機能します。
配布元はGitHub、GitLab、BitBucketがあります。</p>
</blockquote>
<p>← <a href="doc/01-basic-usage.html">基本的な使い方</a> |  <a href="doc/03-cli.html">コマンドラインインターフェース</a> →</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="コマンドラインインターフェース--コマンド"><a class="header" href="#コマンドラインインターフェース--コマンド">コマンドラインインターフェース / コマンド</a></h1>
<p>既にいろいろなことをするために、コマンドラインインターフェースの使い方は学びました。
この章は全ての利用可能なコマンドを説明します。</p>
<p>コマンドラインからヘルプを得るためには、<code>composer</code>または<code>composer list</code>を実行して全てのコマンドの完全な一覧を見ることができます。
更に<code>--help</code>をそれらのコマンドと組み合わせれば、より多くの情報を得られます。</p>
<p>Composerは<a href="https://github.com/symfony/console">symfony/console</a>を使っているため、曖昧でなければ短い名前でコマンドを呼び出せます。</p>
<pre><code class="language-shell">php composer.phar dump
</code></pre>
<p>上では<code>composer dump-autoload</code>を呼び出します。</p>
<h2 id="bashの補完"><a class="header" href="#bashの補完">Bashの補完</a></h2>
<p>Bashの補完をインストールするには、<code>composer completion bash &gt; completion.bash</code>と走らせられます。
現在のディレクトリに<code>completion.bash</code>ファイルを作ります。</p>
<p>それから<code>source completion.bash</code>を実行すれば現在の端末のセッションで有効になります。</p>
<p><code>completion.bash</code>を<code>/etc/bash_completion.d/composer</code>に移動しつつ改名すれば、新しい端末で自動的に読み込まれるようにできます。</p>
<h2 id="大域オプション"><a class="header" href="#大域オプション">大域オプション</a></h2>
<p>以下のオプションは全てのコマンドで利用できます。</p>
<ul>
<li><strong>--verbose (-v):</strong> メッセージの冗長さを増やす。</li>
<li><strong>--help (-h):</strong> ヘルプ情報を表示する。</li>
<li><strong>--quiet (-q):</strong> メッセージを一切出力しない。</li>
<li><strong>--no-interaction (-n):</strong>
対話的な質問の問い合わせを一切行わない。</li>
<li><strong>--no-plugins:</strong> プラグインを無効にする。</li>
<li><strong>--no-scripts:</strong> <code>composer.json</code>で定義されているスクリプトの実行を飛ばす。</li>
<li><strong>--no-cache:</strong> キャッシュディレクトリの使用を無効にする。
COMPOSER_CACHE_DIR環境変数を<code>/dev/null</code>（WindowsではNUL）に設定することと同じです。</li>
<li><strong>--working-dir (-d):</strong> 指定すると、与えられたディレクトリを作業ディレクトリに使う。</li>
<li><strong>--profile:</strong> 時間とメモリ使用量の情報を表示する。</li>
<li><strong>--ansi:</strong> ANSI出力を強制する。</li>
<li><strong>--no-ansi:</strong> ANSI出力を行わない。</li>
<li><strong>--version (-V):</strong> 本アプリケーションのバージョンを表示する。</li>
</ul>
<h2 id="プロセスの終了コード"><a class="header" href="#プロセスの終了コード">プロセスの終了コード</a></h2>
<ul>
<li><strong>0:</strong> OK</li>
<li><strong>1:</strong> 一般的ないし不明な失敗コード</li>
<li><strong>2:</strong> 依存解決の失敗コード</li>
</ul>
<h2 id="init"><a class="header" href="#init">init</a></h2>
<p><a href="doc/02-libraries.html">ライブラリ</a>の章で<code>composer.json</code>を手作りする方法を見ました。
こうしたことをするのに<code>init</code>コマンドというのもあります。</p>
<p>このコマンドを実行すると、賢明な既定値を使いながら、対話的な問答を経てフィールドが埋められていきます。</p>
<pre><code class="language-shell">php composer.phar init
</code></pre>
<h3 id="オプション"><a class="header" href="#オプション">オプション</a></h3>
<ul>
<li><strong>--name:</strong> パッケージの名前。</li>
<li><strong>--description:</strong> パッケージの説明。</li>
<li><strong>--author:</strong> パッケージの作者名。</li>
<li><strong>--type:</strong> パッケージの種類。</li>
<li><strong>--homepage:</strong> パッケージのホームページ。</li>
<li><strong>--require:</strong> バージョン制約付きの必要なパッケージ。書式は<code>foo/bar:1.0.0</code>のようになります。</li>
<li><strong>--require-dev:</strong> 開発のための要件です。<strong>--require</strong>を参照。</li>
<li><strong>--stability (-s):</strong> <code>minimum-stability</code>フィールド用の値。</li>
<li><strong>--license (-l):</strong> パッケージの利用許諾。</li>
<li><strong>--repository:</strong> 1つ（かそれ以上）の個別のリポジトリを与えます。
これらのリポジトリは生成されるcomposer.jsonに収められ、要件の一覧を提案する際の自動補完に使われます。
全てのリポジトリは<code>composer</code>リポジトリを指すHTTPのURLないし<a href="doc/04-schema.html#repositories">repositories</a>キーが受け付けるものと同様のJSON文字列の何れかを取ります。</li>
<li><strong>--autoload (-a):</strong> composer.jsonへのPSR-4自動読み込みの対応付けを加えます。
自動的にパッケージの名前空間を与えられたディレクトリに対応付けます（src/のような相対パスを想定しています）。
<a href="doc/04-schema.html#psr-4">PSR-4自動読み込み</a>も参照してください。</li>
</ul>
<h2 id="install--i"><a class="header" href="#install--i">install / i</a></h2>
<p><code>install</code>コマンドは現在のディレクトリから<code>composer.json</code>ファイルを読み込み、依存物を解決し、<code>vendor</code>配下にインストールします。</p>
<pre><code class="language-shell">php composer.phar install
</code></pre>
<p>現在のディレクトリに<code>composer.lock</code>ファイルが存在する場合は、依存物を解決する代わりに、そこから厳密なバージョンを使います。
ライブラリを使う全ての利用者が同じバージョンの依存物を持つことを保証します。</p>
<p><code>composer.lock</code>ファイルがない場合、composerは依存物を解決した後で作成します。</p>
<h3 id="オプション-1"><a class="header" href="#オプション-1">オプション</a></h3>
<ul>
<li><strong>--prefer-install:</strong> パッケージをダウンロードする方法は<code>source</code>と<code>dist</code>の2つあります。
Composerは<code>dist</code>を既定で使います。
<code>--prefer-install=source</code>（または<code>--prefer-source</code>）を渡すと、Composerは、もしあれば<code>source</code>からインストールします。
プロジェクトへのバグ修正をして、依存関係のローカルgitクローンを直接取得したい場合に便利です。
Composerがパッケージの開発版用の<code>source</code>を自動的に使う、以前の挙動にしたければ、<code>--prefer-install=auto</code>を使ってください。
<a href="doc/06-config.html#preferred-install">config.preferred-install</a>も参照してください。
このフラグを渡すと、設定値より優先されます。</li>
<li><strong>--dry-run:</strong>
実際にはパッケージをインストールすることなくインストールの過程を進めたいときは<code>--dry-run</code>を使うことができます。
インストールを模擬して何が起こるのかを示します。</li>
<li><strong>--download-only:</strong> ダウンロードするのみで、パッケージをインストールしません。</li>
<li><strong>--dev:</strong> <code>require-dev</code>に挙げられたパッケージをインストールします（既定の挙動です）。</li>
<li><strong>--no-dev:</strong> <code>require-dev</code>に挙げられたパッケージのインストールを飛ばします。
自動読み込み器の生成で<code>autoload-dev</code>規則を読み飛ばします。
<a href="doc/03-cli.html#composer-no-dev">COMPOSER_NO_DEV</a>も参照してください。</li>
<li><strong>--no-autoloader:</strong> 自動読み込み器の生成を飛ばします。</li>
<li><strong>--no-progress:</strong>
進捗表示を除きます。
バックスペース文字を扱わない端末やスクリプトではこの表示があることで散らかってしまうからです。</li>
<li><strong>--audit:</strong> インストールが完了した後に監査を走らせます。</li>
<li><strong>--audit-format:</strong> 監査の出力形式です。
"table"、"plain"、"json"、または"summary"（既定）のどれかでなければなりません。</li>
<li><strong>--optimize-autoloader (-o):</strong> PSR-0の自動読み込みをクラス対応表に変換して自動読み込みを高速にします。
実運用では特にお勧めしますが、走らせるのに少し時間が掛かることがあるので、現在は既定ではされません。</li>
<li><strong>--classmap-authoritative (-a):</strong> クラス対応表からクラスのみを自動読み込みします。
暗黙裡に<code>--optimize-autoloader</code>を有効にします。</li>
<li><strong>--apcu-autoloader:</strong> APCuを使って、クラスの有無をキャッシュします。</li>
<li><strong>--apcu-autoloader-prefix:</strong> APCu自動読み込み器のキャッシュ用に独自の接頭辞を使います。
暗黙裡に<code>--apcu-autoloader</code>を有効にします。</li>
<li><strong>--ignore-platform-reqs:</strong>
全てのプラットフォーム要件（<code>php</code>、<code>hhvm</code>、<code>lib-*</code>、<code>ext-*</code>）を無視し、ローカルマシンがたとえこれらを満たしていなくてもインストールを強行します。
<a href="doc/06-config.html#platform"><code>platform</code></a>設定オプションも参照してください。</li>
<li><strong>--ignore-platform-req:</strong>
特定のプラットフォーム要件（<code>php</code>、<code>hhvm</code>、<code>lib-*</code>、<code>ext-*</code>）を無視し、ローカルマシンがたとえこれらを満たしていなくてもインストールを強行します。
ワイルドカードを使って複数の要件を無視できます。
<code>+</code>を後ろに付けることで要件の上限値だけを無視できます。
例えばパッケージが<code>php: ^7</code>を要求しているとき、オプション<code>--ignore-platform-req=php+</code>はPHP8でのインストールを許しますが、PHP
5.6でのインストールについては失敗します。</li>
</ul>
<h2 id="update--u--upgrade"><a class="header" href="#update--u--upgrade">update / u / upgrade</a></h2>
<p>依存関係の最新版を取得して<code>composer.lock</code>ファイルを更新する上では<code>update</code>コマンドを使うと良いでしょう。
このコマンドには<code>upgrade</code>の別名が付けられていますが、<code>apt-get</code>や類するパッケージ管理を連想したときに<code>upgrade</code>がすることと同じだからです。</p>
<pre><code class="language-shell">php composer.phar update
</code></pre>
<p>こうするとプロジェクトの全ての依存関係を解決し、厳密なバージョンを<code>composer.lock</code>に書き込みます。</p>
<p>全てではなく、2、3のパッケージのみを更新したい場合は、以下のように列挙できます。</p>
<pre><code class="language-shell">php composer.phar update vendor/package vendor/package2
</code></pre>
<p>ワイルドカードを使って複数のパッケージを一挙に更新することもできます。</p>
<pre><code class="language-shell">php composer.phar update "vendor/*"
</code></pre>
<p><code>composer.json</code>を変えることなくパッケージを指定のバージョンに巻き戻したいときは、<code>--with</code>を使うことができます。
このオプションには自分で選んだバージョン制約を与えます。</p>
<pre><code class="language-shell">php composer.phar update --with vendor/package:2.0.1
</code></pre>
<p>なお上記では全てのパッケージが更新されます。
<code>--with</code>を使って自分で選んだ制約を与えたパッケージのみを更新するには、<code>--with</code>を省き、代わりに部分的な更新構文を持つ制約を使ってください。</p>
<pre><code class="language-shell">php composer.phar update vendor/package:2.0.1 vendor/package2:3.0.*
</code></pre>
<blockquote>
<p><strong>補足：</strong> composer.jsonでも要求されているパッケージについては、自分で選んだ制約は既存の制約の部分集合でなければなりません。
composer.jsonでの制約は適用されたままであり、これらの一時的な制約の更新では変更されません。</p>
</blockquote>
<h3 id="オプション-2"><a class="header" href="#オプション-2">オプション</a></h3>
<ul>
<li><strong>--prefer-install:</strong> パッケージをダウンロードする方法は<code>source</code>と<code>dist</code>の2つあります。
Composerは<code>dist</code>を既定で使います。
<code>--prefer-install=source</code>（または<code>--prefer-source</code>）を渡すと、Composerは、もしあれば<code>source</code>からインストールします。
プロジェクトへのバグ修正をして、依存関係のローカルgitクローンを直接取得したい場合に便利です。
Composerがパッケージの開発版用の<code>source</code>を自動的に使う、以前の挙動にしたければ、<code>--prefer-install=auto</code>を使ってください。
<a href="doc/06-config.html#preferred-install">config.preferred-install</a>も参照してください。
このフラグを渡すと、設定値より優先されます。</li>
<li><strong>--dry-run:</strong>
実際には何もせず、コマンドを模擬します。</li>
<li><strong>--dev:</strong> <code>require-dev</code>に挙げられたパッケージをインストールします（既定の挙動です）。</li>
<li><strong>--no-dev:</strong> <code>require-dev</code>に挙げられたパッケージのインストールを飛ばします。
自動読み込み器の生成で<code>autoload-dev</code>規則を読み飛ばします。
<a href="doc/03-cli.html#composer-no-dev">COMPOSER_NO_DEV</a>も参照してください。</li>
<li><strong>--no-install:</strong>
composer.lockを更新した後のインストール過程を走らせません。</li>
<li><strong>--no-audit:</strong>
composer.lockを更新した後の監査過程を走らせません。<a href="doc/03-cli.html#composer-no-audit">COMPOSER_NO_AUDIT</a>も参照してください。</li>
<li><strong>--audit-format:</strong> 監査の出力形式です。
"table"、"plain"、"json"、または"summary"（既定）のどれかでなければなりません。</li>
<li><strong>--lock:</strong>
パッケージのバージョンを更新せず、固定ファイルが期限切れであることについての警告を抑えるために固定ファイルを上書きします。
ミラーやURLといったパッケージのメタデータが変更されていれば更新します。</li>
<li><strong>--with:</strong> 一時的に追加するバージョン制約です。例えばfoo/bar:1.0.0やfoo/bar=1.0.0です。</li>
<li><strong>--no-autoloader:</strong> 自動読み込み器の生成を飛ばします。</li>
<li><strong>--no-progress:</strong>
進捗表示を除きます。
バックスペース文字を扱わない端末やスクリプトではこの表示があることで散らかってしまうからです。</li>
<li><strong>--with-dependencies (-w):</strong>
引数リスト中のパッケージの依存関係も更新します。
ただし根幹要件は除きます。
COMPOSER_WITH_DEPENDENCIES=1 環境変数で設定することもできます。</li>
<li><strong>--with-all-dependencies (-W):</strong>
引数リスト中のパッケージの依存関係も更新します。
根幹要件を含みます。
COMPOSER_WITH_ALL_DEPENDENCIES=1 環境変数でも設定できます。</li>
<li><strong>--optimize-autoloader (-o):</strong>
PSR-0自動読み込みをクラスマップに変換して、より高速な自動読み込み器を取得します。
特に実運用で推奨されますが、走らせるのに少し時間が掛かるため、現時点では既定では有効になっていません。</li>
<li><strong>--classmap-authoritative (-a):</strong> クラス対応表からクラスのみを自動読み込みします。
暗黙裡に<code>--optimize-autoloader</code>を有効にします。</li>
<li><strong>--apcu-autoloader:</strong> APCuを使って、クラスの有無をキャッシュします。</li>
<li><strong>--apcu-autoloader-prefix:</strong> APCu自動読み込み器のキャッシュ用に独自の接頭辞を使います。
暗黙裡に<code>--apcu-autoloader</code>を有効にします。</li>
<li><strong>--ignore-platform-reqs:</strong>
全てのプラットフォーム要件（<code>php</code>、<code>hhvm</code>、<code>lib-*</code>、<code>ext-*</code>）を無視し、ローカルマシンがたとえこれらを満たしていなくてもインストールを強行します。
<a href="doc/06-config.html#platform"><code>platform</code></a>設定オプションも参照してください。</li>
<li><strong>--ignore-platform-req:</strong>
特定のプラットフォーム要件（<code>php</code>、<code>hhvm</code>、<code>lib-*</code>、<code>ext-*</code>）を無視し、ローカルマシンがたとえこれらを満たしていなくてもインストールを強行します。
ワイルドカードを使って複数の要件を無視できます。
<code>+</code>を後ろに付けることで要件の上限値だけを無視できます。
例えばパッケージが<code>php: ^7</code>を要求しているとき、オプション<code>--ignore-platform-req=php+</code>はPHP8でのインストールを許しますが、PHP
5.6でのインストールについては失敗します。</li>
<li><strong>--prefer-stable:</strong>
依存関係の安定板を選ぶようにします。COMPOSER_PREFER_STABLE=1環境変数を介しても設定できます。</li>
<li><strong>--prefer-lowest:</strong>
依存関係の最も低いバージョンを選ぶようにします。最小バージョン要件を試す際に便利で、一般的には<code>--prefer-stable</code>と共に使われます。COMPOSER_PREFER_LOWERST=1環境変数を介しても設定できます。</li>
<li><strong>--minimal-changes (-m):</strong>
<code>-w</code> / <code>-W</code>を使った部分的な更新の際に、遷移的な依存関係については絶対に必須の変更のみを実施するようにします。
COMPOSER_MINIMAL_CHANGES=1環境変数を介しても設定できます。</li>
<li><strong>--patch-only:</strong>
現在インストールされている依存関係について、パッチバージョンの更新のみ許可します。</li>
<li><strong>--interactive:</strong> 自動補完付きの対話的なインターフェースで、更新するパッケージを選択します。</li>
<li><strong>--root-reqs:</strong> 更新を一次依存関係に制限します。</li>
<li><strong>--bump-after-update:</strong>
更新後に<code>bump</code>を走らせます。
<code>dev</code>や<code>no-dev</code>を設定すると、それぞれの依存関係のみのバージョンを上げます。</li>
</ul>
<p>引数として単語<code>mirrors</code>、<code>lock</code>、<code>nothing</code>からどれか1つを指定すると、オプション<code>--lock</code>を指定することと同じ効果があります。
例えば<code>composer update mirrors</code>は<code>composer update --lock</code>と全く同じです。</p>
<h2 id="require--r"><a class="header" href="#require--r">require / r</a></h2>
<p><code>require</code>コマンドは<code>composer.json</code>ファイルに現在のディレクトリから新しいパッケージを追加します。1つもファイルが存在しなければ必要に応じて作られます。</p>
<p>パッケージを指定しない場合、Composerはパッケージを探すためにプロンプトを出し、要件にするものに照合する一覧を提供します。</p>
<pre><code class="language-shell">php composer.phar require
</code></pre>
<p>要件を加えたり変えたりした後に、変更された要件がインストールされたり更新されたりします。</p>
<p>対話的に要件を選びたくなければコマンドに渡すこともできます。</p>
<pre><code class="language-shell">php composer.phar require "vendor/package:2.*" vendor/package2:dev-master
</code></pre>
<p>バージョン制約を指定しなければ、composerは利用できるパッケージのバージョンに基づいて相応しいものを選びます。</p>
<pre><code class="language-shell">php composer.phar require vendor/package vendor/package2
</code></pre>
<p>すぐには新しい依存関係をインストールしたくない場合は--no-update付きで呼べます。</p>
<h3 id="オプション-3"><a class="header" href="#オプション-3">オプション</a></h3>
<ul>
<li><strong>--dev:</strong> パッケージを<code>require-dev</code>に追加します。</li>
<li><strong>--dry-run:</strong>
実際には何もせず、コマンドを模擬します。</li>
<li><strong>--prefer-install:</strong> パッケージをダウンロードする方法は<code>source</code>と<code>dist</code>の2つあります。
Composerは<code>dist</code>を既定で使います。
<code>--prefer-install=source</code>（または<code>--prefer-source</code>）を渡すと、Composerは、もしあれば<code>source</code>からインストールします。
プロジェクトへのバグ修正をして、依存関係のローカルgitクローンを直接取得したい場合に便利です。
Composerがパッケージの開発版用の<code>source</code>を自動的に使う、以前の挙動にしたければ、<code>--prefer-install=auto</code>を使ってください。
<a href="doc/06-config.html#preferred-install">config.preferred-install</a>も参照してください。
このフラグを渡すと、設定値より優先されます。</li>
<li><strong>--no-progress:</strong>
進捗表示を除きます。
バックスペース文字を扱わない端末やスクリプトではこの表示があることで散らかってしまうからです。</li>
<li><strong>--no-update:</strong> 依存関係の自動的な更新を無効にします（--no-installを暗示します）。</li>
<li><strong>--no-install:</strong>
composer.lockを更新した後のインストール過程を走らせません。</li>
<li><strong>--no-audit:</strong>
composer.lockを更新した後の監査過程を走らせません。<a href="doc/03-cli.html#composer-no-audit">COMPOSER_NO_AUDIT</a>も参照してください。</li>
<li><strong>--audit-format:</strong> 監査の出力形式です。
"table"、"plain"、"json"、または"summary"（既定）のどれかでなければなりません。</li>
<li><strong>--update-no-dev:</strong>
<code>--no-dev</code>オプションと共に依存関係の更新を走らせます。<a href="doc/03-cli.html#composer-no-dev">COMPOSER_NO_DEV</a>も参照してください。</li>
<li><strong>--update-with-dependencies (-w):</strong>
新しく要求するパッケージの依存関係も更新します。
ただし根幹要件は除きます。
COMPOSER_WITH_DEPENDENCIES=1 環境変数でも設定できます。</li>
<li><strong>--update-with-all-dependencies (-W):</strong>
新しく要求するパッケージの依存関係も更新します。
根幹要件も含まれます。
COMPOSER_WITH_ALL_DEPENDENCIES=1 環境変数でも設定できます。</li>
<li><strong>--ignore-platform-reqs:</strong>
全てのプラットフォーム要件（<code>php</code>、<code>hhvm</code>、<code>lib-*</code>、<code>ext-*</code>）を無視し、ローカルマシンがたとえこれらを満たしていなくてもインストールを強行します。
<a href="doc/06-config.html#platform"><code>platform</code></a>設定オプションも参照してください。</li>
<li><strong>--ignore-platform-req:</strong>
特定のプラットフォーム要件（<code>php</code>、<code>hhvm</code>、<code>lib-*</code>、<code>ext-*</code>）を無視して、たとえローカルマシンが満たしていなかったとしても、インストールを強行します。
ワイルドカードを使って複数の要件を無視できます。</li>
<li><strong>--prefer-stable:</strong>
依存関係の安定板を選ぶようにします。COMPOSER_PREFER_STABLE=1環境変数を介しても設定できます。</li>
<li><strong>--prefer-lowest:</strong>
依存関係の最も低いバージョンを選ぶようにします。最小バージョン要件を試す際に便利で、一般的には<code>--prefer-stable</code>と共に使われます。COMPOSER_PREFER_LOWERST=1環境変数を介しても設定できます。</li>
<li><strong>--minimal-changes (-m):</strong>
<code>-w</code> / <code>-W</code>での更新の際に、遷移的な依存関係に関して絶対に必須の変更のみを実施するようにします。
COMPOSER_MINIMAL_CHANGES=1環境変数を介して設定することもできます。</li>
<li><strong>--sort-packages:</strong>
パッケージを<code>package.json</code>で整列した状態にします。</li>
<li><strong>--optimize-autoloader (-o):</strong>
PSR-0自動読み込みをクラスマップに変換して、より高速な自動読み込み器を取得します。
特に実運用で推奨されますが、走らせるのに少し時間が掛かるため、現時点では既定では有効になっていません。</li>
<li><strong>--classmap-authoritative (-a):</strong> クラス対応表からクラスのみを自動読み込みします。
暗黙裡に<code>--optimize-autoloader</code>を有効にします。</li>
<li><strong>--apcu-autoloader:</strong> APCuを使って、クラスの有無をキャッシュします。</li>
<li><strong>--apcu-autoloader-prefix:</strong> APCu自動読み込み器のキャッシュ用に独自の接頭辞を使います。
暗黙裡に<code>--apcu-autoloader</code>を有効にします。</li>
</ul>
<h2 id="remove--rm--uninstall"><a class="header" href="#remove--rm--uninstall">remove / rm / uninstall</a></h2>
<p><code>remove</code>コマンドは現在のディレクトリにある<code>composer.json</code>ファイルからパッケージを削除します。</p>
<pre><code class="language-shell">php composer.phar remove vendor/package vendor/package2
</code></pre>
<p>要件を削除した後は変更対象の要件がアンインストールされます。</p>
<h3 id="オプション-4"><a class="header" href="#オプション-4">オプション</a></h3>
<ul>
<li><strong>--unused</strong>（もう）直接ないし間接の依存関係ではない、使われていないパッケージを削除します。</li>
<li><strong>--dev:</strong> <code>require-dev</code>からパッケージを削除します。</li>
<li><strong>--dry-run:</strong>
実際には何もせず、コマンドを模擬します。</li>
<li><strong>--no-progress:</strong>
進捗表示を除きます。
バックスペース文字を扱わない端末やスクリプトではこの表示があることで散らかってしまうからです。</li>
<li><strong>--no-update:</strong> 依存関係の自動的な更新を無効にします（--no-installを暗示します）。</li>
<li><strong>--no-install:</strong>
composer.lockを更新した後のインストール過程を走らせません。</li>
<li><strong>--no-audit:</strong>
インストールが完了した後の監査過程を走らせないようにします。
<a href="doc/03-cli.html#composer-no-audit">COMPOSER_NO_AUDIT</a>も参照してください。</li>
<li><strong>--audit-format:</strong> 監査の出力形式です。
"table"、"plain"、"json"、または"summary"（既定）のどれかでなければなりません。</li>
<li><strong>--update-no-dev:</strong>
--no-devオプションで依存関係の更新を走らせます。<a href="doc/03-cli.html#composer-no-dev">COMPOSER_NO_DEV</a>も参照してください。</li>
<li><strong>--update-with-dependencies (-w):</strong>
削除されたパッケージの依存関係も更新します。
COMPOSER_WITH_DEPENDENCIES=1 環境変数でも設定できます（廃止されました。
現在は既定の挙動になっています）。</li>
<li><strong>--update-with-all-dependencies (-W):</strong>
全ての継承する依存関係が更新されるようにします。
根幹要件のものも含みます。
COMPOSER_WITH_ALL_DEPENDENCIES=1 環境変数でも設定できます。</li>
<li><strong>--minimal-changes (-m):</strong>
<code>-w</code> / <code>-W</code>での更新の際に、遷移的な依存関係に関して絶対に必須の変更のみを実施するようにします。
COMPOSER_MINIMAL_CHANGES=1環境変数を介して設定することもできます。</li>
<li><strong>--ignore-platform-reqs:</strong>
全てのプラットフォーム要件（<code>php</code>、<code>hhvm</code>、<code>lib-*</code>、<code>ext-*</code>）を無視し、ローカルマシンがたとえこれらを満たしていなくてもインストールを強行します。
<a href="doc/06-config.html#platform"><code>platform</code></a>設定オプションも参照してください。</li>
<li><strong>--ignore-platform-req:</strong>
特定のプラットフォーム要件（<code>php</code>、<code>hhvm</code>、<code>lib-*</code>、<code>ext-*</code>）を無視して、たとえローカルマシンが満たしていなかったとしても、インストールを強行します。
ワイルドカードを使って複数の要件を無視できます。</li>
<li><strong>--optimize-autoloader (-o):</strong> PSR-0の自動読み込みをクラス対応表に変換して自動読み込みを高速にします。
実運用では特にお勧めしますが、走らせるのに少し時間が掛かることがあるので、現在は既定ではされません。</li>
<li><strong>--classmap-authoritative (-a):</strong> クラス対応表からクラスのみを自動読み込みします。
暗黙裡に<code>--optimize-autoloader</code>を有効にします。</li>
<li><strong>--apcu-autoloader:</strong> APCuを使って、クラスの有無をキャッシュします。</li>
<li><strong>--apcu-autoloader-prefix:</strong> APCu自動読み込み器のキャッシュ用に独自の接頭辞を使います。
暗黙裡に<code>--apcu-autoloader</code>を有効にします。</li>
</ul>
<h2 id="bump"><a class="header" href="#bump">bump</a></h2>
<p><code>bump</code>コマンドはcomposer.jsonの要件の下限を現在インストールされているバージョンに引き上げます。これにより依存関係が何らかの競合によりうっかりダウングレードされてしまわないようになったり、Composerが探すパッケージのバージョンの数が抑えられるため依存関係解決を僅かに向上させられます。</p>
<p>許される依存関係を狭めてしまうため、ライブラリでこれを無闇に走らせるのは推奨<strong>されません</strong>。
依存関係を狭めることは利用者に依存関係地獄を招きかねません。
しかしライブラリで<code>--dev-only</code>を走らせるのは、開発用要件がライブラリに対して局所的で、パッケージの消費者には影響しないため問題ないでしょう。</p>
<h3 id="オプション-5"><a class="header" href="#オプション-5">オプション</a></h3>
<ul>
<li><strong>--dev-only:</strong> "require-dev" 中の要件のみbumpします。</li>
<li><strong>--no-dev-only:</strong> "require" にある要件のみbumpします。</li>
<li><strong>--dry-run:</strong> bumpするパッケージを出力しますが、何も実行しません。</li>
</ul>
<h2 id="reinstall"><a class="header" href="#reinstall">reinstall</a></h2>
<p><code>reinstall</code>コマンドは名前からインストールされているパッケージを見付けだし、アンインストールと再インストールをします。
こうすることでファイルを散らかしたり--prefer-installを使ってインストールの種類を変えたいと思ったりしたときにクリーンインストールできます。</p>
<pre><code class="language-shell">php composer.phar reinstall acme/foo acme/bar
</code></pre>
<p>再インストールするパッケージ名を1つ以上指定できます。
またはワイルドカードを使って複数パッケージの一括選択もできます。</p>
<pre><code class="language-shell">php composer.phar reinstall "acme/*"
</code></pre>
<h3 id="オプション-6"><a class="header" href="#オプション-6">オプション</a></h3>
<ul>
<li><strong>--prefer-install:</strong> パッケージをダウンロードする方法は<code>source</code>と<code>dist</code>の2つあります。
Composerは<code>dist</code>を既定で使います。
<code>--prefer-install=source</code>（または<code>--prefer-source</code>）を渡すと、Composerは、もしあれば<code>source</code>からインストールします。
プロジェクトへのバグ修正をして、依存関係のローカルgitクローンを直接取得したい場合に便利です。
Composerがパッケージの開発版用の<code>source</code>を自動的に使う、以前の挙動にしたければ、<code>--prefer-install=auto</code>を使ってください。
<a href="doc/06-config.html#preferred-install">config.preferred-install</a>も参照してください。
このフラグを渡すと、設定値より優先されます。</li>
<li><strong>--no-autoloader:</strong> 自動読み込み器の生成を飛ばします。</li>
<li><strong>--no-progress:</strong>
進捗表示を除きます。
バックスペース文字を扱わない端末やスクリプトではこの表示があることで散らかってしまうからです。</li>
<li><strong>--optimize-autoloader (-o):</strong> PSR-0の自動読み込みをクラス対応表に変換して自動読み込みを高速にします。
実運用では特にお勧めしますが、走らせるのに少し時間が掛かることがあるので、現在は既定ではされません。</li>
<li><strong>--classmap-authoritative (-a):</strong> クラス対応表からクラスのみを自動読み込みします。
暗黙裡に<code>--optimize-autoloader</code>を有効にします。</li>
<li><strong>--apcu-autoloader:</strong> APCuを使って、クラスの有無をキャッシュします。</li>
<li><strong>--apcu-autoloader-prefix:</strong> APCu自動読み込み器のキャッシュ用に独自の接頭辞を使います。
暗黙裡に<code>--apcu-autoloader</code>を有効にします。</li>
<li><strong>--ignore-platform-reqs:</strong> 全てのプラットフォーム要件を無視します。
再インストールコマンド用の自動読み込み器の生成のときにのみ効果があります。</li>
<li><strong>--ignore-platform-req:</strong> 特定のプラットフォーム要件を無視します。
再インストールコマンド用の自動読み込み器の生成のときにのみ効果があります。
複数の要件をワイルドカードで無視できます。</li>
</ul>
<h2 id="check-platform-reqs"><a class="header" href="#check-platform-reqs">check-platform-reqs</a></h2>
<p>check-platform-reqsコマンドはPHPと拡張のバージョンがインストールされているパッケージのプラットフォーム要件を満たしているかを確認します。
例えば実運用サーバーでインストール後に、プロジェクトを走らせるのに必要な全ての拡張があることを検証したいときに使えます。</p>
<p>updateやinstallとは異なり、このコマンドはconfig.platform設定を無視し、実際のプラットフォームパッケージを検査します。
そのため要求されているプラットフォーム依存関係があることを確かめられます。</p>
<h3 id="オプション-7"><a class="header" href="#オプション-7">オプション</a></h3>
<ul>
<li><strong>--lock:</strong>
インストールされたパッケージからではなく、固定ファイルのみから要件を検査します。</li>
<li><strong>--no-dev:</strong> require-devのパッケージ要件の検査を無効にします。</li>
<li><strong>--format (-f):</strong> 出力の書式です。text（既定）またはjsonです。</li>
</ul>
<h2 id="global"><a class="header" href="#global">global</a></h2>
<p>globalコマンドは<code>install</code>、<code>remove</code>、<code>require</code>、<code>update</code>のようなコマンドをあたかも<a href="doc/03-cli.html#composer-home">COMPOSER_HOME</a>ディレクトリから走らせているように実行できます。</p>
<p>中心的な場所に保管されたプロジェクトを管理するためのただの補助であり、CLIツールやComposerプラグインのような、どこでも使えるようにしたいものを置いておけます。</p>
<p>大域的にCLIユーティリティをインストールするのに使えます。
以下は一例です。</p>
<pre><code class="language-shell">php composer.phar global require friendsofphp/php-cs-fixer
</code></pre>
<p>これで<code>php-cs-fixer</code>バイナリが大域的に使えるようになりました。大域的な<a href="doc/articles/vendor-binaries.html">ベンダーバイナリ</a>ディレクトリが<code>$PATH</code>環境変数の中にあるようにしてください。インストールした場所は以下のコマンドで得られます。</p>
<pre><code class="language-shell">php composer.phar global config bin-dir --absolute
</code></pre>
<p>後になってバイナリを更新したいと思ったら、global updateを走らせられます。</p>
<pre><code class="language-shell">php composer.phar global update
</code></pre>
<h2 id="search"><a class="header" href="#search">search</a></h2>
<p>searchコマンドを使うと、現在のプロジェクトのパッケージリポジトリ全体を検索できます。
大抵はpackagistです。
検索したい用語を渡せます。</p>
<pre><code class="language-shell">php composer.phar search monolog
</code></pre>
<p>複数の引数を渡すことで1つ以上の用語を探すこともできます。</p>
<h3 id="オプション-8"><a class="header" href="#オプション-8">オプション</a></h3>
<ul>
<li><strong>--only-name (-N):</strong> パッケージの名前のみから検索します。</li>
<li><strong>--only-vendor (-O):</strong>
ベンダー・組織名のみから検索します。
結果として「ベンダー」のみが返ります。</li>
<li><strong>--type (-t):</strong> 特定のパッケージの種類から探します。</li>
<li><strong>--format (-f):</strong>
text（既定）かjson出力かのどちらかを選べます。
jsonではname及びdescriptionキーのみが存在することが保証されています。
残り（<code>url</code>、<code>repository</code>、<code>downloads</code>、<code>favers</code>）はPackagist.orgの検索結果で得られるものであって、その他のリポジトリが返す情報はそれより多かったり少なかったりします。</li>
</ul>
<h2 id="show--info"><a class="header" href="#show--info">show / info</a></h2>
<p>使えるパッケージの全てを一覧にするには<code>show</code>コマンドが使えます。</p>
<pre><code class="language-shell">php composer.phar show
</code></pre>
<p>一覧を絞り込むには、ワイルドカードを使ってパッケージマスクを渡せます。</p>
<pre><code class="language-shell">php composer.phar show "monolog/*"
</code></pre>
<pre><code class="language-text">monolog/monolog 2.4.0 Sends your logs to files, sockets, inboxes, databases and various web services
</code></pre>
<p>何かのパッケージの詳細を見たければ、パッケージ名を渡すことができます。</p>
<pre><code class="language-shell">php composer.phar show monolog/monolog
</code></pre>
<pre><code class="language-text">name     : monolog/monolog
descrip. : Sends your logs to files, sockets, inboxes, databases and various web services
keywords : log, logging, psr-3
versions : * 1.27.1
type     : library
license  : MIT License (MIT) (OSI approved) https://spdx.org/licenses/MIT.html#licenseText
homepage : http://github.com/Seldaek/monolog
source   : [git] https://github.com/Seldaek/monolog.git 904713c5929655dc9b97288b69cfeedad610c9a1
dist     : [zip] https://api.github.com/repos/Seldaek/monolog/zipball/904713c5929655dc9b97288b69cfeedad610c9a1 904713c5929655dc9b97288b69cfeedad610c9a1
names    : monolog/monolog, psr/log-implementation

support
issues : https://github.com/Seldaek/monolog/issues
source : https://github.com/Seldaek/monolog/tree/1.27.1

autoload
psr-4
Monolog\ =&gt; src/Monolog

requires
php &gt;=5.3.0
psr/log ~1.0
</code></pre>
<p>パッケージのバージョンを渡すこともできます。
こうすると特定のバージョンでの詳細が分かります。</p>
<pre><code class="language-shell">php composer.phar show monolog/monolog 1.0.2
</code></pre>
<h3 id="オプション-9"><a class="header" href="#オプション-9">オプション</a></h3>
<ul>
<li><strong>--all:</strong>
リポジトリで使える全てのパッケージを一覧にします。</li>
<li><strong>--installed (-i):</strong> インストールされているパッケージを一覧にします（既定で有効になっており、時代遅れのオプションです）。</li>
<li><strong>--locked:</strong> composer.lockから固定されたパッケージを一覧にします。</li>
<li><strong>--platform (-p):</strong> プラットフォームパッケージ（phpと拡張）のみを一覧にします。</li>
<li><strong>--available (-a):</strong> 利用できるパッケージのみにします。</li>
<li><strong>--self (-s):</strong>
根幹パッケージ情報を一覧にします。</li>
<li><strong>--name-only (-N):</strong> パッケージ名のみを一覧にします。</li>
<li><strong>--path (-P):</strong> パッケージのパスを一覧にします。</li>
<li><strong>--tree (-t):</strong> 依存関係を木構造で一覧にします。パッケージ名を渡した場合はそのパッケージの依存関係を示します。</li>
<li><strong>--latest (-l):</strong> インストールされている全てのパッケージをその最新バージョンと共に一覧にします。</li>
<li><strong>--outdated (-o):</strong>
--latestを暗示しますが、新しいバージョンが手に入るパッケージ<em>のみ</em>を一覧にします。</li>
<li><strong>--ignore:</strong>
ワイルドカード (<code>*</code>) を含められます。
指定されたパッケージを無視します。
パッケージの新しいバージョンについて通知を受けたくなければ--outdatedオプションと一緒に使ってください。</li>
<li><strong>--no-dev:</strong> パッケージ一覧から開発用の依存関係を除外します。</li>
<li><strong>--major-only (-M):</strong>
--latestまたは--outdatedと一緒に使ってください。
メジャーなセマンティックバージョニング互換の更新があるパッケージのみ示されます。</li>
<li><strong>--minor-only (-m):</strong>
--latestまたは--outdatedと一緒に使ってください。
マイナーなセマンティックバージョニング互換の更新があるパッケージのみ示されます。</li>
<li><strong>--patch-only:</strong>
--latestまたは--outdatedと一緒に使ってください。
パッチ水準のセマンティックバージョニング互換の更新があるパッケージのみが示されます。</li>
<li><strong>--sort-by-age (-A):</strong>
インストールされたバージョンの経過時間を表示し、古い順にパッケージを整列します。
--latestないし--outdatedオプションと一緒に使ってください。</li>
<li><strong>--direct (-D):</strong> パッケージの一覧を直接的な依存関係に限定します。</li>
<li><strong>--strict:</strong> 時代遅れのパッケージがあるときは非ゼロの終了コードを返します。</li>
<li><strong>--format (-f):</strong> 出力形式としてtext（既定）ないしjsonを選びます。</li>
<li><strong>--ignore-platform-reqs:</strong>
全てのプラットフォーム要件（<code>php</code>、<code>hhvm</code>、<code>lib-*</code>、<code>ext-*</code>）を無視し、たとえローカルマシンがこれらの要件を満たしていなくても、インストールを強行します。--outdatedオプションと一緒に使ってください。</li>
<li><strong>--ignore-platform-req:</strong>
特定のプラットフォーム要件（<code>php</code>、<code>hhvm</code>、<code>lib-*</code>、<code>ext-*</code>）を無視し、たとえローカルマシンがその要件を満たしていなくても、インストールを強行します。
ワイルドカードを介して複数の要件を無視できます。
--outdatedオプションと一緒に使ってください。</li>
</ul>
<h2 id="outdated"><a class="header" href="#outdated">outdated</a></h2>
<p><code>outdated</code>コマンドは、更新が利用できるインストール済みパッケージの一覧を、現在のバージョンと最新のバージョンを含めて示します。
基本的に<code>composer show -lo</code>の別名になっています。</p>
<p>色彩コードは以下の通り。</p>
<ul>
<li><strong>green (=)</strong>: 依存関係は最新バージョンであり、最新式です。</li>
<li><strong>yellow (<code>~</code>)</strong>:
依存関係に新しいバージョンが利用できるものがありますが、セマンティックバージョニングに於ける後方互換性の破壊が含まれます。
そのため更新できそうならしても良いですが、作業が発生する可能性があります。</li>
<li><strong>red (!)</strong>:
依存関係にセマンティックバージョニング上互換性のある新しいバージョンがあり、更新するべきです。</li>
</ul>
<h3 id="オプション-10"><a class="header" href="#オプション-10">オプション</a></h3>
<ul>
<li><strong>--all (-a):</strong> 時代遅れのものだけでなく、全てのパッケージを示します（<code>composer show --latest</code>の別名です）。</li>
<li><strong>--direct (-D):</strong> パッケージの一覧を直接的な依存関係に限定します。</li>
<li><strong>--strict:</strong>
1つもパッケージが時代遅れでなければ、非ゼロの終了コードを返します。</li>
<li><strong>--ignore:</strong>
指定されたパッケージを無視します。
ワイルドカード (<code>*</code>) を含められます。
何かしらのパッケージの新しいバージョンについて知らされたくないときに使ってください。</li>
<li><strong>--major-only (-M):</strong> メジャーなセマンティックバージョニング上の互換性を伴う更新のみ示します。</li>
<li><strong>--minor-only (-m):</strong> マイナーなセマンティックバージョニング上の互換性を伴う更新のみ示します。</li>
<li><strong>--patch-only (-p):</strong>
パッチ水準のセマンティックバージョニング上の互換性を伴う更新のみ示します。</li>
<li><strong>--sort-by-age (-A):</strong>
インストールされたバージョンの経過時間を表示し、古い順にパッケージを整列します。</li>
<li><strong>--format (-f):</strong> 出力形式としてtext（既定）ないしjsonを選びます。</li>
<li><strong>--no-dev:</strong> 時代遅れの開発用依存関係を表示しません。</li>
<li><strong>--locked:</strong>
固定ファイルを元にしたパッケージの更新を示します。
現在のベンダーディレクトリの中身は措かれます。</li>
<li><strong>--ignore-platform-reqs:</strong>
全てのプラットフォーム要件（<code>php</code>、<code>hhvm</code>、<code>lib-*</code>、<code>ext-*</code>）を無視し、たとえローカルマシンがこれらの要件を満たしていなくても、インストールを強行します。</li>
<li><strong>--ignore-platform-req:</strong>
特定のプラットフォーム要件（<code>php</code>、<code>hhvm</code>、<code>lib-*</code>、<code>ext-*</code>）を無視して、たとえローカルマシンが満たしていなかったとしても、インストールを強行します。
ワイルドカードを使って複数の要件を無視できます。</li>
</ul>
<h2 id="browse--home"><a class="header" href="#browse--home">browse / home</a></h2>
<p><code>browse</code>（別名<code>home</code>）はパッケージのリポジトリURLまたはホームページをブラウザで開きます。</p>
<h3 id="オプション-11"><a class="header" href="#オプション-11">オプション</a></h3>
<ul>
<li><strong>--homepage (-H):</strong> リポジトリではなくホームページのURLを開きます。</li>
<li><strong>--show (-s):</strong> ホームページないしリポジトリのURLを表示するだけにします。</li>
</ul>
<h2 id="suggests"><a class="header" href="#suggests">suggests</a></h2>
<p>現在インストールされているパッケージの集合から提案される全てのパッケージを一覧にします。
おまけとして複数のパッケージ名を<code>vendor/package</code>の形式で渡し、これらのパッケージのみについて提案を出力するように制限できます。</p>
<p><code>--by-package</code>（既定）ないし<code>--by-suggestion</code>フラグを使って出力をグループ分けできます。それぞれ提案を行うパッケージによるグループ分けと提案されたパッケージによるグループ分けになっています。</p>
<p>提案されたパッケージ名の一覧だけが欲しければ<code>--list</code>を使ってください。</p>
<h3 id="オプション-12"><a class="header" href="#オプション-12">オプション</a></h3>
<ul>
<li><strong>--by-package:</strong> 提案を行ったパッケージによって出力をグループ分けします（既定）。</li>
<li><strong>--by-suggestion:</strong> 提案されたパッケージによって出力をグループ分けします。</li>
<li><strong>--all:</strong> 推移的なものを含む全ての依存関係から提案を示します（既定では直接的な依存関係の提案のみが示されます）。</li>
<li><strong>--list:</strong> 提案されたパッケージ名のみを一覧として示します。</li>
<li><strong>--no-dev:</strong> <code>require-dev</code>パッケージからの提案を除外します。</li>
</ul>
<h2 id="fund"><a class="header" href="#fund">fund</a></h2>
<p>依存関係の維持管理に投資して支援する方法が分かります。
このコマンドはインストールされている依存関係から全ての投資のリンクを一覧にします。
機械で読むことのできる出力を得るには<code>--format=json</code>を使ってください。</p>
<h3 id="オプション-13"><a class="header" href="#オプション-13">オプション</a></h3>
<ul>
<li><strong>--format (-f):</strong> 出力形式としてtext（既定）ないしjsonを選びます。</li>
</ul>
<h2 id="depends--why"><a class="header" href="#depends--why">depends / why</a></h2>
<p><code>depends</code>コマンドは特定のパッケージに依存する他のパッケージを教えてくれます。
インストールの際、<code>require-dev</code>の関係は根幹パッケージのみ考慮されます。</p>
<pre><code class="language-shell">php composer.phar depends doctrine/lexer
</code></pre>
<pre><code class="language-text">doctrine/annotations  1.13.3 requires doctrine/lexer (1.*)
doctrine/common       2.13.3 requires doctrine/lexer (^1.0)
</code></pre>
<p>おまけとしてパッケージの後にバージョン制約を指定することで検索結果を絞り込むことができます。</p>
<p><code>--tree</code>や<code>-t</code>フラグを加えると、なぜそのパッケージが依存されているのかの再帰的な木構造が示されます。例えば以下の通りです。</p>
<pre><code class="language-shell">php composer.phar depends psr/log -t
</code></pre>
<pre><code class="language-text">psr/log 1.1.4 Common interface for logging libraries
├──composer/composer 2.4.x-dev (requires psr/log ^1.0 || ^2.0 || ^3.0)
├──composer/composer dev-main (requires psr/log ^1.0 || ^2.0 || ^3.0)
├──composer/xdebug-handler 3.0.3 (requires psr/log ^1 || ^2 || ^3)
│  ├──composer/composer 2.4.x-dev (requires composer/xdebug-handler ^2.0.2 || ^3.0.3)
│  └──composer/composer dev-main (requires composer/xdebug-handler ^2.0.2 || ^3.0.3)
└──symfony/console v5.4.11 (conflicts psr/log &gt;=3) (circular dependency aborted here)
</code></pre>
<h3 id="オプション-14"><a class="header" href="#オプション-14">オプション</a></h3>
<ul>
<li><strong>--recursive (-r):</strong>
再帰的に根幹パッケージまで木構造を解決します。</li>
<li><strong>--tree (-t):</strong> 入れ子の木構造を結果に出力します。-rを暗示します。</li>
</ul>
<h2 id="prohibits--why-not"><a class="header" href="#prohibits--why-not">prohibits / why-not</a></h2>
<p><code>prohibits</code>コマンドを使うと与えられたパッケージがインストールされる上でどのパッケージが障壁になっているのかが分かります。
バージョン制約を指定するとプロジェクトにおいて更新が実施できるかを検証し、もしできなければその理由を示します。
以下の例をご覧ください。</p>
<pre><code class="language-shell">php composer.phar prohibits symfony/symfony 3.1
</code></pre>
<pre><code class="language-text">laravel/framework v5.2.16 requires symfony/var-dumper (2.8.*|3.0.*)
</code></pre>
<p>なおプラットフォーム要件も指定できます。
例えばサーバーをPHP 8.0に更新できるかどうかを確認するにはこうします。</p>
<pre><code class="language-shell">php composer.phar prohibits php 8
</code></pre>
<pre><code class="language-text">doctrine/cache        v1.6.0 requires php (~5.5|~7.0)
doctrine/common       v2.6.1 requires php (~5.5|~7.0)
doctrine/instantiator 1.0.5  requires php (&gt;=5.3,&lt;8.0-DEV)
</code></pre>
<p><code>depends</code>と同様に再帰的な探索を求めることができます。その場合は競合を起こしているパッケージに依存している全てのパッケージを一覧にします。</p>
<h3 id="オプション-15"><a class="header" href="#オプション-15">オプション</a></h3>
<ul>
<li><strong>--recursive (-r):</strong>
再帰的に根幹パッケージまで木構造を解決します。</li>
<li><strong>--tree (-t):</strong> 入れ子の木構造を結果に出力します。-rを暗示します。</li>
</ul>
<h2 id="validate"><a class="header" href="#validate">validate</a></h2>
<p><code>composer.json</code>ファイル（と、<a href="doc/01-basic-usage.html#commit-your-composer-lock-file-to-version-control">当てはまるとき</a>は<code>composer.lock</code>）をコミットしたり、リリースのタグ付けをしたりする前には、必ず<code>validate</code>コマンドを走らせるべきです。</p>
<p><code>composer.json</code>が正当であるか検査します。
<code>composer.lock</code>があるとき、<code>composer.json</code>に対して最新かも検査します。</p>
<pre><code class="language-shell">php composer.phar validate
</code></pre>
<h3 id="オプション-16"><a class="header" href="#オプション-16">オプション</a></h3>
<ul>
<li><strong>--no-check-all:</strong>
<code>composer.json</code>中の要件が範囲のないものであったり、過度に厳密なバージョン制約であったりする場合について、警告を出しません。</li>
<li><strong>--no-check-lock:</strong>
<code>composer.lock</code>が存在し、且つ更新されていない場合について、警告を出しません。</li>
<li><strong>--check-lock</strong>
固定ファイルが最新か検査します（config.lockが偽の場合も含みます）</li>
<li><strong>--no-check-publish:</strong>
Packagistに投稿するには相応しくないが、そうでなければ妥当な<code>composer.json</code>になっている場合について、エラーを出しません。</li>
<li><strong>--no-check-version:</strong>
バージョンフィールドがあるとき、警告を出しません。</li>
<li><strong>--with-dependencies:</strong> 全てのインストールされた依存関係についてもcomposer.jsonを検証します。</li>
<li><strong>--strict:</strong> エラーに加えて警告についても非ゼロの終了コードを返します。</li>
</ul>
<h2 id="status"><a class="header" href="#status">status</a></h2>
<p>依存関係のコードを変更したり、ソースからインストールしたりする必要がしばしばある場合は、<code>status</code>コマンドを使うとその中からローカルで加えた変更があるか確認できます。</p>
<pre><code class="language-shell">php composer.phar status
</code></pre>
<p><code>--verbose</code>コマンドで変化したところについてのより詳しい情報を得られます。</p>
<pre><code class="language-shell">php composer.phar status -v
</code></pre>
<pre><code class="language-text">You have changes in the following dependencies:
vendor/seld/jsonlint:
    M README.mdown
</code></pre>
<h2 id="self-update--selfupdate"><a class="header" href="#self-update--selfupdate">self-update / selfupdate</a></h2>
<p>Composer自体を最新版に更新したければ<code>self-update</code>コマンドを走らせてください。<code>composer.phar</code>を最新版に置き換えます。</p>
<pre><code class="language-shell">php composer.phar self-update
</code></pre>
<p>そうではなく特定のリリースに更新したければそのように指定してください。</p>
<pre><code class="language-shell">php composer.phar self-update 2.4.0-RC1
</code></pre>
<p>Composerをシステム全体にインストールしたときは（<a href="doc/00-intro.html#globally">大域的なインストール</a>を参照）、コマンドを<code>root</code>権限で走らせなくてはならないかもしれません。</p>
<pre><code class="language-shell">sudo -H composer self-update
</code></pre>
<p>ComposerがPHARとしてインストールされていなければこのコマンドは使えません（Composerがオペレーティングシステムのパッケージ管理によってインストールされたときはこの場合に当たることがあります）。</p>
<h3 id="オプション-17"><a class="header" href="#オプション-17">オプション</a></h3>
<ul>
<li><strong>--rollback (-r):</strong> インストールした直近のバージョンに巻き戻します。</li>
<li><strong>--clean-backups:</strong>
更新時に古いバックアップを削除します。更新後は現在のComposerのバージョンのみがバックアップとして残ります。</li>
<li><strong>--no-progress:</strong>
ダウンロードの進捗バーを出力しません。</li>
<li><strong>--update-keys:</strong> キーの更新を利用者に尋ねます。</li>
<li><strong>--stable:</strong> 更新を安定チャンネルに強制します。</li>
<li><strong>--preview:</strong> 更新をプレビューチャンネルに強制します。</li>
<li><strong>--snapshot:</strong> 更新をスナップショットチャンネルに強制します。</li>
<li><strong>--1:</strong> 更新を安定チャンネルに強制しますが、1.x版のみを使います。</li>
<li><strong>--2:</strong> 更新を安定チャンネルに強制しますが、2.x版のみを使います。</li>
<li><strong>--set-channel-only:</strong> チャンネルを既定のものとして保存するだけして終了します。</li>
</ul>
<h2 id="config"><a class="header" href="#config">config</a></h2>
<p><code>config</code>コマンドではローカルの<code>composer.json</code>ファイルまたは大域的な<code>config.json</code>ファイルにあるComposerの設定やリポジトリを編集できます。</p>
<p>加えてローカルの<code>composer.json</code>にある殆どのプロパティを編集できます。</p>
<pre><code class="language-shell">php composer.phar config --list
</code></pre>
<h3 id="使い方"><a class="header" href="#使い方">使い方</a></h3>
<p><code>config [options] [setting-key] [setting-value1] ... [setting-valueN]</code></p>
<p><code>setting-key</code>は設定のオプション名で、<code>setting-value1</code>は設定値です。
（<code>github-protocols</code>のような）値の配列を取ることができる設定については、複数の設定値の引数が可能です。</p>
<p>プロパティの値を編集することもできます。</p>
<p><code>description</code>、<code>homepage</code>、<code>keywords</code>、<code>license</code>、<code>minimum-stability</code>、<code>name</code>、<code>prefer-stable</code>、<code>type</code>、<code>version</code>がそうです。</p>
<p>妥当な設定オプションについては<a href="doc/06-config.html">設定</a>の章を参照してください。</p>
<h3 id="オプション-18"><a class="header" href="#オプション-18">オプション</a></h3>
<ul>
<li><strong>--global (-g):</strong>
既定では<code>$COMPOSER_HOME/config.json</code>に位置する大域設定ファイルを編集します。
このオプションがなければ、このコマンドはローカルのcomposer.json<code>ファイルないし</code>--file`により指定されたファイルに作用します。</li>
<li><strong>--editor (-e):</strong>
ローカルのcomposer.jsonファイルを<code>EDITOR</code>環境変数で定義されたテキストエディタを使って開きます。<code>--global</code>オプションと一緒に使うと大域設定ファイルを開きます。</li>
<li><strong>--auth (-a):</strong>
認証設定ファイルに作用します（--editorの使用限定です）。</li>
<li><strong>--unset:</strong> <code>setting-key</code>の名前が付いている設定要素を削除します。</li>
<li><strong>--list (-l):</strong> 現在の設定変数の一覧を示します。<code>global</code>オプションと一緒に使うと大域設定のみを一覧にします。</li>
<li><strong>--file="..." (-f):</strong> composer.jsonではなく特定のファイルについて編集します。
なお、<code>--global</code>オプションと織り交ぜて使うことはできません。</li>
<li><strong>--absolute:</strong>
<code>*-dir</code>設定値を取得するとき、相対パスではなく絶対パスを返します。</li>
<li><strong>--json:</strong> 設定値をJSONでデコードします。このデコード結果は<code>extra.*</code>キーで使うことができます。</li>
<li><strong>--merge:</strong> 設定値を現在の値と統合します。<code>--json</code>と組み合わせて<code>extra.*</code>キーに使えます。</li>
<li><strong>--append:</strong> リポジトリを追加するとき、既存のものの先頭に追加する（最優先）のではなく末尾に付ける（低優先）ようにします。</li>
<li><strong>--source:</strong> 設定値がどこから読み込まれたのかを表示します。</li>
</ul>
<h3 id="リポジトリを変更する"><a class="header" href="#リポジトリを変更する">リポジトリを変更する</a></h3>
<p>設定部分を変更することに加えて、<code>config</code>コマンドを以下のように使うことでリポジトリ部分を変更することにも対応しています。</p>
<pre><code class="language-shell">php composer.phar config repositories.foo vcs https://github.com/foo/bar
</code></pre>
<p>リポジトリにより多くの設定オプションが必要なら、代わりにそのJSON表現を渡すことができます。</p>
<pre><code class="language-shell">php composer.phar config repositories.foo '{"type": "vcs", "url": "http://svn.example.org/my-project/", "trunk-path": "master"}'
</code></pre>
<h3 id="追加の値を変更する"><a class="header" href="#追加の値を変更する">追加の値を変更する</a></h3>
<p>設定部分を変更することに加えて、<code>config</code>コマンドを以下のように使って追加部分を変更することにも対応しています。</p>
<pre><code class="language-shell">php composer.phar config extra.foo.bar value
</code></pre>
<p>ドットは入れ子の連なりを表していますが、深さは3段階までです。上は<code>"extra": { "foo": { "bar": "value" } }</code>を設定します。</p>
<p>複雑な値を加えたり変更したりする場合は<code>--json</code>や<code>--merge</code>フラグを使って追加のフィールドをJSONとして編集できます。</p>
<pre><code class="language-shell">php composer.phar config --json extra.foo.bar '{"baz": true, "qux": []}'
</code></pre>
<h2 id="create-project"><a class="header" href="#create-project">create-project</a></h2>
<p>Composerを使って既存のパッケージから新しいプロジェクトを作ることができます。
git cloneやsvn checkoutをしてから、ベンダーにあるものを<code>composer install</code>することと等価です。</p>
<p>このコマンドにはいくつかの活用法があります。</p>
<ol>
<li>アプリケーションパッケージをデプロイできます。</li>
<li>任意のパッケージをチェックアウトして、例えばパッチを開発できます。</li>
<li>複数人の開発者がいるプロジェクトでこの機能を使い、開発のための初期のアプリケーションに着手できます。</li>
</ol>
<p>Composerで新しいプロジェクトを作るためには<code>create-project</code>コマンドが使えます。パッケージ名とプロジェクトを作成するディレクトリを渡してください。また、3つ目の引数としてバージョンを与えることもでき、与えない場合は最新版が使われます。</p>
<p>ディレクトリがその時点で存在しなければインストールの過程で作られます。</p>
<pre><code class="language-shell">php composer.phar create-project doctrine/orm path "2.2.*"
</code></pre>
<p>プロジェクトに着手するための既存の<code>composer.json</code>があるディレクトリ内では、引数がなくともコマンドを走らせることができます。</p>
<p>既定ではコマンドはパッケージをpackagist.orgで確認します。</p>
<h3 id="オプション-19"><a class="header" href="#オプション-19">オプション</a></h3>
<ul>
<li><strong>--stability (-s):</strong> パッケージの最小安定性です。<code>stable</code>が既定です。</li>
<li><strong>--prefer-install:</strong> パッケージをダウンロードする方法は<code>source</code>と<code>dist</code>の2つあります。
Composerは<code>dist</code>を既定で使います。
<code>--prefer-install=source</code>（または<code>--prefer-source</code>）を渡すと、Composerは、もしあれば<code>source</code>からインストールします。
プロジェクトへのバグ修正をして、依存関係のローカルgitクローンを直接取得したい場合に便利です。
Composerがパッケージの開発版用の<code>source</code>を自動的に使う、以前の挙動にしたければ、<code>--prefer-install=auto</code>を使ってください。
<a href="doc/06-config.html#preferred-install">config.preferred-install</a>も参照してください。
このフラグを渡すと、設定値より優先されます。</li>
<li><strong>--repository:</strong>
パッケージを探索するための独自のリポジトリを与えます。このリポジトリはpackagistの代わりに使われます。<code>composer</code>ディレクトリを指すHTTP
URLでも、ローカルの<code>packages.json</code>ファイルへのパスでも、あるいは<a href="doc/04-schema.html#repositories">リポジトリ</a>キーが受け付けるものに似たJSON文字列でも大丈夫です。複数回使って複数のリポジトリを設定できます。</li>
<li><strong>--add-repository:</strong>
composer.jsonの中に独自のリポジトリを加えます。
固定ファイルが存在している場合、一旦削除されインストールの代わりに更新が走ります。</li>
<li><strong>--dev:</strong> <code>require-dev</code>に挙げられたパッケージをインストールします。</li>
<li><strong>--no-dev:</strong> require-devのパッケージのインストールを無効にします。</li>
<li><strong>--no-scripts:</strong>
根幹パッケージで定義されているスクリプトの実行を無効にします。</li>
<li><strong>--no-progress:</strong>
進捗表示を除きます。
バックスペース文字を扱わない端末やスクリプトではこの表示があることで散らかってしまうからです。</li>
<li><strong>--no-secure-http:</strong>
根幹パッケージのインストール中、一時的にsecure-http設定オプションを無効にします。
自己責任でご利用ください。
このフラグを使うのは関心しません。</li>
<li><strong>--keep-vcs:</strong>
作成されるプロジェクトのVCSメタデータの削除を飛ばします。
これが役に立つのはコマンドを非対話的なモードで走らせているときが殆どです。</li>
<li><strong>--remove-vcs:</strong> プロンプト無しにVCSメタデータを強制削除します。</li>
<li><strong>--no-install:</strong> ベンダーのインストールを無効にします。</li>
<li><strong>--no-audit:</strong>
インストールが完了した後の監査過程を走らせないようにします。
<a href="doc/03-cli.html#composer-no-audit">COMPOSER_NO_AUDIT</a>も参照してください。</li>
<li><strong>--audit-format:</strong> 監査の出力形式です。
"table"、"plain"、"json"、または"summary"（既定）のどれかでなければなりません。</li>
<li><strong>--ignore-platform-reqs:</strong>
全てのプラットフォーム要件（<code>php</code>、<code>hhvm</code>、<code>lib-*</code>、<code>ext-*</code>）を無視し、ローカルマシンがたとえこれらを満たしていなくてもインストールを強行します。
<a href="doc/06-config.html#platform"><code>platform</code></a>設定オプションも参照してください。</li>
<li><strong>--ignore-platform-req:</strong>
特定のプラットフォーム要件（<code>php</code>、<code>hhvm</code>、<code>lib-*</code>、<code>ext-*</code>）を無視して、たとえローカルマシンが満たしていなかったとしても、インストールを強行します。
ワイルドカードを使って複数の要件を無視できます。</li>
<li><strong>--ask:</strong> 利用者に新しいプロジェクトの対象ディレクトリを入れてもらうようにします。</li>
</ul>
<h2 id="dump-autoload--dumpautoload"><a class="header" href="#dump-autoload--dumpautoload">dump-autoload / dumpautoload</a></h2>
<p>例えばクラスマップパッケージ中に新しいクラスができたことによって自動読み込み器を更新する必要がある場合は、インストールや更新を行わずとも<code>dump-autoload</code>が使えます。</p>
<p>加えて、効率性の理由からPSR-0/4のパッケージをクラスマップのものに変換する、最適化された自動読み込み器を吐き出すことができます。
多くのクラスがある比較的大規模なアプリケーションでは、自動読み込み器には毎回のリクエストに掛かる時間のうち無視できない時間が掛かります。
開発時に常にクラスマップを使うことはあまり便利ではありませんが、このオプションを使えば便宜上PSR-0/4を使いつつも、効率性のためにクラスマップを使うことができます。</p>
<h3 id="オプション-20"><a class="header" href="#オプション-20">オプション</a></h3>
<ul>
<li><strong>--optimize (-o):</strong>
PSR-0/4自動読み込みをクラスマップに変換し、より高速な自動読み込み器を得ます。
実運用で特に推奨されますが、走らせるのに少し時間が掛かるため、現時点では既定で有効になっていません。</li>
<li><strong>--classmap-authoritative (-a):</strong>
クラスマップからのみクラスを自動読み込みします。暗に<code>--optimize</code>を有効します。</li>
<li><strong>--apcu:</strong> APCuを使って、クラスの有無をキャッシュします。</li>
<li><strong>--apcu-prefix:</strong> APCu自動読み込み器のキャッシュに独自の接頭辞を使います。暗に<code>--apcu</code>を有効にします。</li>
<li><strong>--dry-run:</strong>
操作内容を出力しますが、何も実行しません。</li>
<li><strong>--no-dev:</strong> autoload-dev規則を無効にします。
既定では、Composerは直近の<code>install --no-dev</code>または<code>update --no-dev</code>の状態に随って自動的にこれを推測します。</li>
<li><strong>--dev:</strong> autoload-dev規則を有効にします。
既定では、Composerは直近の<code>install --no-dev</code>または<code>update --no-dev</code>の状態に随って自動的にこれを推測します。</li>
<li><strong>--ignore-platform-reqs:</strong>
全ての<code>php</code>、<code>hhvm</code>、<code>lib-*</code>、<code>ext-*</code>要件を無視し、これらの<a href="doc/07-runtime.html#platform-check">プラットフォーム検査</a>を飛ばします。<a href="doc/06-config.html#platform"><code>platform</code></a>設定オプションも参照してください。</li>
<li><strong>--ignore-platform-req:</strong>
特定のプラットフォーム要件（<code>php</code>、<code>hhvm</code>、<code>lib-*</code>、<code>ext-*</code>）を無視し、それについての<a href="doc/07-runtime.html#platform-check">プラットフォーム検査</a>を飛ばします。
ワイルドカードを使って複数の要件を無視できます。</li>
<li><strong>--strict-psr:</strong> PSR-4またはPSR-0の対応付けでの失敗が存在する場合は、失敗の終了コード (1) を返します。
動作には--optimizeが必要です。</li>
<li><strong>--strict-ambiguous:</strong>
複数ファイルに同じクラスがあるとき、失敗の終了コード (2) を返します。
動作には--optimizeが必要です。</li>
</ul>
<h2 id="clear-cache--clearcache--cc"><a class="header" href="#clear-cache--clearcache--cc">clear-cache / clearcache / cc</a></h2>
<p>Composerのキャッシュディレクトリから全ての内容を削除します。</p>
<h3 id="オプション-21"><a class="header" href="#オプション-21">オプション</a></h3>
<ul>
<li><strong>--gc:</strong> ガベージコレクションのみを走らせます。完全なキャッシュの消去は行いません。</li>
</ul>
<h2 id="licenses"><a class="header" href="#licenses">licenses</a></h2>
<p>インストールされている全てのパッケージの名前、バージョン、使用許諾を一覧にします。
<code>--format-json</code>を使うと、機械で読み込みやすい出力が得られます。</p>
<h3 id="オプション-22"><a class="header" href="#オプション-22">オプション</a></h3>
<ul>
<li><strong>--format:</strong> 出力の形式です。text、json、summaryの何れかです（既定では「text」）。</li>
<li><strong>--no-dev:</strong> 出力から開発依存関係を除きます。</li>
</ul>
<h2 id="run-script--run"><a class="header" href="#run-script--run">run-script / run</a></h2>
<h3 id="オプション-23"><a class="header" href="#オプション-23">オプション</a></h3>
<ul>
<li><strong>--timeout:</strong> スクリプトの制限時間を秒単位で設定します。0は制限時間無しです。</li>
<li><strong>--dev:</strong> 開発モードを設定します。</li>
<li><strong>--no-dev:</strong> 開発モードを無効にします。</li>
<li><strong>--list (-l):</strong> 利用者が定義したスクリプトを一覧にします。</li>
</ul>
<p><a href="doc/articles/scripts.html">スクリプト</a>を手動で走らせるにはこのコマンドを使うことができます。スクリプト名と任意で必要な引数を与えます。</p>
<h2 id="exec"><a class="header" href="#exec">exec</a></h2>
<p>ベンダーのバイナリやスクリプトを実行します。
どんなコマンドも実行できますし、コマンドが走る前に必ずComposerのbin-dirがPATHに加えられます。</p>
<h3 id="オプション-24"><a class="header" href="#オプション-24">オプション</a></h3>
<ul>
<li><strong>--list (-l):</strong> 利用できるComposerのバイナリを一覧にします。</li>
</ul>
<h2 id="diagnose"><a class="header" href="#diagnose">diagnose</a></h2>
<p>バグや奇妙な挙動を発見したと思ったら、<code>diagnose</code>コマンドを走らせて、多くのよくある問題について自動化された検査を実施できます。</p>
<pre><code class="language-shell">php composer.phar diagnose
</code></pre>
<h2 id="archive"><a class="header" href="#archive">archive</a></h2>
<p>このコマンドを使うと、与えられたバージョンの与えられたパッケージについてzip/tarアーカイブを生成します。
除外・無視対象のファイルを除く、プロジェクト全体をアーカイブするために使うこともできます。</p>
<pre><code class="language-shell">php composer.phar archive vendor/package 2.0.21 --format=zip
</code></pre>
<h3 id="オプション-25"><a class="header" href="#オプション-25">オプション</a></h3>
<ul>
<li><strong>--format (-f):</strong> アーカイブ結果の形式です。tar、tar.gz、tar.bz2、zipのいずれかです（既定：「tar」）。</li>
<li><strong>--dir:</strong> アーカイブをこのディレクトリに書き出します（既定：「.」）。</li>
<li><strong>--file:</strong> 与えられたファイル名でアーカイブを書き出します。</li>
</ul>
<h2 id="audit"><a class="header" href="#audit">audit</a></h2>
<p>このコマンドを使うと、インストールしたパッケージに対し、セキュリティ上の問題がありうるか監査できます。
既定では<a href="https://packagist.org/apidoc#list-security-advisories">Packagist.org
api</a>を使い、セキュリティ上の脆弱性に対する推奨事項を確認して一覧にします。
<code>composer.json</code>の<code>repositories</code>節で指定されたときは、他のリポジトリが使われます。
このコマンドでは、放棄されたパッケージも検出されます。</p>
<p>監査コマンドでは、脆弱なパッケージや放棄されたパッケージがあるか判定されます。
見つかったものに基づいて、以下の終了コードを返します。</p>
<ul>
<li><code>0</code> は、問題なし</li>
<li><code>1</code> は、脆弱なパッケージ</li>
<li><code>2</code> は、放棄されたパッケージ</li>
<li><code>3</code> は、脆弱なパッケージと放棄されたパッケージ</li>
</ul>
<pre><code class="language-shell">php composer.phar audit
</code></pre>
<h3 id="オプション-26"><a class="header" href="#オプション-26">オプション</a></h3>
<ul>
<li><strong>--no-dev:</strong> require-devのパッケージの監査を無効にします。</li>
<li><strong>--format (-f):</strong>
出力の形式を監査します。監査の出力は「table」（既定）、「plain」、「json」、「summary」の何れかです。</li>
<li><strong>--locked:</strong>
固定ファイルのパッケージを監査します。
現時点でベンダーディレクトリに何があるかは無視されます。</li>
<li><strong>--abandoned:</strong>
放棄されたパッケージに対して動作します。
「ignore」「report」「fail」のどれかでなければなりません。
<a href="doc/06-config.html#abandoned">audit.abandoned</a>もご参照ください。
このフラグを渡すと、構成値と環境変数がオーバーライドされます。</li>
<li><strong>--ignore-severity:</strong>
特定の深刻度の水準の勧告を無視します。
複数の深刻度を無視するために1回以上渡せます。</li>
</ul>
<h2 id="help"><a class="header" href="#help">help</a></h2>
<p>あるコマンドについて詳細が知りたければ<code>help</code>が使えます。</p>
<pre><code class="language-shell">php composer.phar help install
</code></pre>
<h2 id="コマンドラインインターフェース"><a class="header" href="#コマンドラインインターフェース">コマンドラインインターフェース</a></h2>
<p>コマンドライン補完は、<code>composer completion --help</code>コマンドを走らせると有効にできます。
また、以下の手順に従ってください。</p>
<h2 id="環境変数"><a class="header" href="#環境変数">環境変数</a></h2>
<p>環境変数を設定して多くの設定を上書きできます。
できる限りこうした設定は環境変数ではなく<code>composer.json</code>の<code>config</code>部分で指定することをお勧めします。
環境変数は<code>composer.json</code>で指定された値より常に優先されるということ以外に利点はありません。</p>
<h3 id="composer"><a class="header" href="#composer">COMPOSER</a></h3>
<p><code>COMPOSER</code>環境変数を設定することにより、<code>composer.json</code>のファイル名を何か別のものに設定できます。</p>
<p>例えば：</p>
<pre><code class="language-shell">COMPOSER=composer-other.json php composer.phar install
</code></pre>
<p>生成される固定ファイルは同じ名前を使います。
この例では<code>composer-other.lock</code>です。</p>
<h3 id="composer_allow_superuser"><a class="header" href="#composer_allow_superuser">COMPOSER_ALLOW_SUPERUSER</a></h3>
<p>1に設定すると、この環境変数はコマンドをルートないし特権のある利用者として走らせることについての警告を無効にします。
自動的なsudoセッションの消去も無効にするため、必ずDockerコンテナのような特権のある利用者として、常時Composerを使うときにのみ設定するようにしてください。</p>
<h3 id="composer_allow_xdebug"><a class="header" href="#composer_allow_xdebug">COMPOSER_ALLOW_XDEBUG</a></h3>
<p>1に設定すると、Xdebug拡張を持たないPHPを再始動させることなく、環境変数はXdebug拡張が有効のときにComposerを走らせられるようにします。</p>
<h3 id="composer_auth"><a class="header" href="#composer_auth">COMPOSER_AUTH</a></h3>
<p><code>COMPOSER_AUTH</code>変数では、環境変数として認証を設定できます。
変数の内容はJSON形式のオブジェクトで、<a href="doc/articles/authentication-for-private-packages.html">http-basic、github-oauth、bitbucket-oauth、……といった必要に応じたもの</a>です。
オブジェクトは<a href="doc/06-config.html">設定の仕様</a>に従います。</p>
<h3 id="composer_bin_dir"><a class="header" href="#composer_bin_dir">COMPOSER_BIN_DIR</a></h3>
<p>このオプションを設定すると<code>bin</code>ディレクトリ（<a href="doc/articles/vendor-binaries.html">ベンダーバイナリ</a>）を<code>vendor/bin</code>とは違う別のどこかに変更できます。</p>
<h3 id="composer_cache_dir"><a class="header" href="#composer_cache_dir">COMPOSER_CACHE_DIR</a></h3>
<p><code>COMPOSER_CACHE_DIR</code>変数ではComposerのキャッシュディレクトリを変更できます。
<a href="doc/06-config.html#cache-dir"><code>cache-dir</code></a>オプションを介しても設定できます。</p>
<p>Windowsにおいて既定では<code>C:\Users\&lt;user&gt;\AppData\Local\Composer</code>（もしくは<code>%LOCALAPPDATA%/Composer</code>）を指します。
*nixシステムでは<a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html">XDG Base Directory Specifications</a>に従い、<code>$XDG_CACHE_HOME/composer</code>を指します。他の*nixシステムとmacOSにおいては<code>$COMPOSER_HOME/cache</code>を指します。</p>
<h3 id="composer_cafile"><a class="header" href="#composer_cafile">COMPOSER_CAFILE</a></h3>
<p>この環境値を設定することで、パスを証明書バンドルファイルに設定してSSL/TLSピア検証で使えるようにします。</p>
<h3 id="composer_disable_xdebug_warn"><a class="header" href="#composer_disable_xdebug_warn">COMPOSER_DISABLE_XDEBUG_WARN</a></h3>
<p>1に設定すると、ComposerがXdebug拡張が有効の状態で走っているときに出す警告をこの環境変数により抑制します。</p>
<h3 id="composer_discard_changes"><a class="header" href="#composer_discard_changes">COMPOSER_DISCARD_CHANGES</a></h3>
<p>この環境変数は<a href="doc/06-config.html#discard-changes"><code>discard-changes</code></a>設定オプションを制御します。</p>
<h3 id="composer_fund"><a class="header" href="#composer_fund">COMPOSER_FUND</a></h3>
<p>この環境変数を0に設定すると、インンストール時に投資のお知らせを抑制します。</p>
<h3 id="composer_home"><a class="header" href="#composer_home">COMPOSER_HOME</a></h3>
<p><code>COMPOSER_HOME</code>変数によりComposerのホームディレクトリを変えられます。
全てのプロジェクトで共有される、隠された（マシン上の使用者毎の）大域的なディレクトリです。</p>
<p><code>composer config --global home</code>を使ってホームディレクトリの場所を確認してください。</p>
<p>既定では、Windowsにおいては<code>C:\Users\&lt;user&gt;\AppData\Roaming\Composer</code>を、macOSにおいては<code>/Users/&lt;user&gt;/.composer</code>を指します。*nixシステムでは<a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html">XDG Base Directory Specifications</a>に従い、<code>$XDG_CONFIG_HOME/composer</code>を指します。他の*nixシステムでは<code>/home/&lt;user&gt;/.composer</code>を指します。</p>
<h4 id="composer_homeconfigjson"><a class="header" href="#composer_homeconfigjson">COMPOSER_HOME/config.json</a></h4>
<p><code>config.json</code>ファイルを<code>COMPOSER_HOME</code>が指す場所に置くことができます。Composerは<code>install</code>及び<code>update</code>コマンドを走らせたとき、部分的に（<code>config</code>および<code>repositories</code>キーのみ）この設定をプロジェクトの<code>composer.json</code>と統合します。</p>
<p>このファイルがあれば使用者のプロジェクト用に<a href="doc/05-repositories.html">リポジトリ</a>と<a href="doc/06-config.html">構成</a>を設定できます。</p>
<p>大域的な設定が<em>ローカルの</em>設定に合致した場合、プロジェクトの<code>composer.json</code>が常に優先されます。</p>
<h3 id="composer_htaccess_protect"><a class="header" href="#composer_htaccess_protect">COMPOSER_HTACCESS_PROTECT</a></h3>
<p>既定では<code>1</code>です。<code>0</code>に設定するとComposerはComposerのホーム、キャッシュ、データディレクトリに<code>.htaccess</code>ファイルを作りません。</p>
<h3 id="composer_memory_limit"><a class="header" href="#composer_memory_limit">COMPOSER_MEMORY_LIMIT</a></h3>
<p>設定すると、その値がphpのメモリ上限として使われます。</p>
<h3 id="composer_mirror_path_repos"><a class="header" href="#composer_mirror_path_repos">COMPOSER_MIRROR_PATH_REPOS</a></h3>
<p>1に設定すると、この環境変数は既定のパスリポジトリ戦略を<code>symlink</code>ではなく<code>mirror</code>に変更します。既定の戦略が設定されているため、リポジトリオプションで上書きすることもできます。</p>
<h3 id="composer_no_interaction"><a class="header" href="#composer_no_interaction">COMPOSER_NO_INTERACTION</a></h3>
<p>1に設定すると、この環境変数によりComposerがあたかも全てのコマンドについて<code>--no-interaction</code>フラグを渡されたかのように動作します。
build box/CIで設定できます。</p>
<h3 id="composer_process_timeout"><a class="header" href="#composer_process_timeout">COMPOSER_PROCESS_TIMEOUT</a></h3>
<p>この環境変数はコマンド（例えばgitコマンド）が実行終了するまでの待機時間を制御します。既定値は300秒（5分）です。</p>
<h3 id="composer_root_version"><a class="header" href="#composer_root_version">COMPOSER_ROOT_VERSION</a></h3>
<p>この変数を設定することで、根幹パッケージのバージョンがVCSの情報から推測できず、<code>composer.json</code>にもないときに、そのバージョンを指定できます。</p>
<h3 id="composer_vendor_dir"><a class="header" href="#composer_vendor_dir">COMPOSER_VENDOR_DIR</a></h3>
<p>この変数を設定することでComposerに依存関係を<code>vendor</code>以外のディレクトリにインストールさせられます。</p>
<h3 id="composer_runtime_env"><a class="header" href="#composer_runtime_env">COMPOSER_RUNTIME_ENV</a></h3>
<p>これによりどの環境でComposerが走っているのかの手掛かりが得られ、Composerで何らかの環境特有の問題を回避するための助けになります。
現在対応している唯一の値は<code>virtualbox</code>で、こうするといくつかの短い<code>sleep()</code>呼び出しを有効にして、ファイルシステムが適切にファイルに書き込むのを待ってからそのファイルを読み込むようにします。
VagrantやVirtualboxを使っていてファイルが存在しているのにも関わらずインストール時にファイルがない旨問題に遭遇したときは、この環境変数を設定すると良いでしょう。</p>
<h3 id="http_proxyやhttp_proxy"><a class="header" href="#http_proxyやhttp_proxy">http_proxyやHTTP_PROXY</a></h3>
<h3 id="http_proxy_request_fulluri"><a class="header" href="#http_proxy_request_fulluri">HTTP_PROXY_REQUEST_FULLURI</a></h3>
<h3 id="https_proxy_request_fulluri"><a class="header" href="#https_proxy_request_fulluri">HTTPS_PROXY_REQUEST_FULLURI</a></h3>
<h3 id="no_proxyやno_proxy"><a class="header" href="#no_proxyやno_proxy">no_proxyやNO_PROXY</a></h3>
<p>プロキシの環境変数の使い方についての詳細は、<a href="doc/faqs/how-to-use-composer-behind-a-proxy.html">プロキシのドキュメント</a>を参照してください。</p>
<h3 id="composer_audit_abandoned"><a class="header" href="#composer_audit_abandoned">COMPOSER_AUDIT_ABANDONED</a></h3>
<p><code>ignore</code>、<code>report</code>、<code>fail</code>に設定すると、<a href="doc/06-config.html#abandoned">audit.abandoned</a>構成オプションをオーバーライドします。</p>
<h3 id="composer_max_parallel_http"><a class="header" href="#composer_max_parallel_http">COMPOSER_MAX_PARALLEL_HTTP</a></h3>
<p>整数を指定し、並列で何個のファイルをダウンロードするか設定します。
既定で12になっており、1から50の間でなければいけません。
プロキシに並列性の問題があるときはこの値を下げたいかもしれません。
この値を増加させても一般には効率性が上がる結果にはならないでしょう。</p>
<h3 id="composer_ipresolve"><a class="header" href="#composer_ipresolve">COMPOSER_IPRESOLVE</a></h3>
<p><code>4</code>ないし<code>6</code>に設定するとそれぞれIPv4ないしIPv6の解決を強制します。
ダウンロード用にcurl拡張が使用されている場合にのみ機能します。</p>
<h3 id="composer_self_update_target"><a class="header" href="#composer_self_update_target">COMPOSER_SELF_UPDATE_TARGET</a></h3>
<p>設定した場合、self-updateコマンドが元あるファイルではなく与えられたパスに新しいComposerのpharファイルを書き込むようにします。読み込み専用のファイルシステムでComposerを更新するときに便利です。</p>
<h3 id="composer_disable_network"><a class="header" href="#composer_disable_network">COMPOSER_DISABLE_NETWORK</a></h3>
<p><code>1</code>に設定するとネットワークアクセスを（最大限の努力で）無効にします。この変数はComposerをデバッグしたり貧弱な接続環境下で走らせたりするのに使えます。</p>
<p><code>prime</code>に設定した場合、GitHub VCSリポジトリはキャッシュに前もって溜め込んでおくため、<code>1</code>で完全にオフラインで使えるようになります。</p>
<h3 id="composer_debug_events"><a class="header" href="#composer_debug_events">COMPOSER_DEBUG_EVENTS</a></h3>
<p><code>1</code>に設定するとディスパッチされたイベントについての情報を出力します。プラグインの作者にとって何が厳密にどの時点で発火しているのか特定するのに便利かもしれません。</p>
<h3 id="composer_skip_scripts"><a class="header" href="#composer_skip_scripts">COMPOSER_SKIP_SCRIPTS</a></h3>
<p>イベント名のコンマ区切りリストを受け付けます。
例えば、スクリプト実行をスキップするための<code>post-install-cmd</code>があります。</p>
<h3 id="composer_no_audit"><a class="header" href="#composer_no_audit">COMPOSER_NO_AUDIT</a></h3>
<p><code>1</code>に設定すると、<code>require</code>、<code>update</code>、<code>remove</code>、<code>create-project</code>コマンドに<code>--no-audit</code>コマンドを渡すことと等価になります。</p>
<h3 id="composer_no_dev"><a class="header" href="#composer_no_dev">COMPOSER_NO_DEV</a></h3>
<p><code>1</code>に設定すると<code>--update-no-dev</code>を<code>require</code>に渡したり<code>install</code>、<code>update</code>に<code>--no-dev</code>オプションを渡すのと等価になります。
<code>COMPOSER_NO_DEV=0</code>を設定することで1回のコマンドについてこの設定を上書きできます。</p>
<h3 id="composer_prefer_stable"><a class="header" href="#composer_prefer_stable">COMPOSER_PREFER_STABLE</a></h3>
<p><code>1</code>に設定すると<code>update</code>や<code>require</code>に<code>--prefer-stable</code>オプションを渡すことと等価になります。</p>
<h3 id="composer_prefer_lowest"><a class="header" href="#composer_prefer_lowest">COMPOSER_PREFER_LOWEST</a></h3>
<p><code>1</code>に設定すると<code>update</code>や<code>require</code>に<code>--prefer-lowest</code>オプションを渡すことと等価になります。</p>
<h3 id="composer_minimal_changes"><a class="header" href="#composer_minimal_changes">COMPOSER_MINIMAL_CHANGES</a></h3>
<p><code>1</code>に設定すると、<code>update</code>や<code>require</code>や<code>remove</code>に<code>--minimal-changes</code>オプションを渡すことと等価になります。</p>
<h3 id="composer_ignore_platform_reqやcomposer_ignore_platform_reqs"><a class="header" href="#composer_ignore_platform_reqやcomposer_ignore_platform_reqs">COMPOSER_IGNORE_PLATFORM_REQやCOMPOSER_IGNORE_PLATFORM_REQS</a></h3>
<p><code>COMPOSER_IGNORE_PLATFORM_REQS</code>を<code>1</code>に設定すると、<code>--ignore-platform-reqs</code>引数を渡すことと等価になります。
他方で<code>COMPOSER_IGNORE_PLATFORM_REQ</code>でコンマ区切りのリストを指定すると、これらの特定の要件を無視します。</p>
<p>例えば開発ワークステーションが全くデータベースクエリを走らせない場合、データベースの要件が利用できることの要件を無視するのに使うことができます。<code>COMPOSER_IGNORE_PLATFORM_REQ=ext-oci8</code>を設定すると、Composerは<code>oci8</code>PHP拡張が有効になっていなくともパッケージをインストールします。</p>
<h3 id="composer_with_dependencies"><a class="header" href="#composer_with_dependencies">COMPOSER_WITH_DEPENDENCIES</a></h3>
<p><code>1</code>に設定すると、<code>update</code>や<code>require</code>や<code>remove</code>に、<code>--with-dependencies</code>オプションを渡すことと同じです。</p>
<h3 id="composer_with_all_dependencies"><a class="header" href="#composer_with_all_dependencies">COMPOSER_WITH_ALL_DEPENDENCIES</a></h3>
<p><code>1</code>に設定すると、<code>update</code>や<code>require</code>や<code>remove</code>に、<code>--with-all-dependencies</code>オプションを渡すことと同じです。</p>
<p>← <a href="doc/02-libraries.html">ライブラリ</a>  | <a href="doc/04-schema.html">スキーマ</a> →</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="composerjsonのスキーマ"><a class="header" href="#composerjsonのスキーマ">composer.jsonのスキーマ</a></h1>
<p>この章では<code>composer.json</code>で利用できる全てのフィールドについて説明します。</p>
<h2 id="jsonスキーマ"><a class="header" href="#jsonスキーマ">JSONスキーマ</a></h2>
<p>形式をドキュメント化する<a href="https://json-schema.org">JSON
schema</a>があり、<code>composer.json</code>を検証するのにも使えます。実際、<code>validate</code>コマンドによって使われています。
https://getcomposer.org/schema.json から取得できます。</p>
<h2 id="根幹パッケージ"><a class="header" href="#根幹パッケージ">根幹パッケージ</a></h2>
<p>根幹パッケージとは、<code>composer.json</code>でプロジェクトの根幹に定義されたパッケージのことです。
プロジェクトの要件を定義しているのが主眼の<code>composer.json</code>なのです。</p>
<p>フィールドの中には根幹パッケージの文脈でのみ適用されるものがあります。
この一例は<code>config</code>フィールドです。
根幹パッケージのみが設定を定義できます。
依存関係の設定は無視されます。
このようにして<code>config</code>フィールドは<code>root-only</code>になるのです。</p>
<blockquote>
<p><strong>補足：</strong>
パッケージは文脈によって根幹パッケージになったりならなかったりします。
例えばプロジェクトが<code>monolog</code>ライブラリに依存している場合、そのプロジェクトは根幹パッケージです。
しかしもし不具合修正のためにGitHubから<code>monolog</code>をクローンしてきたとすれば、<code>monolog</code>が根幹パッケージになります。</p>
</blockquote>
<h2 id="プロパティ"><a class="header" href="#プロパティ">プロパティ</a></h2>
<h3 id="name"><a class="header" href="#name">name</a></h3>
<p>パッケージ名です。ベンダー名とプロジェクト名から構成され、<code>/</code>で区切られます。例えば：</p>
<ul>
<li>monolog/monolog</li>
<li>igorw/event-source</li>
</ul>
<p>名前は小文字で、単語は<code>-</code>や<code>.</code>や<code>_</code>で区切られていなくてはなりません。
名前全体は<code>^[a-z0-9]([_.-]?[a-z0-9]+)*/[a-z0-9](([_.]|-{1,2})?[a-z0-9]+)*$</code>に照合します。</p>
<p><code>name</code>プロパティは公開されるパッケージ（ライブラリ）には必須です。</p>
<blockquote>
<p><strong>補足：</strong> Composerのバージョン2.0より前は、名前には空白込みでどんな文字も含められました。</p>
</blockquote>
<h3 id="description"><a class="header" href="#description">description</a></h3>
<p>パッケージの短い説明です。
大抵1行分の長さです。</p>
<p>公開されるパッケージ（ライブラリ）には必須です。</p>
<h3 id="version"><a class="header" href="#version">version</a></h3>
<p>パッケージのバージョンです。
殆どの場合は必須でなく、省略すべきです（後述）。</p>
<p><code>X.Y.Z</code>や<code>vX.Y.Z</code>の形式に従っていなければなりません。
オプションで<code>-dev</code>、<code>-patch</code> (<code>-p</code>)、<code>-alpha</code> (<code>-a</code>)、<code>-beta</code>
(<code>-b</code>)、<code>-RC</code>を接尾辞に付けても構いません。
また、patch、alpha、beta、RCの接尾辞には数字を続けても大丈夫です。</p>
<p>例：</p>
<ul>
<li>1.0.0</li>
<li>1.0.2</li>
<li>1.1.0</li>
<li>0.2.5</li>
<li>1.0.0-dev</li>
<li>1.0.0-alpha3</li>
<li>1.0.0-beta2</li>
<li>1.0.0-RC5</li>
<li>v2.0.4-p1</li>
</ul>
<p>パッケージのリポジトリのどこかしらからバージョンが推測できるのであれば、このプロパティはオプションです。
例えばVCSリポジトリのVCSのタグ名などです。
その場合は省略することが推奨されます。</p>
<blockquote>
<p><strong>補足：</strong> PackagistはVCSリポジトリを使うため、上の記載はPackagistにも全く同じことが言えます。
自分でバージョンを指定すると、ほぼ確実にいつか手作業による誤りにより問題が生じることでしょう。</p>
</blockquote>
<h3 id="type"><a class="header" href="#type">type</a></h3>
<p>パッケージの種別です。既定は<code>library</code>です。</p>
<p>パッケージの種別は独自のインストールの仕組みに使われます。
何らかの特別な仕組みが必要なパッケージがあるとき、<code>symfony-bundle</code>、<code>wordpress-plugin</code>、<code>typo3-cms-extension</code>といった独自の種別を定義できます。
これらの種別は全て特定のプロジェクトに特有のものであって、その種別のパッケージのインストールができるようなインストーラを提供する必要があります。</p>
<p>その中でも特にComposerは4つの種別に対応しています。</p>
<ul>
<li><strong>library:</strong>
既定です。
ファイルを<code>vendor</code>に複製します。</li>
<li><strong>project:</strong>
ライブラリではなくプロジェクトであることを示します。
例えば<a href="https://github.com/symfony/symfony-standard">標準版Symfony</a>のようなアプリケーションのシェル、<a href="https://github.com/silverstripe/silverstripe-installer">Silverstripeインストーラ</a>のようなCMS、あるいはパッケージとして配布される完全なアプリケーションがこれにあたります。
例として、IDEから新しいワークスペースを作る際に、初期化するプロジェクトの一覧を提供するのに使えます。</li>
<li><strong>metapackage:</strong>
要件を含む空のパッケージでありインストールの条件になりますが、ファイルを含んでおらずファイルシステムに何も書き込まないものです。
そうしたわけで、インストールできるdistやsourceキーを必要としません。</li>
<li><strong>composer-plugin:</strong>
種別<code>composer-plugin</code>のパッケージは独自の種別を持つ他のパッケージのインストーラを提供することがあります。
詳細は<a href="doc/articles/custom-installers.html">専門記事</a>を参照してください。</li>
<li><strong>php-ext</strong>と<strong>php-ext-zend</strong>：
これらの名前はCで書かれたPHPの拡張パッケージ用に予約されています。
これらの種別はPHPで書かれたパッケージ用に使わないでください。</li>
</ul>
<p>インストール時に独自の仕組みが必要な場合にのみ独自の種別を使ってください。
このフィールドを省略し、既定の<code>library</code>にするのがお勧めです。</p>
<h3 id="keywords"><a class="header" href="#keywords">keywords</a></h3>
<p>パッケージに関係するキーワードの配列です。検索と絞り込みに使えます。</p>
<p>例：</p>
<ul>
<li>logging</li>
<li>events</li>
<li>database</li>
<li>redis</li>
<li>templating</li>
</ul>
<blockquote>
<p><strong>補足</strong>：<code>--dev</code>オプション無しで<code>composer require</code>するようにし、パッケージを<code>require</code>ではなく<code>require-dev</code>に追加しても良いか利用者にプロンプトを出す特別なキーワードがあります。
<code>dev</code>、<code>testing</code>、<code>static analysis</code>がそれです。</p>
</blockquote>
<blockquote>
<p><strong>補足</strong>：文字列内で許される文字の範囲には、ユニコードの英数字、空白<code>" "</code>、ドット<code>.</code>、下線<code>_</code>、ダッシュ<code>-</code>（正規表現：<code>'{^[\p{N}\p{L} ._-]+$}u'</code>）の制限があります。
その他の文字を使うと、<code>composer validate</code>を走らせるときに警告が出ます。
またパッケージのPackagist.orgへの更新が失敗する原因となります。</p>
</blockquote>
<p>省略可能です。</p>
<h3 id="homepage"><a class="header" href="#homepage">homepage</a></h3>
<p>プロジェクトのwebサイトへのURLです。</p>
<p>省略可能です。</p>
<h3 id="readme"><a class="header" href="#readme">readme</a></h3>
<p>readmeドキュメントへの相対パスです。
既定では<code>README.md</code>です。</p>
<p>主にパッケージがGitHubにないときに有用です。
GitHubのパッケージの場合、Packagist.orgではGitHub側で検出されたものを取得するreadme APIを使うからです。</p>
<p>省略可能です。</p>
<h3 id="time"><a class="header" href="#time">time</a></h3>
<p>当該バージョンのリリース日です。</p>
<p><code>YYYY-MM-DD</code>または<code>YYYY-MM-DD HH:MM:SS</code>の形式で、UTCタイムゾーンでなければなりません。</p>
<p>省略可能です。</p>
<h3 id="license"><a class="header" href="#license">license</a></h3>
<p>パッケージの利用許諾です。
文字列または文字列の配列にできます。</p>
<p>最頻出の利用許諾についての推奨される記法は以下の通り（辞書順）。</p>
<ul>
<li>Apache-2.0</li>
<li>BSD-2-Clause</li>
<li>BSD-3-Clause</li>
<li>BSD-4-Clause</li>
<li>GPL-2.0-only / GPL-2.0-or-later</li>
<li>GPL-3.0-only / GPL-3.0-or-later</li>
<li>LGPL-2.1-only / LGPL-2.1-or-later</li>
<li>LGPL-3.0-only / LGPL-3.0-or-later</li>
<li>MIT</li>
</ul>
<p>オプションにはなりますが、このプロパティを付けることは強く推奨されます。他の識別子は<a href="https://spdx.org/licenses/">SPDX Open Source License
Registry</a>に一覧になっています。</p>
<blockquote>
<p><strong>Note:</strong>
ソースが閉鎖的なソフトウェアについては、利用許諾の識別子として <code>"proprietary"</code> を使うことができます。</p>
</blockquote>
<p>一例：</p>
<pre><code class="language-json">{
    "license": "MIT"
}
</code></pre>
<p>あるパッケージについて、複数の利用許諾から選択できる場合（「離接的利用許諾」）、複数のものを配列として指定できます。</p>
<p>離接的利用許諾の例です。</p>
<pre><code class="language-json">{
    "license": [
        "LGPL-2.1-only",
        "GPL-3.0-or-later"
    ]
}
</code></pre>
<p>代わりに「or」で区切って括弧で囲むこともできます。</p>
<pre><code class="language-json">{
    "license": "(LGPL-2.1-only or GPL-3.0-or-later)"
}
</code></pre>
<p>これに似ていますが、複数の利用許諾が適用される必要があるときは（「結合的利用許諾」）、「and」で区切って（）で囲むことになります。</p>
<h3 id="authors"><a class="header" href="#authors">authors</a></h3>
<p>パッケージの作者です。
オブジェクトの配列です。</p>
<p>それぞれの作者オブジェクトは以下のプロパティを持つことができます。</p>
<ul>
<li><strong>name:</strong> 作者名です。大抵は実名です。</li>
<li><strong>email:</strong> 作者のEメールアドレスです。</li>
<li><strong>homepage:</strong> 作者のwebサイトへのURLです。</li>
<li><strong>role:</strong>
プロジェクトに於ける作者の役割です（例：開発者や翻訳者）</li>
</ul>
<p>一例：</p>
<pre><code class="language-json">{
    "authors": [
        {
            "name": "Nils Adermann",
            "email": "naderman@naderman.de",
            "homepage": "https://www.naderman.de",
            "role": "Developer"
        },
        {
            "name": "Jordi Boggiano",
            "email": "j.boggiano@seld.be",
            "homepage": "https://seld.be",
            "role": "Developer"
        }
    ]
}
</code></pre>
<p>省略可能なプロパティですが、付けることを強く推奨します。</p>
<h3 id="support"><a class="header" href="#support">support</a></h3>
<p>プロジェクトについてのサポートを得るための様々な情報です。</p>
<p>サポート情報には以下が含まれます。</p>
<ul>
<li><strong>email:</strong> サポート用Eメールアドレスです。</li>
<li><strong>issues:</strong> 課題管理表へのURLです。</li>
<li><strong>forum:</strong> フォーラムへのURLです。</li>
<li><strong>wiki:</strong> wikiへのURLです。</li>
<li><strong>irc:</strong> <a href="irc://server/channel">irc://server/channel</a>のような、サポート用IRCチャンネルです。</li>
<li><strong>source:</strong> ソースを閲覧したりダウンロードしたりするURLです。</li>
<li><strong>docs:</strong> ドキュメントへのURLです。</li>
<li><strong>rss:</strong> RSSフィードへのURLです。</li>
<li><strong>chat:</strong> チャットチャンネルへのURLです。</li>
<li><strong>security:</strong> 脆弱性公表ポリシー (vulnerability disclosure policy; VDP) へのURLです。</li>
</ul>
<p>一例：</p>
<pre><code class="language-json">{
    "support": {
        "email": "support@example.org",
        "irc": "irc://irc.freenode.org/composer"
    }
}
</code></pre>
<p>省略可能です。</p>
<h3 id="funding"><a class="header" href="#funding">funding</a></h3>
<p>パッケージの作者が維持管理と新しい機能の開発を行えるよう、投資を提供するためのURLの一覧です。</p>
<p>それぞれの項目は以下のものからなります。</p>
<ul>
<li><strong>type:</strong>
投資の種別、または投資を行えるプラットフォームです。例えばpatreon、opencollective、tidelift、githubです。</li>
<li><strong>url:</strong>
詳細が記載されたwebサイトへのURLと、パッケージに投資する方法です。</li>
</ul>
<p>一例：</p>
<pre><code class="language-json">{
    "funding": [
        {
            "type": "patreon",
            "url": "https://www.patreon.com/phpdoctrine"
        },
        {
            "type": "tidelift",
            "url": "https://tidelift.com/subscription/pkg/packagist-doctrine_doctrine-bundle"
        },
        {
            "type": "other",
            "url": "https://www.doctrine-project.org/sponsorship.html"
        }
    ]
}
</code></pre>
<p>省略可能です。</p>
<h3 id="パッケージのリンク"><a class="header" href="#パッケージのリンク">パッケージのリンク</a></h3>
<p>以下の全ては、バージョン制約を介してパッケージ名とパッケージのバージョンを対応付けるオブジェクトを取ります。
バージョンについての詳細は<a href="doc/articles/versions.html">こちら</a>をお読みください。</p>
<p>例：</p>
<pre><code class="language-json">{
    "require": {
        "monolog/monolog": "1.0.*"
    }
}
</code></pre>
<p>全てのリンクは省略可能なフィールドです。</p>
<p><code>require</code>と<code>require-dev</code>は追加で<em>安定性フラグ</em>（<a href="doc/04-schema.html#root-package">根幹限定</a>）に対応しています。
"<em>constraint</em>@<em>stability flag</em>" の形式を取っています。
これらによりパッケージの安定性を、<a href="doc/04-schema.html#minimum-stability">最小安定性</a>の範疇を超え、更に制限したり拡張したりできます。
こうしたフラグは制約や空の<em>制約</em>に適用できます。
後者は例えば依存関係に不安定なパッケージを許容したい場合などです。</p>
<p>例：</p>
<pre><code class="language-json">{
    "require": {
        "monolog/monolog": "1.0.*@beta",
        "acme/foo": "@dev"
    }
}
</code></pre>
<p>依存関係のうち、不安定なパッケージに依存しているものがあれば、同様に明示的に必要安定性フラグと共に要件に加えなければなりません。</p>
<p>例：</p>
<p><code>doctrine/doctrine-fixtures-bundle</code>が<code>"doctrine/data-fixtures": "dev-master"</code>を要件としているとすると、根幹のcomposer.jsonの中で以下の2行目を加えて<code>doctrine/data-fixtures</code>パッケージの開発版リリースを許容する必要があります。</p>
<pre><code class="language-json">{
    "require": {
        "doctrine/doctrine-fixtures-bundle": "dev-master",
        "doctrine/data-fixtures": "@dev"
    }
}
</code></pre>
<p><code>require</code>と<code>require-dev</code>は追加で明示的な参照（つまりコミット）に対応しており、たとえ更新を走らせたとしても、開発版のバージョンが与えられた状態で確実に固定されているようにします。
明示的に開発版を要件にして、参照に<code>#&lt;ref&gt;</code>を付けたときにのみ動作します。
また<a href="doc/04-schema.html#root-package">根幹限定</a>の機能であり、依存関係では無視されます。</p>
<p>例：</p>
<pre><code class="language-json">{
    "require": {
        "monolog/monolog": "dev-master#2eb0c0978d290a1c45346a1955188929cb4e5db7",
        "acme/foo": "1.0.x-dev#abc123"
    }
}
</code></pre>
<blockquote>
<p><strong>補足：</strong>
この機能には厳しい技術的制約があり、composer.jsonのメタデータはハッシュの前に指定されたブランチ名から読み込んでしまいます。
したがって、この機能は開発時に一時的に取る解決法とするべきです。
一時的な問題を矯正するための、タグ付けされたリリースに切り替えるまでの対処法なのです。
Composerチームはこの機能に活発に対応しておらずこれに関するバグ報告を受け付けません。</p>
</blockquote>
<p>パッケージ制約をインラインエイリアスすることも可能で、そうでなければ合致しない制約に合致させられます。詳細については<a href="doc/articles/aliases.html">エイリアスの記事を参照してください</a>。</p>
<p><code>require</code>と<code>require-dev</code>はまた、プロジェクトを正常に走らせるために必要な特定のPHPとPHPの拡張のバージョンとへの参照に対応しています。</p>
<p>例：</p>
<pre><code class="language-json">{
    "require": {
        "php": "&gt;=7.4",
        "ext-mbstring": "*"
    }
}
</code></pre>
<blockquote>
<p><strong>補足：</strong> プロジェクトが要件とするPHP拡張を一覧にすることは重要です。
PHPのインストールが全て同じようになされるとは限りません。
標準と考えている拡張が欠けているものもあるでしょう（例えば<code>ext-mysqli</code>は、Fedora/CentOSの最小インストールシステムでは既定ではインストールされません）。
必要なPHPの要件を一覧にし損ねると、利用者体験が悪化することに繋がります。
Composerはパッケージをインストールするときは失敗することなく、実行時に失敗するからです。
<code>composer show --platform</code>コマンドはシステムで利用できる全てのPHP拡張を一覧にします。
これを使えば、使用する拡張の一覧をコンパイルして要件に加える補助になるでしょう。
代えてサードパーティーツールを使ってプロジェクトを解析し、使用されている拡張の一覧が得られるかもしれません。</p>
</blockquote>
<h4 id="require"><a class="header" href="#require">require</a></h4>
<p>このパッケージが必要とするパッケージの対応付けです。
これらの要件が満たされない限り、パッケージはインストールされません。</p>
<h4 id="require-dev-根幹限定"><a class="header" href="#require-dev-根幹限定">require-dev <span>(<a href="doc/04-schema.html#root-package">根幹限定</a>)</span></a></h4>
<p>このパッケージを開発したり、テストを走らせたりなどするのに必要なパッケージへの対応付けです。
根幹パッケージの開発要件は既定でインストールされます。
<code>install</code>と<code>update</code>の両方とも<code>--no-dev</code>オプションに対応しており、開発依存関係がインストールされるのを阻止できます。</p>
<h4 id="conflict"><a class="header" href="#conflict">conflict</a></h4>
<p>このバージョンのパッケージと競合するパッケージへの対応付けです。
それらのパッケージがこのパッケージと共にインストールされるのを許容しないようにします。</p>
<p>なお、<code>conflict</code>リンクで<code>&lt;1.0 &gt;=1.1</code>のような範囲を指定する場合、1.0より小さく<em>且つ</em>同時に1.1かそれより新しい全てのバージョンと競合しているという意味になります。
恐らくやりたいことではないでしょう。
この場合は<code>&lt;1.0 || &gt;=1.1</code>としたいことでしょう。</p>
<h4 id="replace"><a class="header" href="#replace">replace</a></h4>
<p>このパッケージが置き換えるパッケージへの対応付けです。
これによりパッケージをフォークし、独自のバージョン番号を持つ異なる名前で公開できます。
また元のパッケージが置き換わっているため、元のパッケージを要件とするパッケージはフォークしたパッケージを使って動作し続けることになります。</p>
<p>副パッケージを含むパッケージについても有用です。
例えば主眼のsymfony/symfonyパッケージには個々のパッケージとしても使える全てのSymfony Componentが含まれています。
主眼のパッケージを要件にすると、自動的に個々のコンポーネントのうち、どれか1つの要件が充足されます。
主眼のパッケージがコンポーネントを置き換えるからです。</p>
<p>上記で説明した副パッケージの目的で置き換えを使う際は忠告があります。
その場合は通常、<code>self.version</code>をバージョン制約として使うことで置き換えるだけにしておくべきです。
主眼のパッケージが厳密なバージョンの副パッケージのみを置き換えるようにするためです。
他のバージョンになるとおかしなことになるでしょう。</p>
<h4 id="provide"><a class="header" href="#provide">provide</a></h4>
<p>このパッケージにより提供されるパッケージの対応付けです。
これが最も役立つのは、共通化されたインターフェースの実装です。
パッケージは仮想パッケージに依存できます。
例としては<code>psr/log-implementation</code>で、このロガーインターフェースを実装する任意のライブラリは<code>provide</code>の一覧に加えます。
実装しているパッケージは<a href="https://packagist.org/providers/psr/log-implementation">Packagist.orgで探せます</a>。</p>
<p>仮想的なパッケージではなく、実際のパッケージの名前で<code>provide</code>を使うことは、そのパッケージのコードも世に出ているということを暗示します。
その場合、一般的には<code>replace</code>がより良い選択です。
インターフェースを提供して実装を提供する他のパッケージに任せる際（例えばPSRのインターフェース）のよくある慣習は、インターフェースパッケージに対応する仮想パッケージの名前に<code>-implementation</code>後置詞を使うことです。</p>
<h4 id="suggest"><a class="header" href="#suggest">suggest</a></h4>
<p>このパッケージを向上させたりいい感じに動かせたりするようなお勧めのパッケージです。
これらは通知のようなもので、パッケージがインストールされた後に表示されます。
利用者にもっとパッケージを加えてもらえるような手掛かりを与えるためのもので、厳密には必要でなかったとしても大丈夫です。</p>
<p>形式は上述のパッケージリンクと同様ですが、値が自由な内容のテキストで、バージョン制約ではない点は異なります。</p>
<p>例：</p>
<pre><code class="language-json">{
    "suggest": {
        "monolog/monolog": "Allows more advanced logging of the application flow",
        "ext-xml": "Needed to support XML format in class Foo"
    }
}
</code></pre>
<h3 id="autoload"><a class="header" href="#autoload">autoload</a></h3>
<p>PHPの自動読み込み器用の自動読み込みの対応付けです。</p>
<p><a href="https://www.php-fig.org/psr/psr-4/"><code>PSR-4</code></a>と<a href="http://www.php-fig.org/psr/psr-0/"><code>PSR-0</code></a>の自動読み込み、<code>classmap</code>生成、<code>files</code>による包含に対応しています。</p>
<p>PSR-4はずっと簡単に使えるためお勧めの方法です（クラスを追加したときに自動読み込み器を再生成する必要がありません）。</p>
<h4 id="psr-4"><a class="header" href="#psr-4">PSR-4</a></h4>
<p><code>psr-4</code>キー配下では名前空間からパスへの対応付けを定義します。
パスはパッケージの根幹から相対的なものです。
<code>Foo\\Bar\\Baz</code>のようなクラスを自動読み込みする場合、ディレクトリ<code>src/</code>を指す名前空間の前部分<code>Foo\\</code>は、自動読み込み器が<code>src/Bar/Baz.php</code>という名前のファイルを探索し、もしあれば含めるという意味です。
なお、比較的古いPSR-0の様式とは反対に、前部分 (<code>Foo\\</code>) はファイルパスに存在<strong>しません</strong>。</p>
<p>名前空間の前置詞は、似た前置詞との競合を避けるため、<code>\\</code>で終わっていなければなりません。
例えば<code>Foo</code>は<code>FooBar</code>名前空間のクラスに照合するので、後ろにバックスラッシュを付けると問題が解決します。
<code>Foo\\</code>と<code>FooBar\\</code>は独立しています。</p>
<p>PSR-4の参照は、installやupdateの際に、単一のキー=&gt;バリュー配列に全て結合されます。生成されるファイル<code>vendor/composer/autoload_psr4.php</code>で確認できます。</p>
<p>例：</p>
<pre><code class="language-json">{
    "autoload": {
        "psr-4": {
            "Monolog\\": "src/",
            "Vendor\\Namespace\\": ""
        }
    }
}
</code></pre>
<p>複数のディレクトリで同じ前置詞を検索する必要がある場合は、以下のように配列として指定できます。</p>
<pre><code class="language-json">{
    "autoload": {
        "psr-4": { "Monolog\\": ["src/", "lib/"] }
    }
}
</code></pre>
<p>任意の名前空間が探索されるようなフォールバックディレクトリを持たせたければ、次のように空の前置詞が使えます。</p>
<pre><code class="language-json">{
    "autoload": {
        "psr-4": { "": "src/" }
    }
}
</code></pre>
<h4 id="psr-0"><a class="header" href="#psr-0">PSR-0</a></h4>
<p><code>psr-0</code>キーの配下では名前空間からパスへの対応付けを定義します。
このパスはパッケージの根幹から相対的です。
なお、PEARの様式の名前空間が付いていない変換にも対応しています。</p>
<p>注意していただきたいのは、自動読み込み器が厳密に応答するよう、名前空間の宣言が<code>\\</code>で終わるようにすべきということです。
例えば<code>Foo</code>は<code>FooBar</code>に照合してしまうため、後ろにバックスラッシュを付けると問題が解決するでしょう。
<code>Foo\\</code>と<code>FooBar\\</code>は独立しています。</p>
<p>PSR-0の参照はinstallやupdateの際に全て単一のキー=&gt;配列値に束ねられます。
生成されたファイル<code>vendor/composer/autoload_namespaces.php</code>で確認できます。</p>
<p>例：</p>
<pre><code class="language-json">{
    "autoload": {
        "psr-0": {
            "Monolog\\": "src/",
            "Vendor\\Namespace\\": "src/",
            "Vendor_Namespace_": "src/"
        }
    }
}
</code></pre>
<p>複数のディレクトリで同じ前置詞を検索する必要がある場合は、以下のように配列として指定できます。</p>
<pre><code class="language-json">{
    "autoload": {
        "psr-0": { "Monolog\\": ["src/", "lib/"] }
    }
}
</code></pre>
<p>PSR-0の様式は名前空間の宣言のみに留まらず、クラス水準にまで指定できます。
大域的な名前空間で、ただ1つのクラスを持つライブラリについては便利かもしれません。
例えばphpのソースファイルがパッケージの根幹に位置している場合、このように宣言できます。</p>
<pre><code class="language-json">{
    "autoload": {
        "psr-0": { "UniqueGlobalClass": "" }
    }
}
</code></pre>
<p>どの名前空間にもなれるフォールバックディレクトリを持たせたければ、次のような空の前置詞を使うことができます。</p>
<pre><code class="language-json">{
    "autoload": {
        "psr-0": { "": "src/" }
    }
}
</code></pre>
<h4 id="クラスマップ"><a class="header" href="#クラスマップ">クラスマップ</a></h4>
<p><code>classmap</code>参照はinstall/update中に単一のキー=&gt;バリュー配列に全て束ねられ、<code>vendor/composer/autoload_classmap.php</code>にファイルが生成されます。この対応付けは与えられたディレクトリやファイルにある全ての<code>.php</code>または<code>.inc</code>ファイル中のクラスを読み取ることによって構築されます。</p>
<p>クラスマップ生成を使ってPSR-4に従わない全てのライブラリ用の自動読み込み器を定義できます。
これを設定するには、クラスを検索する全てのディレクトリないしファイルを指定します。</p>
<p>例：</p>
<pre><code class="language-json">{
    "autoload": {
        "classmap": ["src/", "lib/", "Something.php"]
    }
}
</code></pre>
<p>クラスマップのパスではワイルドカード (<code>*</code>) にも対応しており、任意のディレクトリ名に照合するよう展開されます。</p>
<p>例：</p>
<pre><code class="language-json">{
    "autoload": {
        "classmap": ["src/addons/*/lib/", "3rd-party/*", "Something.php"]
    }
}
</code></pre>
<h4 id="ファイル"><a class="header" href="#ファイル">ファイル</a></h4>
<p>必要に応じて特定のファイルを明示的にrequireしたい場合は、<code>files</code>自動読み込み機構を使うことができます。
PHPによって自動読み込みできないPHPの関数を含むパッケージがあるときに便利です。</p>
<p>例：</p>
<pre><code class="language-json">{
    "autoload": {
        "files": ["src/MyLibrary/functions.php"]
    }
}
</code></pre>
<p>filesの自動読み込みの規則は<code>vendor/autoload.php</code>が含まれたときは常に取り込まれ、ちょうど自動読み込み器が登録された後になります。
取り込み順序はパッケージの依存関係によります。
そのためパッケージAがBに依存している場合、パッケージBにあるファイルが最初に取り込まれます。
パッケージAのファイルが取り込まれた時点でパッケージBが完全に取り込まれて準備ができているようにするためです。</p>
<p>2つのパッケージが同量の依存関係を持つ、あるいは依存関係がない場合、順番は辞書順になります。</p>
<p>根幹パッケージのfilesは常に最後に読み込まれるため、filesを使って依存関係由来の関数を上書きするために自身を自動読み込みさせることはできません。
そうしたい場合はComposerの<code>vendor/autoload.php</code>を取り込む<em>前に</em>独自の関数を取り込むことをお勧めします。</p>
<h4 id="クラスマップからファイルを除外する"><a class="header" href="#クラスマップからファイルを除外する">クラスマップからファイルを除外する</a></h4>
<p>クラスマップから何らかのファイルやディレクトリを除外したければ<code>exclude-from-classmap</code>プロパティを使うことができます。
例えば、実環境でテストクラスを除外するのに便利かもしれません。
最適化された自動読み込み器を構築しているときでも、クラスマップから読み飛ばされるからです。</p>
<p>クラスマップ生成器はここで設定されたパスにある全てのファイルを無視します。
パスはパッケージの根幹ディレクトリからの絶対位置にあり、スラッシュ以外の全てに照合する<code>*</code>と任意のものに照合する<code>**</code>に対応しています。
<code>**</code>はパスの末尾に暗黙に追加されます。</p>
<p>例：</p>
<pre><code class="language-json">{
    "autoload": {
        "exclude-from-classmap": ["/Tests/", "/test/", "/tests/"]
    }
}
</code></pre>
<h4 id="自動読み込み器を最適化する"><a class="header" href="#自動読み込み器を最適化する">自動読み込み器を最適化する</a></h4>
<p>自動読み込み器がリクエスト時間にかなり無視できない影響があることがあります（沢山のクラスを使う大きなフレームワークではリクエストあたり50-100msです）。
この影響を低減する方法についての詳細は<a href="doc/articles/autoloader-optimization.html">自動読み込み器の最適化についての記事</a>を参照してください。</p>
<h3 id="autoload-dev-根幹限定"><a class="header" href="#autoload-dev-根幹限定">autoload-dev <span>（<a href="doc/04-schema.html#root-package">根幹限定</a>）</span></a></h3>
<p>この節では開発目的の自動読み込み規則を定義できます。</p>
<p>テストスートを走らせるのに必要なクラスは、主眼のの自動読み込み規則に含めるべきではありません。
実運用や他の人がパッケージを依存関係として使う際に、自動読み込み器を汚染するのを避けるためです。</p>
<p>したがって単体試験専用のパスを用意してautoload-dev節内に追加するのは良いことです。</p>
<p>例：</p>
<pre><code class="language-json">{
    "autoload": {
        "psr-4": { "MyLibrary\\": "src/" }
    },
    "autoload-dev": {
        "psr-4": { "MyLibrary\\Tests\\": "tests/" }
    }
}
</code></pre>
<h3 id="include-path"><a class="header" href="#include-path">include-path</a></h3>
<blockquote>
<p><strong>時代遅れ</strong> ：
古びたプロジェクトに対応するためだけに存在し、全ての新しいコードでは自動読み込み器の方を使うべきです。
そうしたわけで時代遅れなものですが、機能自体はComposerから消えることはきっとないでしょう。</p>
</blockquote>
<p>PHPの<code>include_path</code>に後付けされるパスのリストです。</p>
<p>例：</p>
<pre><code class="language-json">{
    "include-path": ["lib/"]
}
</code></pre>
<p>省略可能です。</p>
<h3 id="target-dir"><a class="header" href="#target-dir">target-dir</a></h3>
<blockquote>
<p><strong>時代遅れ</strong> ：
古びたPSR-0様式の自動読み込みに対応するためだけに存在しており、全ての新しいコードはtarget-dir無しのPSR-4を使うべきです。
PHPの名前空間と共にPSR-0を使っているプロジェクトは代わりにPSR-4への移行が推奨されます。</p>
</blockquote>
<p>インストール対象を定義します。</p>
<p>パッケージの根幹が名前空間宣言の元にある場合は適切に自動読み込みできません。
<code>target-dir</code>はこの問題を解決します。</p>
<p>一例はSymfonyです。これにはコンポーネント毎に独立のパッケージがあります。
Yamlコンポーネントは<code>Symfony\Component\Yaml</code>以下にあります。
パッケージの根幹はその<code>Yaml</code>ディレクトリです。
自動読み込みできるようにするには、必ず<code>vendor/symfony/yaml</code>ではなく<code>vendor/symfony/yaml/Symfony/Component/Yaml</code>にインストールされるようにしなければいけません。
自動読み込み器が<code>vendor/symfony/yaml</code>から読み込めるようにするためです。</p>
<p>そうするために、<code>autoload</code>と<code>target-dir</code>は以下のように定義されています。</p>
<pre><code class="language-json">{
    "autoload": {
        "psr-0": { "Symfony\\Component\\Yaml\\": "" }
    },
    "target-dir": "Symfony/Component/Yaml"
}
</code></pre>
<p>省略可能です。</p>
<h3 id="minimum-stability-根幹限定"><a class="header" href="#minimum-stability-根幹限定">minimum-stability <span>(<a href="doc/04-schema.html#root-package">根幹限定</a>)</span></a></h3>
<p>安定性によってパッケージの絞り込みをする既定の挙動を定義します。
この既定は<code>stable</code>になっているので、<code>dev</code>のパッケージに依っている場合は、驚くようなことになるのを避けるためにファイルを指定しておくべきです。</p>
<p>各パッケージの全バージョンについて安定性が検査され、<code>minimum-stability</code>設定より安定していないものは、プロジェクトの依存関係の解決の際に無視されます（なお、<code>require</code>ブロック中で指定するバージョン制約中の安定性フラグを使って、パッケージ毎に安定性の要件を指定することもできます（詳細は<a href="doc/04-schema.html#package-links">パッケージリンク</a>を参照））。</p>
<p>使えるオプションは（安定性の順番で）<code>dev</code>、<code>alpha</code>、<code>beta</code>、<code>RC</code>、<code>stable</code>です。</p>
<h3 id="prefer-stable-根幹限定"><a class="header" href="#prefer-stable-根幹限定">prefer-stable <span>（<a href="doc/04-schema.html#root-package">根幹限定</a>）</span></a></h3>
<p>これが有効になっているとき、互換性のある安定的なパッケージが使える場合に、不安定なものより安定なパッケージを贔屓します。
開発版が必要だったりパッケージでアルファ版しか使えなかったりする場合については、minimum-stabilityが許容するかどうかが考慮された上で選択されます。</p>
<p>有効にするには<code>"prefer-stable": true</code>を使ってください。</p>
<h3 id="repositories-根幹限定"><a class="header" href="#repositories-根幹限定">repositories <span>（<a href="doc/04-schema.html#root-package">根幹限定</a>）</span></a></h3>
<p>独自に使用するパッケージリポジトリです。</p>
<p>既定ではComposerはpackagistリポジトリのみを使います。
リポジトリを指定することによって、パッケージをどこからでも取得できます。</p>
<p>リポジトリは再帰的に解決されません。
主眼の<code>composer.json</code>に加えることができるだけです。
依存関係のリポジトリの<code>composer.json</code>にある宣言は無視されます。</p>
<p>以下のリポジトリの種別に対応しています。</p>
<ul>
<li><strong>composer:</strong>
Composerリポジトリはネットワーク（HTTP、FTP、SSH）越しに提供されている<code>packages.json</code>であり、追加の<code>dist</code>ないし<code>source</code>の情報付きの<code>composer.json</code>のリストを含みます。
<code>packages.json</code>ファイルはPHPのストリームを使って読み込まれます。
<code>options</code>パラメータを使ってストリームについての追加のオプションを設定できます。</li>
<li><strong>vcs:</strong> パッケージをgit、svn、fossil、hgのリポジトリから取得できるバージョン管理システムリポジトリです。</li>
<li><strong>package:</strong>
何らのComposer対応がされていないプロジェクトに依存する場合、<code>package</code>リポジトリを使ってパッケージの定義を書き下すことができます。基本的に<code>composer.json</code>オブジェクトを書き下します。</li>
</ul>
<p>これらについての詳細な情報については<a href="doc/05-repositories.html">リポジトリ</a>を参照してください。</p>
<p>例：</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "composer",
            "url": "http://packages.example.com"
        },
        {
            "type": "composer",
            "url": "https://packages.example.com",
            "options": {
                "ssl": {
                    "verify_peer": "true"
                }
            }
        },
        {
            "type": "vcs",
            "url": "https://github.com/Seldaek/monolog"
        },
        {
            "type": "package",
            "package": {
                "name": "smarty/smarty",
                "version": "3.1.7",
                "dist": {
                    "url": "https://www.smarty.net/files/Smarty-3.1.7.zip",
                    "type": "zip"
                },
                "source": {
                    "url": "https://smarty-php.googlecode.com/svn/",
                    "type": "svn",
                    "reference": "tags/Smarty_3_1_7/distribution/"
                }
            }
        }
    ]
}
</code></pre>
<blockquote>
<p><strong>補足：</strong> ここでは順番に意味があります。
パッケージを探すとき、Composerは最初から最後までリポジトリを探し、最初に照合したものを拾います。
既定ではPackagistが最後に加えられており、つまり独自のリポジトリがPackagistのパッケージより優先されるのです。</p>
</blockquote>
<p>JSONオブジェクト記法を使うこともできます。
しかしJSONのキーバリュー対は順序なしとして見做されるため、一貫した挙動は保証されません。</p>
<pre><code class="language-json">{
    "repositories": {
        "foo": {
            "type": "composer",
            "url": "http://packages.foo.com"
        }
    }
}
</code></pre>
<h3 id="config-根幹限定"><a class="header" href="#config-根幹限定">config <span>（<a href="doc/04-schema.html#root-package">根幹限定</a>）</span></a></h3>
<p>設定オプションの集合です。プロジェクト限定で使われます。それぞれのオプションについての説明については<a href="doc/06-config.html">設定</a>を参照してください。</p>
<h3 id="scripts-根幹限定"><a class="header" href="#scripts-根幹限定">scripts <span>（<a href="doc/04-schema.html#root-package">根幹限定</a>）</span></a></h3>
<p>Composerではスクリプトの使用を通じてインストールの過程の様々な部分でフックを掛けることができます。</p>
<p>イベントについての詳細と例については<a href="doc/articles/scripts.html">スクリプト</a>を参照してください。</p>
<h3 id="extra"><a class="header" href="#extra">extra</a></h3>
<p><code>scripts</code>によって消費される任意の追加データです。</p>
<p>理論上何でも構いません。
スクリプトのイベント制御子中でアクセスするには以下のようにします。</p>
<pre><code class="language-php">$extra = $event-&gt;getComposer()-&gt;getPackage()-&gt;getExtra();
</code></pre>
<p>省略可能です。</p>
<h3 id="bin"><a class="header" href="#bin">bin</a></h3>
<p>バイナリとして扱われるべきファイルの集合で、（設定の）<code>bin-dir</code>で使えるようにします。</p>
<p>詳細は<a href="doc/articles/vendor-binaries.html">ベンダーバイナリ</a>を参照してください。</p>
<p>省略可能です。</p>
<h3 id="archive-1"><a class="header" href="#archive-1">archive</a></h3>
<p>パッケージアーカイブをつくるためのオプションの集合です。</p>
<p>以下のオプションに対応しています。</p>
<ul>
<li><strong>name:</strong>
アーカイブの基底名を設定できます。既定（設定されていない場合で、かつコマンドライン引数として<code>--file</code>が渡されていない場合）では<code>preg_replace('#[^a-z0-9-_]#i', '-', name)</code>が使われます。</li>
</ul>
<p>例：</p>
<pre><code class="language-json">{
    "name": "org/strangeName",
    "archive": {
        "name": "Strange_name"
    }
}
</code></pre>
<ul>
<li><strong>exclude:</strong> 除外されるパス用のパターンのリストを設定できます。
パターンの構文は.gitignoreファイルのものと同一です。
先頭のびっくりマーク (!) はそれ以前のパターンが除外していたとしても照合したファイルを含めることになります。
先頭のスラッシュはプロジェクトの相対パスの開始部分にのみ照合します。
アスタリスクはディレクトリの区切りに展開されません。</li>
</ul>
<p>例：</p>
<pre><code class="language-json">{
    "archive": {
        "exclude": ["/foo/bar", "baz", "/*.test", "!/foo/bar/baz"]
    }
}
</code></pre>
<p>例では<code>/dir/foo/bar/file</code>、<code>/foo/bar/baz</code>、<code>/file.php</code>、<code>/foo/my.test</code>を含みますが、<code>/foo/bar/any</code>、<code>/foo/baz</code>、<code>/my.test</code>は除外します。</p>
<p>省略可能です。</p>
<h3 id="abandoned"><a class="header" href="#abandoned">abandoned</a></h3>
<p>このパッケージが放棄されたものかどうかを示します。</p>
<p>真偽値または推奨される代替を指すパッケージ名やURLです。</p>
<p>例：</p>
<p><code>"abandoned": true</code>を使うと、このパッケージが放棄されたことを示します。
<code>"abandoned": "monolog/monolog"</code>を使うと、このパッケージが放棄され、推奨される代替が<code>monolog/monolog</code>であることが示されます。</p>
<p>既定では偽です。</p>
<p>省略可能です。</p>
<h3 id="_comment"><a class="header" href="#_comment">_comment</a></h3>
<p>コメントを入れておく場所として使える最上位のキーです（文字列または文字列の配列にできます）。</p>
<pre><code class="language-json">{
    "_comment": [
        "パッケージfoo/barはビジネスロジックに必要でした",
        "foo/barを削除するときはfoo/bazパッケージを削除してください"
    ]
}
</code></pre>
<p>既定では空です。</p>
<p>省略可能です。</p>
<h3 id="non-feature-branches"><a class="header" href="#non-feature-branches">non-feature-branches</a></h3>
<p>数値でないブランチ名の正規表現パターン（例：「latest」など）のリストです。
機能用ブランチを決して扱いません。
文字列の配列です。</p>
<p>数値でないブランチ名がある場合、例えば「latest」「current」「latest-stable」などについては、バージョン番号には見えないので、Composerはそうしたブランチを機能用ブランチとして制御します。
つまりバージョンや特別なブランチ（masterなど）で終わっているような親ブランチを探し、根幹パッケージのバージョン数が親ブランチのバージョンまたは少なくともmasterなどになるということです。</p>
<p>数値でない名前のブランチを、妥当なバージョンやmasterのような特別なブランチ名の親ブランチを探す代わりに、バージョンとして扱うようにするには、開発版ブランチとして制御されるべきブランチ名のパターンを設定できます。</p>
<p>「self.version」を使う依存関係があるときは本当に便利です。
このときdev-masterでなくとも同じブランチがインストールされます（例：latest-testing）。</p>
<p>一例：</p>
<p>テストブランチがある場合で、そのブランチがテストフェーズで手厚く維持管理され、ステージング環境にデプロイされるのであれば、通常<code>composer show -s</code>とすると<code>versions : * dev-master</code>になります。</p>
<p>機能用ブランチではないもの用に<code>latest-.*</code>をパターンとして設定する場合はこのようにします。</p>
<pre><code class="language-json">{
    "non-feature-branches": ["latest-.*"]
}
</code></pre>
<p>それから<code>composer show -s</code>とすると<code>versions : * dev-latest-testing</code>になります。</p>
<p>省略可能です。</p>
<p>← <a href="doc/03-cli.html">コマンドラインインターフェース</a>  | <a href="doc/05-repositories.html">リポジトリ</a> →</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="リポジトリ"><a class="header" href="#リポジトリ">リポジトリ</a></h1>
<p>この章ではパッケージとリポジトリの概念、利用できるリポジトリの種類に何があるか、そしてどういう仕組みになっているのかを解説します。</p>
<h2 id="概念"><a class="header" href="#概念">概念</a></h2>
<p>リポジトリのそれぞれの存在する種別を見ていく前に、Composerが立脚する基礎概念を理解する必要があります。</p>
<h3 id="パッケージ-1"><a class="header" href="#パッケージ-1">パッケージ</a></h3>
<p>Composerは依存関係管理ツールです。
パッケージをローカルにインストールします。
パッケージは本質的には何かを含むディレクトリです。
この場合はその何かがPHPのコードですが、理論上何でも良いわけです。
そしてパッケージの名前とバージョンを持つパッケージの説明を含みます。
名前とバージョンはパッケージを特定するのに使われます。</p>
<p>実際、内部的にはComposerはそれぞれのバージョンを個別のパッケージとして見做します。
この区別はComposerを使っているときは問題になりませんが、Composer自体を変更したいと思ったときはかなり重要になります。</p>
<p>名前とバージョンに加えて有用なメタデータがあります。
インストールに最も関係する情報はソースの定義で、どこかでパッケージの内容を取得するのかを記述します。
パッケージのデータはパッケージの内容を指します。
そしてここで2つの選択肢があります。
distとsourceです。</p>
<p><strong>dist:</strong> distはパッケージデータのパッケージ化されたバージョンです。大抵はリリースバージョンで、中でも大抵は安定リリースです。</p>
<p><strong>source:</strong> ソースは開発に使われます。
大抵gitのようなソースコードリポジトリを起源とします。
ダウンロードされたパッケージを変更したいときはこれを取得できます。</p>
<p>パッケージはこれらの何れか、または両方を与えられます。
利用者により与えられたオプションやパッケージの安定性などの何らかの要因により、どちらかが相応ということになるでしょう。</p>
<h3 id="リポジトリ-1"><a class="header" href="#リポジトリ-1">リポジトリ</a></h3>
<p>リポジトリはパッケージソースで、パッケージとバージョンのリストです。
Composerは全てのリポジトリを見て回り、プロジェクトに必要なパッケージを見付けてきます。</p>
<p>既定ではPackagist.orgリポジトリがComposerに登録されています。<code>composer.json</code>に宣言することでプロジェクトにもっとリポジトリを加えることができます。</p>
<p>リポジトリは根幹パッケージでのみ利用でき、依存関係で定義されたリポジトリは読み込まれません。
なぜそうなっているかを知りたければ<a href="doc/faqs/why-cant-composer-load-repositories-recursively.html">FAQの項目</a>をお読みください。</p>
<p>依存関係解決をするとき、パッケージはリポジトリを上から下への順で見ていき、どこかにパッケージがあったらComposerは他のリポジトリを見るのを止めます。
詳細は<a href="doc/articles/repository-priorities.html">リポジトリの優先度</a>の記事を読んで、この挙動を変える方法を見てください。</p>
<h2 id="種別"><a class="header" href="#種別">種別</a></h2>
<h3 id="composer-1"><a class="header" href="#composer-1">composer</a></h3>
<p>主なリポジトリの種別は<code>composer</code>リポジトリです。全てのパッケージメタデータを含む単一の<code>packages.json</code>ファイルを使っています。</p>
<p>packagistが使っているリポジトリの種別でもあります。
<code>composer</code>リポジトリを参照するには、<code>packages.json</code>ファイルの前にパスを与えてください。
packagistの場合、そのファイルは<code>/packages.json</code>に配置されるので、リポジトリのURLは<code>repo.packagist.org</code>となります。
<code>example.org/packages.json</code>についてはリポジトリのURLは<code>example.org</code>になります。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "composer",
            "url": "https://example.org"
        }
    ]
}
</code></pre>
<h4 id="packages"><a class="header" href="#packages">packages</a></h4>
<p>唯一必要なフィールドは<code>packages</code>です。JSONの構造は以下のようなものです。</p>
<pre><code class="language-json">{
    "packages": {
        "vendor/package-name": {
            "dev-master": { @composer.json },
            "1.0.x-dev": { @composer.json },
            "0.0.1": { @composer.json },
            "1.0.0": { @composer.json }
        }
    }
}
</code></pre>
<p><code>@composer.json</code>の印は、最小のものとして含むパッケージのバージョンに由来する<code>composer.json</code>の内容になります。</p>
<ul>
<li>name</li>
<li>version</li>
<li>distまたはsource</li>
</ul>
<p>以下は最小限のパッケージの定義です。</p>
<pre><code class="language-json">{
    "name": "smarty/smarty",
    "version": "3.1.7",
    "dist": {
        "url": "https://www.smarty.net/files/Smarty-3.1.7.zip",
        "type": "zip"
    }
}
</code></pre>
<p><a href="doc/04-schema.html">スキーマ</a>には指定される他のフィールドの何れかを含められます。</p>
<h4 id="notify-batch"><a class="header" href="#notify-batch">notify-batch</a></h4>
<p><code>notify-batch</code>フィールドでは利用者がパッケージをインストールするときに毎回呼ばれるURLを指定できます。
URLは絶対パス（リポジトリと同じドメイン）ないし完全に修飾されたURLです。</p>
<p>値の一例：</p>
<pre><code class="language-json">{
    "notify-batch": "/downloads/"
}
</code></pre>
<p><code>monolog/monolog</code>パッケージを含む<code>example.org/packages.json</code>について、このようにすると以下のJSON要求本文とともに<code>example.org/downloads/</code>へPOST要求を送ります。</p>
<pre><code class="language-json">{
    "downloads": [
        {"name": "monolog/monolog", "version": "1.2.1.0"}
    ]
}
</code></pre>
<p>バージョンフィールドはバージョン数の正規化された表現を含みます。</p>
<p>このフィールドは省略できます。</p>
<h4 id="metadata-urlavailable-packagesavailable-package-patterns"><a class="header" href="#metadata-urlavailable-packagesavailable-package-patterns">metadata-url、available-packages、available-package-patterns</a></h4>
<p><code>metadata-url</code>フィールドでは、リポジトリにある全てのパッケージを提供するURLテンプレートを与えます。
プレースホルダー<code>%package%</code>を含まなければなりません。</p>
<p>このフィールドはComposer
v2で新しく登場したもので、<code>provider-includes</code>と<code>providers-url</code>が両方とも存在する場合、これらより優先されます。
Composer v1とComposer v2両方の互換性のため、理想的には両方とも提供したいでしょう。
しかし新しいリポジトリの実装はv2対応のみに対応しさえすれば良いです。</p>
<p>一例：</p>
<pre><code class="language-json">{
    "metadata-url": "/p2/%package%.json"
}
</code></pre>
<p>Composerがパッケージを探すときは毎回<code>%package%</code>をパッケージ名で置き換え、そのURLを取得します。開発安定性がそのパッケージについて許容される場合、<code>$packageName~dev</code>で再びURLを読み込むことができます（例：<code>/p2/foo/bar~dev.json</code>は<code>foo/bar</code>の開発版を探します）。</p>
<p>パッケージのバージョンを含む<code>foo/bar.json</code>と<code>foo/bar~dev.json</code>ファイルはfoo/barパッケージのバージョンのみを含まなければなりません。<code>{"packages":{"foo/bar":[……ここにバージョン……]}}</code>のような感じです。</p>
<p>キャッシュはIf-Modified-Sinceヘッダを使うことで行われます。ですから必ずLast-Modifiedヘッダを返して正確な内容であるようにしてください。</p>
<p>バージョンの配列は<a href="https://packagist.org/packages/composer/metadata-minifier">composer/metadata-minifier</a>の<code>Composer\MetadataMinifier\MetadataMinifier::minify()</code>を使って最小化することもできます。
もしそうした場合、最上位に<code>"minified": "composer/2.0"</code>キーを付け、Composerにバージョンのリストを展開して元のデータに戻さなければいけないことを示すべきです。
一例として https://repo.packagist.org/p2/monolog/monolog.json を参照してください。</p>
<p>存在しないパッケージを要求されたら404ステータスコードを返さなければなりません。このステータスコードによりComposerにこのパッケージがリポジトリに存在しないことが示されます。404応答は早く返してComposerがブロックされるのを回避するようにしてください。代替の404ページへのリダイレクトは避けてください。</p>
<p>リポジトリにごく少数のパッケージしかなく、404になる要求を避けたければ<code>packages.json</code>にリポジトリに含まれる全てのパッケージ名が配列になった<code>"available-packages"</code>キーを指定することもできます。代わりにパッケージ名のパターンの配列である<code>"available-package-patterns"</code>キーを指定することもできます（<code>*</code>だと任意の文字列に照合します。例：<code>vendor/*</code>ではComposerはこのリポジトリにある全ての照合したパッケージ名を探します）。</p>
<p>このフィールドは省略できます。</p>
<h4 id="providers-api"><a class="header" href="#providers-api">providers-api</a></h4>
<p><code>providers-api</code>フィールドでは与えられたパッケージ名を提供する全てのパッケージ、ただしその名前のパッケージ以外、を返すURLテンプレートを与えられます。
プレースホルダー<code>%package%</code>を含まなければなりません。</p>
<p>例えば https://packagist.org/providers/monolog/monolog.json はmonolog/monologに
"provide" 規則を持つパッケージを一覧にしますが、monolog/monolog自体は一覧に挙がりません。</p>
<pre><code class="language-json">{
    "providers-api": "https://packagist.org/providers/%package%.json",
}
</code></pre>
<p>このフィールドは省略できます。</p>
<h4 id="list"><a class="header" href="#list">list</a></h4>
<p><code>list</code>フィールドでは与えられたフィールド（もしくはフィルタが存在しなければ全ての名前）に照合するパッケージの名前を返せます。
任意で<code>?filter=xx</code>クエリパラメータを受け付けますが、これには任意の部分文字列に照合するワイルドカードとして<code>*</code>を含められます。</p>
<p>replace/provide規則はここでは考慮すべきではありません。</p>
<p>パッケージ名の配列を返さねばなりません。</p>
<pre><code class="language-json">{
    "packageNames": [
        "a/b",
        "c/d"
    ]
}
</code></pre>
<p>例については<a href="https://packagist.org/packages/list.json?filter=composer/*">https://packagist.org/packages/list.json?filter=composer/*</a>を参照してください。</p>
<p>このフィールドは省略できます。</p>
<h4 id="provider-includesとproviders-url"><a class="header" href="#provider-includesとproviders-url">provider-includesとproviders-url</a></h4>
<p><code>provider-includes</code>フィールドでは、このリポジトリから提供されるパッケージ名を一覧にするファイルの集まりを列挙できます。
この場合ハッシュはファイルのsha256になります。</p>
<p><code>providers-url</code>は提供するファイルをサーバーで見付ける方法を記述します。
リポジトリの根幹からの絶対パスです。
<code>%package%</code>と<code>%hash%</code>のプレースホルダーを含まなければいけません。</p>
<p>これらのフィールドは、Composer v1かリポジトリが<code>metadata-url</code>フィールドを設定していない場合に使われます。</p>
<p>一例：</p>
<pre><code class="language-json">{
    "provider-includes": {
        "providers-a.json": {
            "sha256": "f5b4bc0b354108ef08614e569c1ed01a2782e67641744864a74e788982886f4c"
        },
        "providers-b.json": {
            "sha256": "b38372163fac0573053536f5b8ef11b86f804ea8b016d239e706191203f6efac"
        }
    },
    "providers-url": "/p/%package%$%hash%.json"
}
</code></pre>
<p>これらのファイルにはファイルの完全性を検証するハッシュが含まれます。例えば次の通りです。</p>
<pre><code class="language-json">{
    "providers": {
        "acme/foo": {
            "sha256": "38968de1305c2e17f4de33aea164515bc787c42c7e2d6e25948539a14268bb82"
        },
        "acme/bar": {
            "sha256": "4dd24c930bd6e1103251306d6336ac813b563a220d9ca14f4743c032fb047233"
        }
    }
}
</code></pre>
<p>上のファイルは<code>providers-url</code>で参照されたファイルを読み込むことにより、このリポジトリにacme/fooとacme/barがあることを宣言しています。
ベンダーの名前空間が付いたパッケージ名で<code>%package%</code>を、<code>%hash%</code>をsha256フィールドを、それぞれ置き換えます。
これらのファイル自体には<a href="doc/05-repositories.html#packages">上</a>で前述したパッケージの定義が含まれます。</p>
<p>これらのフィールドは省略可能です。
恐らく独自のリポジトリでは必要ないでしょう。</p>
<h4 id="curlとストリームオプション"><a class="header" href="#curlとストリームオプション">cURLとストリームオプション</a></h4>
<p>リポジトリへはcURL（ext-curlが有効なComposer 2）またはPHPストリームの何れかを使ってアクセスします。
<code>options</code>パラメータを使って追加のオプションを設定できます。
PHPストリームについては、任意の妥当なPHPストリームコンテキストオプションを設定できます。
詳細は<a href="https://php.net/manual/en/context.php">コンテキストオプションとパラメータ</a>を参照してください。
cURLが使われているとき、ごく一部の<code>http</code>と<code>ssl</code>オプションしか設定できないように制限されます。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "composer",
            "url": "https://example.org",
            "options": {
                "http": {
                    "timeout": 60
                }
            }
        }
    ],
    "require": {
        "acme/package": "^1.0"
    }
}
</code></pre>
<h3 id="vcs"><a class="header" href="#vcs">VCS</a></h3>
<p>VCSはバージョンコントロールシステム (Version Control System)
から来ています。これにはgit、svn、fossil、hgのようなバージョニングシステムが含まれます。Composerにはこれらのシステムからパッケージをインストールするリポジトリ種別があります。</p>
<h4 id="vcsリポジトリからパッケージを読み込む"><a class="header" href="#vcsリポジトリからパッケージを読み込む">VCSリポジトリからパッケージを読み込む</a></h4>
<p>これにはいくつかの使い途があります。
一番よくあるものとしては、サードパーティライブラリの独自のフォークを維持管理することです。
プロジェクトで或るライブラリを使用していて、ライブラリ内の何かを変更し、プロジェクトでパッチを適用したバージョンを使用しようと思ったとします。
ライブラリがGitHubにある場合（殆どのライブラリが当てはまります）、フォークして、変更をフォークにプッシュできます。
その後、プロジェクトの<code>composer.json</code>を更新します。
する必要があるのは、フォークをリポジトリとして追加し、バージョン制約を更新してカスタム ブランチを指すようにすることだけです。
<code>composer.json</code> でのみ、カスタムブランチ名の前に<code>"dev-"</code>を付けるべきです（実際のブランチ名の一部にしないでください）。
バージョン制約の命名規則については、<a href="doc/02-libraries.html">ライブラリ</a>を参照してください。</p>
<p><code>bugfix</code>ブランチのバグを修正するためにmonologにパッチを当てたときの例は以下です。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "vcs",
            "url": "https://github.com/igorw/monolog"
        }
    ],
    "require": {
        "monolog/monolog": "dev-bugfix"
    }
}
</code></pre>
<p><code>php composer.phar update</code>を実行すると、修正したバージョンの<code>monolog/monolog</code>が取得されます。packagistからのものではありません。</p>
<p>長期的にフォークするつもりがない限り、パッケージを改名しないでください。
また、もし変更するならするで、元のパッケージから完全に離れたものにする必要があります。
独自リポジトリはpackagistよりも優先されるため、Composerは元のパッケージではなく自前のパッケージを正しく選択します。
パッケージを改名する場合、パッケージ名が既定のブランチから取得されるため、機能ブランチではなく、既定の（多くの場合master）ブランチで行う必要があります。</p>
<p>また、フォークされたリポジトリの<code>composer.json</code>ファイルの<code>name</code>プロパティを変更すると、上書きが機能しないことに注意してください。
上書きが機能するには元のものと合致する必要があるからです。</p>
<p>他の依存関係がフォークしたパッケージに依存している場合は、それをインラインエイリアスして、他の方法では一致しない制約に一致させることができます。
詳細については<a href="doc/articles/aliases.html">エイリアスの記事を参照してください</a>。</p>
<h4 id="私有リポジトリを使う"><a class="header" href="#私有リポジトリを使う">私有リポジトリを使う</a></h4>
<p>GitHubとBitbucketの私有リポジトリを全く同じやり方で扱えます。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "vcs",
            "url":  "git@bitbucket.org:vendor/my-private-repo.git"
        }
    ],
    "require": {
        "vendor/my-private-repo": "dev-master"
    }
}
</code></pre>
<p>唯一の要件は、gitクライアント用のSSHキーがインストールされていることです。</p>
<h4 id="gitの代替案"><a class="header" href="#gitの代替案">Gitの代替案</a></h4>
<p>VCSリポジトリで対応しているバージョン管理システムはGitだけではありません。
以下に対応しています。</p>
<ul>
<li><strong>Git:</strong> <a href="https://git-scm.com">git-scm.com</a></li>
<li><strong>Subversion:</strong> <a href="https://subversion.apache.org">subversion.apache.org</a></li>
<li><strong>Mercurial:</strong> <a href="https://www.mercurial-scm.org">mercurial-scm.org</a></li>
<li><strong>Fossil</strong>: <a href="https://www.fossil-scm.org/">fossil-scm.org</a></li>
</ul>
<p>これらのシステムからパッケージを取得するにはそれぞれのクライアントがインストールされてる必要がありますが、これだと不便かもしれません。
このため、GitHubとBitbucketについては、これらのサイトが提供するAPIを使用して、バージョン管理システムをインストールせずにパッケージを取得する特別な対応が入っています。
VCSリポジトリは、パッケージをzipとして取得する<code>dist</code>を提供します。</p>
<ul>
<li><strong>GitHub:</strong> <a href="https://github.com">github.com</a> (Git)</li>
<li><strong>Bitbucket:</strong> <a href="https://bitbucket.org">bitbucket.org</a> (Git)</li>
</ul>
<p>使用するVCSドライバーは、URLに基づいて自動的に検出されます。
ただし、何らかの理由で指定する必要がある場合は、<code>vcs</code>に代えて<code>bitbucket</code>、<code>github</code>、<code>gitlab</code>、<code>perforce</code>、<code>fossil</code>、<code>git</code>、<code>svn</code>、<code>hg</code>がリポジトリの種類として使えます。</p>
<p>githubリポジトリで<code>no-api</code>キーを<code>true</code>に設定すると、GitHub
APIは使用せず、他のgitリポジトリと同様にリポジトリがクローンされます。
ただし、<code>git</code>ドライバーを直接使用する場合とは異なり、Composerは依然としてgithubのzipファイルを使用しようとします。</p>
<p>以下の点に注意してください。</p>
<ul>
<li><strong>Composerに使用するドライバを選ばせるには</strong>、リポジトリの種類は「vcs」として定義されている必要があります</li>
<li><strong>既に私有リポジトリを使っている場合</strong>、Composerはキャッシュへクローンすることになります。
同じパッケージをドライバと一緒にインストールしたい場合、<code>composer clearcache</code>コマンドに続けて<code>composer update</code>とすることでComposerのキャッシュを消去しdistからパッケージをインストールさせられることを覚えておきましょう</li>
<li>VCSドライバ<code>git-bitbucket</code>は<code>bitbucket</code>に取って代わられたため時代遅れです</li>
</ul>
<h4 id="bitbucketドライバ設定"><a class="header" href="#bitbucketドライバ設定">Bitbucketドライバ設定</a></h4>
<blockquote>
<p><strong>Bitbucketのリポジトリのエンドポイントはgitではなくhttpsになっている必要がある点に注意してください。</strong></p>
</blockquote>
<p>bitbucketリポジトリが準備できたら<a href="doc/articles/authentication-for-private-packages.html#bitbucket-oauth">認証の準備</a>もする必要があるでしょう。</p>
<h4 id="subversionのオプション"><a class="header" href="#subversionのオプション">Subversionのオプション</a></h4>
<p>Subversion自体にはブランチとタグの概念がないため、Composerは既定でコードが<code>$url/trunk</code>、<code>$url/branches</code>、<code>$url/tags</code>にあるという前提を置きます。
リポジトリの配置が異なる場合は、それらの値を変更できます。
たとえば、大文字の名前を使用した場合、次のようにリポジトリを構成できます。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "vcs",
            "url": "http://svn.example.org/projectA/",
            "trunk-path": "Trunk",
            "branches-path": "Branches",
            "tags-path": "Tags"
        }
    ]
}
</code></pre>
<p>ブランチのディレクトリもタグのディレクトリもなければ<code>branches-path</code>ないし<code>tags-path</code>を<code>false</code>に設定することで完全に無効にできます。</p>
<p>パッケージが副ディレクトリにある、例えば<code>/trunk/foo/bar/composer.json</code>と<code>/tags/1.0/foo/bar/composer.json</code>にあるなら、<code>"package-path"</code>オプションを副ディレクトリに設定することでComposerがアクセスできるようにさせられます。
この例では<code>"package-path": "foo/bar/"</code>となるでしょう。</p>
<p>私有Subversionリポジトリがあるなら設定のhttp-basic節に資格情報を保存しておけます（<a href="doc/04-schema.html">スキーマ</a>を参照）。</p>
<pre><code class="language-json">{
    "http-basic": {
        "svn.example.org": {
            "username": "username",
            "password": "password"
        }
    }
}
</code></pre>
<p>Subversionクライアントが既定で資格情報を保存するように構成されている場合、これらの資格情報は現在の利用者用に保存され、このサーバー用に保存されている既存の資格情報は上書きされます。
この挙動を変更するには、次のようにリポジトリ構成で<code>"svn-cache-credentials"</code>オプションを設定します。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "vcs",
            "url": "http://svn.example.org/projectA/",
            "svn-cache-credentials": false
        }
    ]
}
</code></pre>
<h3 id="パッケージ-2"><a class="header" href="#パッケージ-2">パッケージ</a></h3>
<p>上記のどの方法でもComposerに対応していないプロジェクトを使いたい場合でも、<code>package</code>リポジトリを使って自分でパッケージを定義できます。</p>
<p>基本的に<code>composer</code>リポジトリの<code>package.json</code>に含まれるのと同じ情報を定義しますが、単一のパッケージ用限定です。
繰り返しますが、最小限必要なフィールドは<code>name</code>、<code>version</code>、そして<code>dist</code>または<code>source</code>の何れかです。</p>
<p>以下はsmartyテンプレートエンジンの例です。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "package",
            "package": {
                "name": "smarty/smarty",
                "version": "3.1.7",
                "dist": {
                    "url": "https://www.smarty.net/files/Smarty-3.1.7.zip",
                    "type": "zip"
                },
                "source": {
                    "url": "http://smarty-php.googlecode.com/svn/",
                    "type": "svn",
                    "reference": "tags/Smarty_3_1_7/distribution/"
                },
                "autoload": {
                    "classmap": ["libs/"]
                }
            }
        }
    ],
    "require": {
        "smarty/smarty": "3.1.*"
    }
}
</code></pre>
<p>source部分は放置しておくのが普通です。本当に必要なことはまずないからです。</p>
<p>sourceキーが含まれているとき、referenceフィールドはインストールされるバージョンへの参照となります。
typeフィールドが<code>git</code>のとき、このフィールドはコミットIDやブランチやタグ名になります。</p>
<blockquote>
<p><strong>補足：</strong>
referenceフィールドにGitのブランチ名を使うことはお勧めしません。
<code>git checkout</code>に対応しているため妥当ではあるのですが、ブランチ名は可変なので固定できないのです。</p>
</blockquote>
<p>フィールドが<code>svn</code>のとき、referenceフィールドには<code>svn co</code>を走らせるときに後ろに付ける参照が含まれます。</p>
<blockquote>
<p><strong>補足</strong>：
このリポジトリ種別には2、3の制約があり、できる限り避けるべきです。</p>
<ul>
<li>Composerは<code>version</code>フィールドを変えない限りパッケージを更新しません。</li>
<li>Composerはコミット参照を更新しません。
そのため、参照として<code>master</code>を使う場合、強制的に更新するためにパッケージを削除し、不安定な固定ファイルに対処しなければならなくなるでしょう。</li>
</ul>
</blockquote>
<p><code>package</code>リポジトリ中の<code>"package"</code>キーには複数バージョンのパッケージを定義する配列を設定できます。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "package",
            "package": [
                {
                    "name": "foo/bar",
                    "version": "1.0.0",
                    ...
                },
                {
                    "name": "foo/bar",
                    "version": "2.0.0",
                    ...
                }
            ]
        }
    ]
}
</code></pre>
<h2 id="自分でホスティングする"><a class="header" href="#自分でホスティングする">自分でホスティングする</a></h2>
<p>多分殆どの場合でパッケージをpackagistに置きたいものと思われますが、自分のリポジトリをホスティングすることによる用途もあります。</p>
<ul>
<li>
<p><strong>企業の私有パッケージ：</strong>
内部的なパッケージ用にComposerを使っている企業に所属しているなら、それらのパッケージを私有としておきたいかもしれません。</p>
</li>
<li>
<p><strong>別のエコシステム:</strong>
独自のエコシステムを持つプロジェクトがあり、より大きなPHPコミュニティからそのパッケージを実際に再利用できない場合は、packagistから分離させておきたいかもしれません。
一例はWordPressプラグインです。</p>
</li>
</ul>
<p>自分のパッケージをホスティングするには、ネイティブな<code>composer</code>の種類のリポジトリが推奨されます。
一番の効率性が齎されるからです。</p>
<p><code>composer</code>リポジトリを作る上で、手助けになるツールはいくつかあります。</p>
<h3 id="私有packagist"><a class="header" href="#私有packagist">私有Packagist</a></h3>
<p><a href="https://packagist.com/">私有Packagist</a>ではGitHub、Packagist.org、その他のパッケージリポジトリのミラーリングと共に私有パッケージのホスティングを提供するアプリケーションです。
Packagistでも立てられていますが、自分で立てることもできます。</p>
<p>詳細は<a href="https://packagist.com/">Packagist.com</a>をご確認ください。</p>
<h3 id="satis"><a class="header" href="#satis">Satis</a></h3>
<p>Satisは静的な<code>composer</code>リポジトリ生成器です。
packagistを超軽量にして、静的なファイルを基盤にしたバージョンのようなものです。</p>
<p>Satisにはリポジトリを含む<code>composer.json</code>を与えます。
リポジトリとしてよくあるのはVCSやパッケージレポジトリの定義です。
<code>require</code>されるパッケージを全て取得し、<code>packages.json</code>を吐き出しますが、これが<code>composer</code>リポジトリになります。</p>
<p>詳細は<a href="https://github.com/composer/satis">satisのGitHubリポジトリ</a>と<a href="doc/articles/handling-private-packages.html">プライベートパッケージを扱うことについての記事</a>をご確認ください。</p>
<h3 id="アーティファクト"><a class="header" href="#アーティファクト">アーティファクト</a></h3>
<p>前述のどのリポジトリの種類もオンラインにできない場合があります。
VCSが使われていたとしても例外ではありません。
よくある例は、ビルドアーティファクトによる組織間のライブラリ交換です。
もちろん殆どの場合で、これらは私有とされます。
これらのアーカイブをそのまま使用するには、これらの私有パッケージのZIPまたはTARアーカイブを含むフォルダーに対して、種別<code>artifact</code>のリポジトリを使用できます。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "artifact",
            "url": "path/to/directory/with/zips/"
        }
    ],
    "require": {
        "private-vendor-one/core": "15.6.2",
        "private-vendor-two/connectivity": "*",
        "acme-corp/parser": "10.3.5"
    }
}
</code></pre>
<p>それぞれのzipアーティファクトとは、根幹のフォルダにある<code>composer.json</code>があるZIPアーカイブです。</p>
<pre><code class="language-shell">unzip -l acme-corp-parser-10.3.5.zip
</code></pre>
<pre><code class="language-text">composer.json
...
</code></pre>
<p>パッケージのバージョンが異なる2つのアーカイブがある場合、両方ともインポートされます。
新しいバージョンのアーカイブがアーティファクトフォルダーに追加された状態で<code>update</code>を実行すると、そのバージョンもインポートされ、Composerは最新版に更新されます。</p>
<h3 id="パス"><a class="header" href="#パス">パス</a></h3>
<p>アーティファクトリポジトリに加えて、絶対パスまたは相対パスのローカルディレクトリに依存するパスを使用できます。
モノリシックリポジトリを扱う場合に特に役立ちます。</p>
<p>例えばリポジトリが以下のディレクトリ構造になっているとします。</p>
<pre><code class="language-text">...
├── apps
│   └── my-app
│       └── composer.json
├── packages
│   └── my-package
│       └── composer.json
...
</code></pre>
<p>そうして依存関係として<code>apps/my-app/composer.json</code>ファイルにパッケージ<code>my/package</code>を加えるには、以下の構成が使えます。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "path",
            "url": "../../packages/my-package"
        }
    ],
    "require": {
        "my/package": "*"
    }
}
</code></pre>
<p>パッケージがローカルのVCSリポジトリである場合、バージョンは現在チェックアウトされているブランチまたはタグによって推測されます。
それ以外の場合は、パッケージの<code>composer.json</code>ファイルでバージョンを明示的に定義すべきです。
これらの方法でバージョンが解決できない場合は、<code>dev-master</code>と見なされます。</p>
<p>バージョンがローカルのVCSリポジトリから推測できない場合、もしくはそのバージョンを上書きしたい場合は、リポジトリの宣言時に<code>versions</code>オプションが使えます。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "path",
            "url": "../../packages/my-package",
            "options": {
                "versions": {
                    "my/package": "4.2-dev"
                }
            }
        }
    ]
}
</code></pre>
<p>可能なときはローカルパッケージがシンボリックリンクされます。
この場合端末の出力は<code>Symlinking from ../../packages/my-package</code>となります。
シンボリックリンクでき<em>ない</em>場合はパッケージが複製されます。
その場合端末の出力は<code>Mirrored from ../../packages/my-package</code>となります。</p>
<p>既定のフォールバック戦略に代えて、<code>"symlink": true</code>としてシンボリックリンクにしたり、<code>"symlink": false</code>オプションでミラーリングしたりすることを強制できます。
ミラーリングを強制すると、モノリシックレポジトリからパッケージをデプロイしたり生成したりする際に便利なことがあります。</p>
<blockquote>
<p><strong>補足：</strong> Windowsでは管理者でない利用者によって作成される可能性があるため、NTFSジャンクションを使ってディレクトリのシンボリックリンクが実装されています。
Windows 7より前のバージョンまたは<code>proc_open</code>が無効にされている場合は常にミラーリングが使用されます。</p>
</blockquote>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "path",
            "url": "../../packages/*",
            "options": {
                "symlink": false
            }
        }
    ]
}
</code></pre>
<p>チルダを先頭に付けると現在の利用者のホームフォルダに展開され、環境変数はWIndowsとLinux/Macの両方の記法で解析されます。
例えば<code>~/git/mypackage</code>は自動的に<code>/home/&lt;利用者名&gt;/git/mypackage</code>からクローンしたmypackageを読み込みます。
<code>$HOME/git/mypackage</code>としたり<code>%USERPROFILE%/git/mypackage</code>としても同じことです。</p>
<blockquote>
<p><strong>補足：</strong> リポジトリのパスは<code>*</code>や<code>?</code>のようなワイルドカードも含められます。
詳細については<a href="https://php.net/glob">PHPのglob関数</a>を参照してください。</p>
</blockquote>
<p>（composer.lockファイルに現れる）パッケージのdistへの参照が構築される方法を構成できます。</p>
<p>以下のモードが存在します。</p>
<ul>
<li><code>none</code>：参照は常に空です。
これにより固定ファイル間の競合を低減する助けになる可能性がありますが、直近に更新があるとパッケージが最新の状態になっているかが比較的不明瞭になります。</li>
<li><code>config</code>：参照はパッケージのcomposer.jsonとリポジトリの設定のハッシュに基づいて構築されます</li>
<li><code>auto</code>（既定で使用されます）：参照は<code>comfig</code>のようなハッシュに基づいて構築されます。
ただしパッケージフォルダがgitリポジトリを含んでいる場合、代わりにHEADコミットのハッシュが参照として使われます。</li>
</ul>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "path",
            "url": "../../packages/*",
            "options": {
                "reference": "config"
            }
        }
    ]
}
</code></pre>
<h2 id="packagistorgを無効にする"><a class="header" href="#packagistorgを無効にする">Packagist.orgを無効にする</a></h2>
<p>以下を<code>composer.json</code>に加えると既定のPackagist.orgリポジトリを無効にできます。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "packagist.org": false
        }
    ]
}
</code></pre>
<p>大域的な構成フラグを使うことで、大域的にPackagist.orgを無効にできます。</p>
<pre><code class="language-shell">php composer.phar config -g repo.packagist false
</code></pre>
<p>← <a href="doc/04-schema.html">スキーマ</a>  | <a href="doc/06-config.html">設定</a> →</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="構成"><a class="header" href="#構成">構成</a></h1>
<p>本章では<code>composer.json</code>の<a href="doc/04-schema.html">スキーマ</a>の<code>config</code>節について記述していきます。</p>
<h2 id="process-timeout"><a class="header" href="#process-timeout">process-timeout</a></h2>
<p>プロセス実行の制限時間で、秒単位です。
既定では300（5分）です。
<code>git clone</code>のような時間の掛かるプロセスは、Composerによりプロセスの異常終了が推定されるまで、実行できます。
接続が遅い場合やベンダーが大きい場合は、これを増やす必要があるかもしれません。</p>
<p>例：</p>
<pre><code class="language-json">{
    "config": {
        "process-timeout": 900
    }
}
</code></pre>
<h3 id="個々のスクリプトのコマンドで制限時間を無効にする"><a class="header" href="#個々のスクリプトのコマンドで制限時間を無効にする">個々のスクリプトのコマンドで制限時間を無効にする</a></h3>
<p><code>scripts</code>以下の独自コマンドでプロセスの制限時間を無効にするには、静的ヘルパーが使えます。</p>
<pre><code class="language-json">{
    "scripts": {
        "test": [
            "Composer\\Config::disableProcessTimeout",
            "phpunit"
        ]
    }
}
</code></pre>
<h2 id="allow-plugins"><a class="header" href="#allow-plugins">allow-plugins</a></h2>
<p>既定は<code>{}</code>で、1つもプラグインを読み込むことはできません。</p>
<p>Composer
2.2.0では、<code>allow-plugins</code>オプションによってセキュリティの層が追加され、Composerの実行中にどのComposerプラグインがコードを実行できるかを制限できるようになりました。</p>
<p>新しいプラグインが最初に活性化され、それが構成オプションにまだ挙げられていなければ、Composerは警告を印字します。
Composerを対話的に実行すると、プラグインを実行するかどうかを決めるようプロンプトを出します。</p>
<p>この設定を使うと、信頼できるパッケージのみがコードを実行できるようになります。
パッケージ名パターンをキーに持つオブジェクトに設定します。
値は、許可する場合は<strong>true</strong>で、許可しない場合は<strong>false</strong>です。
何れもこれ以外の警告とプロンプトは抑制されます。</p>
<pre><code class="language-json">{
    "config": {
        "allow-plugins": {
            "third-party/required-plugin": true,
            "my-organization/*": true,
            "unnecessary/plugin": false
        }
    }
}
</code></pre>
<p>構成オプション自体を<code>false</code>にして全てのプラグインを拒否したり、<code>true</code>にして全てのプロラグインが走るのを許可したり（全くお勧めしません）するようにも設定できます。
例えば以下の通りです。</p>
<pre><code class="language-json">{
    "config": {
        "allow-plugins": false
    }
}
</code></pre>
<h2 id="use-include-path"><a class="header" href="#use-include-path">use-include-path</a></h2>
<p>既定では<code>false</code>です。
<code>true</code>にすると、Composerの自動読み込み器はPHPのインクルードパスにあるクラスも探します。</p>
<h2 id="preferred-install"><a class="header" href="#preferred-install">preferred-install</a></h2>
<p>既定では<code>dist</code>で、<code>source</code>、<code>dist</code>、<code>auto</code>の何れかです。
このオプションではComposerが優先して使うインストール方法を設定できます。
お好みで、より柔軟なインストール設定のためにキーにパッケージ名のパターンがあるオブジェクトにすることもできます。</p>
<pre><code class="language-json">{
    "config": {
        "preferred-install": {
            "my-organization/stable-package": "dist",
            "my-organization/*": "source",
            "partner-organization/*": "auto",
            "*": "dist"
        }
    }
}
</code></pre>
<ul>
<li><code>source</code>は、Composerが（存在する場合）<code>source</code>からパッケージをインストールすることを意味します。
通常、git cloneまたは同等のパッケージが使用するバージョン管理システムのチェックアウトです。
プロジェクトにバグ修正を行い、依存関係のローカルgitクローンを直接取得する場合に便利です。</li>
<li><code>auto</code>は遺物的な動作です。
開発バージョンの場合にComposerは<code>source</code>を自動的に使用し、それ以外の場合は<code>dist</code>を使用します。</li>
<li><code>dist</code>（Composer 2.1以降で既定）は、可能であればComposerが<code>dist</code>からインストールすることを意味します。
通常、zipファイルのダウンロードであり、リポジトリ全体のクローンよりも高速です。</li>
</ul>
<blockquote>
<p><strong>補足：</strong> 順番は重要です。
より限定されたパターンは、より緩いパターンの前に来るべきです。
大域構成やパッケージ構成で文字列表記とハッシュ構成を混在させると、文字列表記は<code>*</code>パッケージパターンに解釈されます。</p>
</blockquote>
<h2 id="audit-1"><a class="header" href="#audit-1">audit</a></h2>
<p>セキュリティ監査の構成オプション</p>
<h3 id="ignore"><a class="header" href="#ignore">ignore</a></h3>
<p>勧告の識別子、リモートの識別子、CVEの識別子のリストです。
報告はされますが監査コマンドは通過させます。</p>
<pre><code class="language-json">{
    "config": {
        "audit": {
            "ignore": {
                "CVE-1234": "The affected component is not in use.",
                "GHSA-xx": "The security fix was applied as a patch.",
                "PKSA-yy": "Due to mitigations in place the update can be delayed."
            }
        }
    }
}
</code></pre>
<p>もしくは以下です。</p>
<pre><code class="language-json">{
    "config": {
        "audit": {
            "ignore": ["CVE-1234", "GHSA-xx", "PKSA-yy"]
        }
    }
}
</code></pre>
<h3 id="abandoned-1"><a class="header" href="#abandoned-1">abandoned</a></h3>
<p>Composer 2.6では<code>report</code>が既定値であり、Composer 2.7以降では<code>fail</code>が既定値です。
監査コマンドが放棄されたパッケージを報告するかどうかを定義するもので、3つの値を取り得ます。</p>
<ul>
<li><code>ignore</code>は、監査コマンドが放棄されたパッケージを全く考慮しないという意味です。</li>
<li><code>report</code>は、放棄されたパッケージが失敗として報告されるものの、非ゼロコードでコマンドが終了してしまわないようにする意味です。</li>
<li><code>fail</code>は、放棄されたパッケージにより監査が非ゼロコードで失敗するようになる意味です。</li>
</ul>
<pre><code class="language-json">{
    "config": {
        "audit": {
            "abandoned": "report"
        }
    }
}
</code></pre>
<p>Composer
2.7以降、<a href="doc/03-cli.html#composer-audit-abandoned"><code>COMPOSER_AUDIT_ABANDONED</code></a>環境変数を介して、オプションをオーバーライドできます。</p>
<p>Composer
2.8以降、<a href="doc/03-cli.html#audit"><code>--abandoned</code></a>コマンドラインオプションを介して、オプションをオーバーライドできます。
このオプションにより、構成値と環境変数が共にオーバーライドされます。</p>
<h2 id="use-parent-dir"><a class="header" href="#use-parent-dir">use-parent-dir</a></h2>
<p>composer.jsonがないディレクトリでComposerを実行しており、その上のディレクトリにcomposer.jsonがある場合、Composerは既定で、そのディレクトリのcomposer.jsonを代わりに使用するかどうかを尋ねます。</p>
<p>このプロンプトに対して常に「はい」と答えたい場合は、この構成値を<code>true</code>に設定できます。
プロンプトが表示されないようにするには、<code>false</code>に設定します。
既定は<code>"prompt"</code>です。</p>
<blockquote>
<p><strong>補足：</strong> この構成を機能させるには、大域的な利用者全体の構成で設定しなければなりません。
例えば<code>php composer.phar config --global use-parent-dir true</code>を使用して設定します。</p>
</blockquote>
<h2 id="store-auths"><a class="header" href="#store-auths">store-auths</a></h2>
<p>認証のプロンプトの後にする動作です。
<code>true</code>（常に保存する）、<code>false</code>（保存しない）、<code>"prompt"</code>（毎回確認する）の何れか1つで、既定では<code>"prompt"</code>です。</p>
<h2 id="github-protocols"><a class="header" href="#github-protocols">github-protocols</a></h2>
<p>既定では<code>["https", "ssh", "git"]</code>です。
github.comからクローンを作成するときに使用するプロトコルのリストで、優先度順に並べます。
既定では<code>git</code>が存在しますが、gitプロトコルは暗号化されていないため、<a href="doc/06-config.html#secure-http">secure-http</a>が無効になっている場合のみ使われます。
originのリモートプッシュURLでssh (<code>git@github.com:...</code>)
ではなくhttpsを使用する場合、プロトコルリストを<code>["https"]</code>のみに設定すると、ComposerはプッシュURLをSSHのURLに上書きすることを取り止めます。</p>
<h2 id="github-oauth"><a class="header" href="#github-oauth">github-oauth</a></h2>
<p>ドメイン名とoauthキーのリストです。
たとえば、このオプションの値として<code>{"github.com": "oauthtoken"}</code>を使用すると、<code>oauthtoken</code>を使用してgithubの私有リポジトリにアクセスし、APIのIPに基づく低いレート制限を回避します。
Composerは、必要に応じて資格情報を要求する場合がありますが、これらは手動で設定することもできます。
GitHubのOAuthトークンを取得する方法及びcliの構文の詳細については、<a href="doc/articles/authentication-for-private-packages.html#github-oauth">こちら</a>を参照してください。</p>
<h2 id="gitlab-domains"><a class="header" href="#gitlab-domains">gitlab-domains</a></h2>
<p>既定では<code>["gitlab.com"]</code>です。
GitLabサーバーのドメインのリストです。
<code>gitlab</code>リポジトリ種別を使う場合に使用されます。</p>
<h2 id="gitlab-oauth"><a class="header" href="#gitlab-oauth">gitlab-oauth</a></h2>
<p>ドメイン名とoauthキーのリストです。
たとえば、このオプションの値として<code>{"gitlab.com": "oauthtoken"}</code>を使用すると、<code>oauthtoken</code>を使用してgitlabの私有リポジトリにアクセスします。
なお、パッケージがgitlab.comでホストされていない場合、ドメイン名も<a href="doc/06-config.html#gitlab-domains"><code>gitlab-domains</code></a>オプションで指定する必要があります。
詳細情報は<a href="doc/articles/authentication-for-private-packages.html#gitlab-oauth">こちら</a>にもあります。</p>
<h2 id="gitlab-token"><a class="header" href="#gitlab-token">gitlab-token</a></h2>
<p>ドメイン名と私有トークンのリストです。
私有トークンは、単純な文字列、または利用者名とトークンを含む配列の何れかです。
たとえば、このオプションの値として<code>{"gitlab.com": "privatetoken"}</code>を使用すると、<code>privatetoken</code>を使用してgitlabの私有リポジトリにアクセスします。
<code>{"gitlab.com": {"username": "gitlabuser", "token": "privatetoken"}}</code>を使用すると、利用者名とトークンの両方を使ってgitlabのデプロイトークン機能 (https://docs.gitlab.com/ ee/user/project/deploy_tokens/) を使用します。
なお、パッケージがgitlab.comでホストされていない場合、ドメイン名も<a href="doc/06-config.html#gitlab-domains"><code>gitlab-domains</code></a>オプションで指定する必要があります。
トークンには<code>api</code>または<code>read_api</code>スコープが必要です。
詳細情報は<a href="doc/articles/authentication-for-private-packages.html#gitlab-token">こちら</a>にもあります。</p>
<h2 id="gitlab-protocol"><a class="header" href="#gitlab-protocol">gitlab-protocol</a></h2>
<p>パッケージメタデータの<code>source</code>値用にリポジトリのURLを作成するときに、強制的に使用するプロトコルです。
<code>git</code>または<code>http</code>の何れかです（<code>https</code>は<code>http</code>の同義語として扱われます）。
HTTPベーシック認証を使った<a href="https://docs.gitlab.com/ee/ci/variables/predefined_variables.html#predefined-variables-reference">GitLabのCI_JOB_TOKEN</a>により、後々GitLab
CIのジョブでクローンされる私有リポジトリを参照するプロジェクトを扱う際に役立ちます。
既定では、Composerは私有リポジトリについてはgit-over-SSHのURLを生成し、公開リポジトリについてはHTTP(S)のみを生成します。</p>
<h2 id="disable-tls"><a class="header" href="#disable-tls">disable-tls</a></h2>
<p>既定は<code>false</code>です。
真に設定すると、すべてのHTTPSのURLが代わりにHTTPで試行され、ネットワークレベルの暗号化は実行されません。
これを有効にすることはセキュリティ上の危険性であり、全く推奨されません。
より良い方法は、php.iniでphp_openssl拡張機能を有効にすることです。
これを有効にすると、<code>secure-http</code>オプションが暗黙に無効になります。</p>
<h2 id="secure-http"><a class="header" href="#secure-http">secure-http</a></h2>
<p>既定では<code>true</code>です。
真に設定すると、HTTPSのURLのみがComposer経由でダウンロードできるようになります。
何かしらへのHTTPアクセスが絶対に必要な場合は無効にできますが、<a href="https://letsencrypt.org/">Let's
Encrypt</a>を使用して無料のSSL証明書を取得する方が一般的にはより良い代替手段です。</p>
<h2 id="bitbucket-oauth"><a class="header" href="#bitbucket-oauth">bitbucket-oauth</a></h2>
<p>ドメイン名と消費者のリストです。
例えば<code>{"bitbucket.org": {"consumer-key": "myKey", "consumer-secret": "mySecret"}}</code>のように使います。
より詳しくは<a href="doc/articles/authentication-for-private-packages.html#bitbucket-oauth">こちら</a>を読んでください。</p>
<h2 id="cafile"><a class="header" href="#cafile">cafile</a></h2>
<p>ローカルファイルシステム上の認証局ファイルの配置場所です。
PHP 5.6以降ではシステムCAファイルを自動的に検出できますが、PHP
5.6以降でも、php.iniのopenssl.cafileを介してこれを設定すべきです。</p>
<h2 id="capath"><a class="header" href="#capath">capath</a></h2>
<p>cafileが指定されていない場合、またはそこに証明書がない場合は、capathが指すディレクトリで適切な証明書が探索されます。
capathは正しくハッシュされた証明書ディレクトリでなければなりません。</p>
<h2 id="http-basic"><a class="header" href="#http-basic">http-basic</a></h2>
<p>認証するためのドメイン名と、利用者名とパスワードのリストです。
たとえば、このオプションの値として<code>{"example.org": {"username": "alice", "password": "foo"}}</code>を使用すると、Composerはexample.orgに対して認証します。
詳細については、<a href="doc/articles/authentication-for-private-packages.html#http-basic">こちら</a>を参照してください。</p>
<h2 id="bearer"><a class="header" href="#bearer">bearer</a></h2>
<p>認証するドメイン名とトークンのリストです。
たとえば、このオプションの値として<code>{"example.org": "foo"}</code>を使用すると、Composerは<code>Authorization: Bearer foo</code>ヘッダーを使用して、example.orgに対して認証を行うことができます。</p>
<h2 id="platform"><a class="header" href="#platform">platform</a></h2>
<p>プラットフォームパッケージ（PHP及び拡張機能）を偽装して、運用環境をエミュレートしたり、構成で対象のプラットフォームを定義したりできるようにします。
例えば<code>{"php": "7.0.3", "ext-something": "4.0.3"}</code>です。</p>
<p>これにより、ローカルで実行する実際のPHPバージョンに関係なく、PHP 7.0.3以上を必要とするパッケージをインストールできなくなります。
ただし、依存関係が正しく検査されなくなったことも意味します。
PHP 5.6を実行すると、7.0.3を想定しているため問題なくインストールされますが、実行時に失敗します。
これは、<code>{"php":"7.4"}</code>が指定されることも意味します。
<code>7.4.1</code>を最小のバージョンとして定義するパッケージは使用されません。</p>
<p>したがって、これを使用する場合は、デプロイ戦略の一部として<a href="doc/03-cli.html#check-platform-reqs"><code>check-platform-reqs</code></a>コマンドも走らせることをお勧めしますし、より安全です。</p>
<p>ローカルにインストールしていない拡張機能が依存関係に必要な場合は、代わりに<code>--ignore-platform-req=ext-foo</code>を<code>update</code>、<code>install</code>、または<code>require</code>に渡して無視できます。
しかし長い目で見れば、今は無視するにせよ必要な拡張はインストールすべきで、1箇月後に新しいパッケージでも必要になると、知らず知らずのうちに本番環境に問題が発生する可能性があります。</p>
<p>拡張をローカルにインストールしているが本番環境では<em>そうではない</em>場合、<code>{"ext-foo": false}</code>を使ってComposerから意図的に隠すこともできます。</p>
<h2 id="vendor-dir"><a class="header" href="#vendor-dir">vendor-dir</a></h2>
<p>既定は<code>vendor</code>です。
お好みで違うディレクトリに依存関係をインストールできます。
vendor-dirと以下の全ての<code>*-dir</code>オプション中では、<code>$HOME</code>と<code>~</code>はホームディレクトリに置換されます。</p>
<h2 id="bin-dir"><a class="header" href="#bin-dir">bin-dir</a></h2>
<p>既定では<code>vendor/bin</code>です。
プロジェクトがバイナリを含む場合、それらのバイナリはこのディレクトリにシンボリックリンクが張られます。</p>
<h2 id="data-dir"><a class="header" href="#data-dir">data-dir</a></h2>
<p>既定では、Windowsでは<code>C:\Users\&lt;user&gt;\AppData\Roaming\Composer</code>、XDG Base Directory Specificationsに従うunixシステムでは<code>$XDG_DATA_HOME/composer</code>、その他のunixシステムでは<code>$COMPOSER_HOME</code>です。
現在、過去のcomposer.pharファイルを保存して古いバージョンにロールバックできるようにするためにのみ使用されています。
<a href="doc/03-cli.html#composer-home">COMPOSER_HOME</a>も参照してください。</p>
<h2 id="cache-dir"><a class="header" href="#cache-dir">cache-dir</a></h2>
<p>既定では、Windowsでは<code>C:\Users\&lt;user&gt;\AppData\Local\Composer</code>、macOSでは<code>/Users/&lt;user&gt;/Library/Caches/composer</code>、XDG Base Directory Specificationに従うunixシステムでは<code>$XDG_CACHE_HOME/composer</code>、他のunixシステムでは<code>$COMPOSER_HOME/cache</code>になります。
Composerで使う全てのキャッシュが保管されます。
<a href="doc/03-cli.html#composer-home">COMPOSER_HOME</a>も参照してください。</p>
<h2 id="cache-files-dir"><a class="header" href="#cache-files-dir">cache-files-dir</a></h2>
<p>既定では<code>$cache-dir/files</code>です。
パッケージのzipアーカイブを保管します。</p>
<h2 id="cache-repo-dir"><a class="header" href="#cache-repo-dir">cache-repo-dir</a></h2>
<p>既定では<code>$cache-dir/repo</code>です。
<code>composer</code>の種別用のリポジトリのメタデータと、<code>svn</code>、<code>fossil</code>、<code>github</code>、<code>gitbucket</code>の種別のVCSリポジトリを保管します。</p>
<h2 id="cache-vcs-dir"><a class="header" href="#cache-vcs-dir">cache-vcs-dir</a></h2>
<p>既定では<code>$cache-dir/vcs</code>です。
<code>git</code>及び<code>hg</code>の種別用のVCSリポジトリメタデータを読み込むためのVCSクローンを保管し、インストールを高速にします。</p>
<h2 id="cache-files-ttl"><a class="header" href="#cache-files-ttl">cache-files-ttl</a></h2>
<p>既定では<code>15552000</code>（6箇月）です。
Composerはダウンロードした全てのdist（zip、tar、……）をキャッシュします。
既定では使われていないものについて6箇月経った後に削除します。
このオプションはこの期間を（秒数で）調整ないし0に設定することで、完全に無効にできるようにするものです。</p>
<h2 id="cache-files-maxsize"><a class="header" href="#cache-files-maxsize">cache-files-maxsize</a></h2>
<p>既定では<code>300MiB</code>です。
Composerはダウンロードした全ての配布パッケージ（zip、tar、……）をキャッシュします。
ガベージコレクションが定期的に走っている場合、キャッシュで使える最大量です。
最後のキャッシュヒットから時間が経った（比較的使われていない）ファイルが削除されます。</p>
<h2 id="cache-read-only"><a class="header" href="#cache-read-only">cache-read-only</a></h2>
<p>既定では<code>false</code>です。
Composerのキャッシュを読取専用モードで使うかどうかを決めます。</p>
<h2 id="bin-compat"><a class="header" href="#bin-compat">bin-compat</a></h2>
<p>既定では<code>auto</code>です。
インストールするバイナリの互換性を決定します。
<code>auto</code>の場合、Composerは、WindowsまたはWSLの場合に.batプロキシファイルのみをインストールします。
<code>full</code>に設定すると、Windows用の.batファイルとUnixベースのオペレーティングシステム用のスクリプトの両方がバイナリごとにインストールされます。
主にLinux VM内でComposerを実行しているが、WindowsホストOSで使用できる<code>.bat</code>プロキシが必要な場合に役立ちます。
<code>proxy</code>に設定すると、ComposerはbashでUnixスタイルのプロキシファイルのみを作成し、WindowsないしWSLでも.batファイルを作成しません。</p>
<h2 id="prepend-autoloader"><a class="header" href="#prepend-autoloader">prepend-autoloader</a></h2>
<p>既定は<code>true</code>です。
<code>false</code>にするとComposerの自動読み込み器は既存の自動読み込み器の前に置かれなくなります。
他の自動読み込み器との相互運用性の問題を修正する際に必要になることがあります。</p>
<h2 id="autoloader-suffix"><a class="header" href="#autoloader-suffix">autoloader-suffix</a></h2>
<p>既定では<code>null</code>です。
空でない文字列に設定した場合、生成されたComposerの自動読み込み器の接尾辞に使われます。
<code>null</code>に設定された場合、可能であれば<code>composer.lock</code>ファイルの<code>content-hash</code>値が使われます。
そうでなければ、乱択された接尾辞が生成されます。</p>
<h2 id="optimize-autoloader"><a class="header" href="#optimize-autoloader">optimize-autoloader</a></h2>
<p>既定では<code>false</code>です。
<code>true</code>の場合、自動読み込み器を吐き出す際に常に最適化されます。</p>
<h2 id="sort-packages"><a class="header" href="#sort-packages">sort-packages</a></h2>
<p>既定では<code>false</code>です。
<code>true</code>の場合、新しいパッケージを追加したときに<code>composer.json</code>中の<code>require</code>コマンドでパッケージが名前順に整列された状態に保たれます。</p>
<h2 id="classmap-authoritative"><a class="header" href="#classmap-authoritative">classmap-authoritative</a></h2>
<p>既定では<code>false</code>です。
<code>true</code>にするとComposerの自動読み込み器はクラスマップからのクラスのみを読み込みます。
暗に<code>optimize-autoloader</code>を有効にします。</p>
<h2 id="apcu-autoloader"><a class="header" href="#apcu-autoloader">apcu-autoloader</a></h2>
<p>既定では<code>false</code>です。
<code>true</code>の場合、Composerの自動読み込み器はAPCuを確認し、拡張が有効になった場合にクラスの有無をキャッシュするのに使います。</p>
<h2 id="github-domains"><a class="header" href="#github-domains">github-domains</a></h2>
<p>既定では<code>["github.com"]</code>です。
githubモードで使われるドメインのリストです。
GitHub Enterpriseの準備で使われます。</p>
<h2 id="github-expose-hostname"><a class="header" href="#github-expose-hostname">github-expose-hostname</a></h2>
<p>既定では<code>true</code>です。
<code>false</code>にするとgithub APIにアクセスするために作られるOAuthトークンがマシンのホスト名ではなく日付になります。</p>
<h2 id="use-github-api"><a class="header" href="#use-github-api">use-github-api</a></h2>
<p>既定では<code>true</code>です。
特定のリポジトリに於ける<code>no-api</code>キーに似ており、<code>use-github-api</code>を<code>false</code>に設定すると、他のgitリポジトリのように、全てのGitHubリポジトリについて、GitHub
APIを使う代わりにリポジトリをクローンするように大域的な挙動を定義します。
しかし<code>git</code>ドライバを直接使うのではなく、ComposerはやはりGitHubのzipファイルを使うことを試みます。</p>
<h2 id="notify-on-install"><a class="header" href="#notify-on-install">notify-on-install</a></h2>
<p>既定では<code>true</code>です。
Composerではリポジトリが通知のURLを定義できるようにしており、そのリポジトリからパッケージがインストールされたことの通知を受けられます。
このオプションはその挙動を無効にできます。</p>
<h2 id="discard-changes"><a class="header" href="#discard-changes">discard-changes</a></h2>
<p>既定では<code>false</code>で、<code>true</code>、<code>false</code>、または<code>stash</code>の何れかにできます。
このオプションでは非対話モードでダーティアップデートを制御する既定の方式を設定できます。
<code>true</code>はベンダーの変更を常に破棄しますが、<code>"stash"</code>は取っておいて再適用しようとします。
よくベンダーを変更する場合は、CIサーバーやデプロイスクリプトにこれを使ってください。</p>
<h2 id="archive-format"><a class="header" href="#archive-format">archive-format</a></h2>
<p>既定では<code>tar</code>です。
archiveコマンドにより使われる既定の形式を上書きします。</p>
<h2 id="archive-dir"><a class="header" href="#archive-dir">archive-dir</a></h2>
<p>既定では<code>.</code>です。
archiveコマンドによる作られる、アーカイブの既定の対象パスです。</p>
<p>例：</p>
<pre><code class="language-json">{
    "config": {
        "archive-dir": "/home/user/.composer/repo"
    }
}
</code></pre>
<h2 id="htaccess-protect"><a class="header" href="#htaccess-protect">htaccess-protect</a></h2>
<p>既定では<code>true</code>です。
<code>false</code>に設定すると、ComposerはComposerのホーム、キャッシュ、データディレクトリに<code>.htaccess</code>ファイルを作りません。</p>
<h2 id="lock"><a class="header" href="#lock">lock</a></h2>
<p>既定では<code>true</code>です。
<code>false</code>に設定すると、Composerは<code>composer.lock</code>ファイルを作らず、存在している場合は無視します。</p>
<h2 id="platform-check"><a class="header" href="#platform-check">platform-check</a></h2>
<p>既定では、PHPのバージョンのみをチェックする<code>php-only</code>に設定されています。
拡張子の存在も確認するには、<code>true</code>に設定します。
<code>false</code>に設定すると、Composerは自動読み込み器のブートストラップの一部として<code>platform_check.php</code>ファイルを作成せず、requireもしません。</p>
<h2 id="secure-svn-domains"><a class="header" href="#secure-svn-domains">secure-svn-domains</a></h2>
<p>既定では<code>[]</code>です。
安全なSubversionまたはSVNの移送を使用しているものとして信頼し、印を付けるべきドメインの一覧です。
既定では、svn://プロトコルは安全ではないと見なされ、throwされますが、この構成オプションを<code>["example.org"]</code>に設定すれば、そのホスト名でsvnのURLを使用できます。
<code>secure-http</code>を完全に無効にするよりも優れた安全な代替手段です。</p>
<h2 id="bump-after-update"><a class="header" href="#bump-after-update">bump-after-update</a></h2>
<p>既定は<code>false</code>で、<code>true</code>、<code>false</code>、<code>"dev"</code>、<code>"no-dev"</code>のどれかにできます。
真に設定すると、Composerは<code>update</code>コマンドを走らせた後に、<code>bump</code>コマンドを走らせます。
<code>"dev"</code>や<code>"no-dev"</code>に設定すると、対応する依存関係のみのバージョンが上がります。</p>
<h2 id="allow-missing-requirements"><a class="header" href="#allow-missing-requirements">allow-missing-requirements</a></h2>
<p>既定は<code>false</code>です。
要件から何か欠けているものがあるとき、<code>install</code>時にエラーを無視します。
状況としては、<code>composer.json</code>にある最新の変更点に対して、固定ファイルが最新でないときです。</p>
<p>← <a href="doc/05-repositories.html">リポジトリ</a>  | <a href="doc/07-runtime.html">実行時</a> →</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="実行時composerユーティリティ"><a class="header" href="#実行時composerユーティリティ">実行時Composerユーティリティ</a></h1>
<p>Composerはほぼプロジェクトに依存関係をインストールするのに使われますが、実行時に使える機能もいくつかあります。</p>
<p>特定のバージョンに於けるこれらの機能のどれかに依る必要があれば、<code>composer-runtime-api</code>パッケージをrequireできます。</p>
<h2 id="自動読み込み-1"><a class="header" href="#自動読み込み-1">自動読み込み</a></h2>
<p>自動読み込み器は最も使われるものであり、既に<a href="doc/01-basic-usage.html#autoloading">基本的な使い方の手引き</a>で押さえられています。
全てのComposerのバージョンで使えます。</p>
<h2 id="インストールされたバージョン"><a class="header" href="#インストールされたバージョン">インストールされたバージョン</a></h2>
<p>composer-runtime-api
2.0では、現在インストールされているバージョンを調べるための静的メソッドを提供する新しい<code>Composer\InstalledVersions</code>クラスが導入されました。
Composerの自動読み込み器が含まれている限り、コードで自動的に使用できます。</p>
<p>このクラスの主な用例は以下の通りです。</p>
<h3 id="パッケージxあるいは仮想パッケージが存在するか見る"><a class="header" href="#パッケージxあるいは仮想パッケージが存在するか見る">パッケージX（あるいは仮想パッケージ）が存在するか見る</a></h3>
<pre><code class="language-php">\Composer\InstalledVersions::isInstalled('vendor/package'); // 真偽値を返す
\Composer\InstalledVersions::isInstalled('psr/log-implementation'); // 真偽値を返す
</code></pre>
<p>Composer 2.1から、2つ目の引数に偽を渡すことによりrequire-devを介してインストールされたかを確認することもできます。</p>
<pre><code class="language-php">\Composer\InstalledVersions::isInstalled('vendor/package'); // このパッケージがインストールされていれば真を返す
\Composer\InstalledVersions::isInstalled('vendor/package', false); // vendor/packageがrequireにあれば真を、require-devにあれば偽を返す
</code></pre>
<p>なお、プラットフォームパッケージがインストールされているかどうかを確認するのには使えません。</p>
<h3 id="パッケージxのバージョンyがインストールされているかどうかを見る"><a class="header" href="#パッケージxのバージョンyがインストールされているかどうかを見る">パッケージXのバージョンYがインストールされているかどうかを見る</a></h3>
<blockquote>
<p><strong>補足：</strong> これを使うためには<code>"composer/semver": "^3.0"</code>をrequireしなければなりません。</p>
</blockquote>
<pre><code class="language-php">use Composer\Semver\VersionParser;

\Composer\InstalledVersions::satisfies(new VersionParser, 'vendor/package', '2.0.*');
\Composer\InstalledVersions::satisfies(new VersionParser, 'psr/log-implementation', '^1.0');
</code></pre>
<p>例えば、vendor/packageについて、<code>2.0.*</code>に適合するバージョンでインストールされている場合だけでなく、与えられたパッケージ名が何らかの他のパッケージにより置き換えられていたり与えられていたりする場合にも真を返します。</p>
<h3 id="パッケージのバージョンを見る"><a class="header" href="#パッケージのバージョンを見る">パッケージのバージョンを見る</a></h3>
<blockquote>
<p><strong>補足：</strong>
求めるパッケージ名自体はインストールされていないものの、他のパッケージから与えられていたり置き換えられていたりする場合は<code>null</code>を返します。
したがって少なくともライブラリのコードでは、satisfies()を使うことをお勧めします。
アプリケーションのコードではもう少し制御できるため、あまり重要ではありません。</p>
</blockquote>
<pre><code class="language-php">// vendor/packageがインストールされている場合、正規化されたバージョン（例：1.2.3.0）が返ります。
// パッケージが提供されたり置き換えられたりしたものであればnullを返します。
// パッケージが全くインストールされていなければOutOfBoundsExceptionを投げます。
\Composer\InstalledVersions::getVersion('vendor/package');
</code></pre>
<pre><code class="language-php">// vendor/packageがインストールされていれば元のバージョン（例：v1.2.3）を返します。
// 提供されたり置き換えられたりしたものであればnullを返します。
// パッケージが全くインストールされていなければOutOfBoundsExceptionを投げます。
\Composer\InstalledVersions::getPrettyVersion('vendor/package');
</code></pre>
<pre><code class="language-php">// vendor/packageがインストールされていれば、パッケージのdistまたはsourceの参照（例：gitのコミットハッシュ）を返します。
// 提供されたり置き換えられたりしたものであればnullを返します。
// そのパッケージが全くインストールされていなければOutOfBoundsExceptionを投げます。
\Composer\InstalledVersions::getReference('vendor/package');
</code></pre>
<h3 id="パッケージ自体のインストールされたバージョンを見る"><a class="header" href="#パッケージ自体のインストールされたバージョンを見る">パッケージ自体のインストールされたバージョンを見る</a></h3>
<p>パッケージ自体のバージョンを取得することにのみ関心がある場合、getVersion/getPrettyVersion/getReferenceで充分でしょう。
例えばacme/fooのソースで、現在実行中のacme/fooのバージョンがどれかを利用者に表示したい場合などです。</p>
<p>上の節の警告はこの場合には適用されません。
なぜならコードが走っている場合はパッケージは存在しており置き換えられてもいないからです。</p>
<p>とはいうものの、できる限りの安全性のために<code>null</code>の返り値まで心を配って制御することは良い考えです。</p>
<hr />
<p>より複雑な用例については他の方法がいくつか利用できます。
<a href="https://github.com/composer/composer/blob/main/src/Composer/InstalledVersions.php">クラス自体</a>のソースやドキュメント部分を参照してください。</p>
<h3 id="パッケージがインストールされているパスを見る"><a class="header" href="#パッケージがインストールされているパスを見る">パッケージがインストールされているパスを見る</a></h3>
<p><code>getInstallPath</code>メソッドはパッケージがインストールされている絶対パスを取得します。</p>
<blockquote>
<p><strong>補足：</strong> パスは絶対的ではありますが、<code>../</code>やシンボリックリンクは含まれることがあります。
<code>realpath()</code>と等価なものであるという保証はないので、問題に挙がる状況ではrealpathを走らせるべきです。</p>
</blockquote>
<pre><code class="language-php">// vendor/packageがインストールされていればパッケージのインストール場所への絶対パスを返します。
// 提供されていたり置き換えられていたり、あるいはパッケージがメタパッケージの場合はnullを返します。
// そのパッケージが全くインストールされていなければOutOfBoundsExceptionを投げます。
\Composer\InstalledVersions::getInstallPath('vendor/package');
</code></pre>
<blockquote>
<p>Composer 2.1から使えます（つまり<code>composer-runtime-api ^2.1</code>です）</p>
</blockquote>
<h3 id="与えられた種類でどのパッケージがインストールされているのかを見る"><a class="header" href="#与えられた種類でどのパッケージがインストールされているのかを見る">与えられた種類でどのパッケージがインストールされているのかを見る</a></h3>
<p><code>getInstalledPackagesByType</code>メソッドはパッケージの種類（例：foo-plugin）を受け入れ、インストールされているその種類のパッケージを一覧にします。
その後、上記のメソッドを使用して、必要に応じて各パッケージに関する詳細情報を取得できます。</p>
<p>この方法により、プラグインをベンダーディレクトリに残すのではなく、特定のパスに配置するカスタムインストーラーの必要性が軽減されます。
それからInstalledVersionsを介して実行時に初期化するプラグインを見付け、必要に応じてgetInstallPathを介してそれらのパスを含めることができます。</p>
<pre><code class="language-php">\Composer\InstalledVersions::getInstalledPackagesByType('foo-plugin');
</code></pre>
<blockquote>
<p>Composer 2.1から使えます（つまり<code>composer-runtime-api ^2.1</code>です）</p>
</blockquote>
<h2 id="プラットフォームの検査"><a class="header" href="#プラットフォームの検査">プラットフォームの検査</a></h2>
<p>composer-runtime-api
2.0では新しい<code>vendor/composer/platform_check.php</code>ファイルが導入されました。
Composerの自動読み込み器を含めた際に、自動的に含まれます。</p>
<p>プラットフォーム要件（つまり、php及びphp拡張機能）が現在実行中のPHPプロセスで満たされていることを確認します。
要件が満たされていない場合、スクリプトは不足している要件に関する警告を出力し、コード104で終了します。</p>
<p>実稼働環境で予期せず失敗した際のPHP拡張機能の曖昧な警告が表示される空白ページを回避するには、デプロイやビルドの工程の一部として<code>composer check-platform-reqs</code>を実行し、0以外のコードが返された場合に中止すると良いでしょう。</p>
<p>既定値は<code>php-only</code>であり、PHPのバージョンのみを検査します。</p>
<p>何らかの理由でこの安全性の検査を使いたくなく、コードが実行されるときの実行時の失敗の惧れを許容する場合は、<a href="doc/06-config.html#platform-check"><code>platform-check</code></a>構成オプションを<code>false</code>に設定することで無効にできます。</p>
<p>検査にPHP拡張機能が存在することの検証を含めたい場合は、configオプションを<code>true</code>に設定します。
その後、<code>ext-*</code>の要件が検証されますが、効率上の理由から、Composerは拡張機能の存在のみをチェックし、その正確なバージョンは検査しません。</p>
<p><code>lib-*</code>の要件は、プラットフォーム検査機能では全く対応されておらず、検査もされません。</p>
<h2 id="バイナリの自動読み込みパス"><a class="header" href="#バイナリの自動読み込みパス">バイナリの自動読み込みパス</a></h2>
<p>composer-runtime-api
2.2では、Composerでインストールされたバイナリを実行するときに設定される<code>$_composer_autoload_path</code>大域変数が新しく導入されました。
詳細については、<a href="doc/articles/vendor-binaries.html#finding-the-composer-autoloader-from-a-binary">ベンダーバイナリドキュメント</a>を参照してください。</p>
<p>バイナリプロキシによって設定されるので、Composerの<code>vendor/autoload.php</code>ではプロジェクトに使うことはできません。
このファイルはそれ自体を指すように戻ってしまうので、役に立たないのです。</p>
<h2 id="バイナリパス-bin-dir"><a class="header" href="#バイナリパス-bin-dir">バイナリパス (bin-dir)</a></h2>
<p>composer-runtime-api 2.2.2では、新しい<code>$_composer_bin_dir</code>大域変数が導入されました。
Composerでインストールされたバイナリを使った際に設定されます。
これについての詳細は<a href="doc/articles/vendor-binaries.html#finding-the-composer-bin-dir-from-a-binary">ベンダーバイナリのドキュメント</a>をお読みください。</p>
<p>バイナリプロキシによって設定されるため、Composerの<code>vendor/autoload.php</code>によるプロジェクトでは利用できません。</p>
<p>← <a href="doc/06-config.html">構成</a>  | <a href="doc/08-community.html">コミュニティ</a> →</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="コミュニティ-1"><a class="header" href="#コミュニティ-1">コミュニティ</a></h1>
<p>既に多くの人々がcomposerを使い、少なくない方々が貢献しています。</p>
<h2 id="貢献"><a class="header" href="#貢献">貢献</a></h2>
<p>Composerに貢献したいときは、<a href="https://github.com/composer/composer">README</a>と<a href="https://github.com/composer/composer/blob/main/.github/CONTRIBUTING.md">CONTRIBUTING</a>のドキュメントを読んでください。</p>
<p>最重要の指針は以下に記述されます。</p>
<blockquote>
<p>全てのコードの貢献は、コミット権限をもつ人を含めて、プルリクエストを通じて行われます。
マージ前に中核開発者による承認がなされなければなりません。
これは全てのコードに適切なレビューを確実に行うためです。</p>
<p>プロジェクトをフォークし、機能ブランチを作成し、そしてプルリクエストを送ってください。</p>
<p>一貫性のあるコードベースにするためにコードが<a href="https://www.php-fig.org/psr/psr-12/">PSR-12コーディング規約</a>に従っていることを確認すべきです。</p>
</blockquote>
<h3 id="翻訳"><a class="header" href="#翻訳">翻訳</a></h3>
<p>日本語訳の改善を歓迎します。
<code>translations/po/ja.po</code>に原文と翻訳の対応があり、このファイルから日本語用のMarkdownファイル<code>translations/ja/**/*.md</code>が生成されます。
したがって後者のMarkdownファイルではなく、前者のGettext POファイルを編集してください。</p>
<p>翻訳は<a href="https://po4a.org/">po4a</a>で管理されています。
<code>npm run translate</code>とするとPOファイルの更新とMarkdownファイルの生成が行われます。
また、<code>package.json</code>には<code>test:ja</code>と<code>test:md</code>のnpm scriptsが定義されています。
<code>test:ja</code>は<a href="https://textlint.github.io/">Textlint</a>により日本語を検査し、<code>test:md</code>は<a href="https://github.com/igorshubovych/markdownlint-cli/">markdownlint</a>によりMarkdownの構文を検査します。</p>
<h2 id="サポート"><a class="header" href="#サポート">サポート</a></h2>
<p>IRCチャンネルは&lt;irc.libera.chat&gt;の
<a href="ircs://irc.libera.chat:6697/composer">#composer</a> にあります。</p>
<p><a href="https://stackoverflow.com/questions/tagged/composer-php">Stack Overflow</a> と
<a href="https://github.com/composer/composer/discussions">GitHub Discussions</a>
には両方ともComposerに関係する質問が寄せられています。</p>
<p>有料のサポートについては、Composerに関係するサポートを<a href="https://packagist.com">Private
Packagist</a>の顧客にチャットとEメールを介して提供しています。</p>
<p>← <a href="doc/07-runtime.html">ランタイム</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="composerをプログラムでインストールする方法"><a class="header" href="#composerをプログラムでインストールする方法">Composerをプログラムでインストールする方法</a></h1>
<p>ダウンロードページに附記したように、インストーラースクリプトにはチェックサムが含まれており、このチェックサムはインストーラのコードにより変化します。
そのため長い目で見るとこの値に依るべきではありません。</p>
<p>代替案はこのスクリプトを使うことです。
UNIXのユーティリティがあってのみ動作します。</p>
<pre><code class="language-shell">#!/bin/sh

EXPECTED_CHECKSUM="$(php -r 'copy("https://composer.github.io/installer.sig", "php://stdout");')"
php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
ACTUAL_CHECKSUM="$(php -r "echo hash_file('sha384', 'composer-setup.php');")"

if [ "$EXPECTED_CHECKSUM" != "$ACTUAL_CHECKSUM" ]
then
    &gt;&amp;2 echo 'ERROR: Invalid installer checksum'
    rm composer-setup.php
    exit 1
fi

php composer-setup.php --quiet
RESULT=$?
rm composer-setup.php
exit $RESULT
</code></pre>
<p>スクリプトは失敗した場合に1で、成功した場合に0で、それぞれ終了します。
また、何らエラーが起きなければ何も出ません。</p>
<p>別案として、そっくりそのままのインストーラーに頼りたければ、GitHubの履歴から特定のバージョンを取得できます。
GitHubのサーバーを信用できる限りにおいて、コミットハッシュは一意性と認証性を与えるに充分でしょう。
例えば以下です。</p>
<pre><code class="language-shell">wget https://raw.githubusercontent.com/composer/getcomposer.org/f3108f64b4e1c1ce6eb462b159956461592b3e3e/web/installer -O - -q | php -- --quiet
</code></pre>
<p>コミットハッシュは https://github.com/composer/getcomposer.org/commits/main
にある何かしら最新のコミットハッシュで置き換えると良いでしょう。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="何故比較とワイルドカードが組み合わさったバージョン制約が良くないのか"><a class="header" href="#何故比較とワイルドカードが組み合わさったバージョン制約が良くないのか">何故、比較とワイルドカードが組み合わさったバージョン制約が良くないのか</a></h1>
<p><code>&gt;=2.*</code>や<code>&gt;=1.1*</code>のようなパッケージの要件でバージョン制約を定義することは、それなりによく見られる誤りです。</p>
<p>ただし本当に意味しているところを考えれば直ちに意味を成さないことに気付かれるでしょう。
<code>&gt;=2.*</code>を分解すると2つに分けられます。</p>
<ul>
<li><code>&gt;=2</code>はパッケージがバージョン2.0.0以上であるべきだとしています。</li>
<li><code>2.*</code>は、パッケージがバージョン2.0.0（このバージョンを含む）と3.0.0（このバージョンを含まない）の間にあるべきだとしています。</li>
</ul>
<p>見ての通り、両方の規則ではパッケージが2.0.0以上でなければならないという事実について合意されています。
しかし、それを書いた時にバージョン3.0.0のパッケージのことを考えていたかについては判定できないのです。
<code>&gt;=2</code>を求めたので照合すべきでしょうか。
それとも<code>2.*</code>を求めたので照合しないべきでしょうか。</p>
<p>こうした理由からComposerはエラーを投げて不当であるとします。
修正するには本当に意味しているところについて考え、これらの規則のうち1つだけを使うことです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="プロキシを隔ててcomposerを使う方法"><a class="header" href="#プロキシを隔ててcomposerを使う方法">プロキシを隔ててComposerを使う方法</a></h1>
<p>Composerは他の多くのツールと同様、環境変数を使ってプロキシサーバーの使用を制御します。
以下に対応しています。</p>
<ul>
<li><code>http_proxy</code> - HTTP要求を使うプロキシ</li>
<li><code>https_proxy</code> - HTTPS要求を使うプロキシ</li>
<li><code>CGI_HTTP_PROXY</code> - HTTP要求をCLIの文脈ではないところで使うプロキシ</li>
<li><code>no_proxy</code> - プロキシを必要としないドメイン</li>
</ul>
<p>これらの名前付き変数は慣習によるもので、公式の標準があるわけではありません。
また異なるオペレーティングシステムやツールに亙る進展や用法については複雑なものとなっています。
Composerでは小文字の名前が望ましいものの、適当な場合には大文字の名前も受け付けます。</p>
<h2 id="使い方-1"><a class="header" href="#使い方-1">使い方</a></h2>
<p>ComposerはHTTPとHTTPSの要求に関して所定の環境変数を必要とします。
例えば以下です。</p>
<pre><code>http_proxy=http://proxy.com:80
https_proxy=http://proxy.com:80
</code></pre>
<p>大文字の名前も使えます。</p>
<h3 id="cliでない使い方"><a class="header" href="#cliでない使い方">CLIでない使い方</a></h3>
<p>ComposerはCLIでない文脈では<code>http_proxy</code>や<code>HTTP_PROXY</code>を探しません。
このような方法で走らせている場合（例えばCMSや似たような用途に統合しているなど）、HTTP要求用に<code>CGI_HTTP_PROXY</code>を使わなければなりません。</p>
<pre><code>CGI_HTTP_PROXY=http://proxy.com:80
https_proxy=http://proxy.com:80

# cgi_http_proxyも使えます
</code></pre>
<blockquote>
<p><strong>補足：</strong>
CGI_HTTP_PROXYは、要求ヘッダの操作を防ぐため、2001年にPerlで導入されました。
この脆弱性が広く報告された2016年に一般に認知されました。
https://httpoxy.org を参照してください。</p>
</blockquote>
<h2 id="構文"><a class="header" href="#構文">構文</a></h2>
<p>上の例にある通り、<code>scheme://host:port</code>を使ってください。
スキームが欠けているとhttpが既定になり、ポートが欠けているとhttpやhttpsのスキーム用に80や443の既定になりますが、その他のツールではこれらの値が必要になることがあります。</p>
<p>IPv4用のドットで4つに区切られた記法を使ったIPアドレスとしても、IPv6用に角括弧で囲まれた記法でも、ホストを指定できます。</p>
<h3 id="認証"><a class="header" href="#認証">認証</a></h3>
<p>Composerは<code>scheme://user:pass@host:port</code>構文を使ったBasic認証に対応しています。
利用者名ないしパスワード中の予約されたURLの文字はパーセント符号化されていなければなりません。
例えば以下です。</p>
<pre><code>利用者：me@company
パスワード：p@ssw$rd
プロキシ：http://proxy.com:80

# パーセント符号化された認証
me%40company:p%40ssw%24rd

scheme://me%40company:p%40ssw%24rd@proxy.com:80
</code></pre>
<blockquote>
<p><strong>補足：</strong>
利用者名とパスワードの構成要素は個々にパーセント符号化され、それからコロンの区切り文字で連結しなければなりません。
利用者名には（パーセント符号化されたとしても）コロンを含められません。
なぜならプロキシは最初に見付けたコロンで構成要素を分割するからです。</p>
</blockquote>
<h2 id="httpsのプロキシサーバー"><a class="header" href="#httpsのプロキシサーバー">HTTPSのプロキシサーバー</a></h2>
<p>ComposerはHTTPSのプロキシサーバーに対応しています。
ここでのHTTPSはプロキシに接続されるために使われるスキームですが、PHP 7.3以降かつcurlのバージョン7.52.0以降のみです。</p>
<pre><code>http_proxy=https://proxy.com:443
https_proxy=https://proxy.com:443
</code></pre>
<h2 id="特定のドメインでプロキシを迂回する"><a class="header" href="#特定のドメインでプロキシを迂回する">特定のドメインでプロキシを迂回する</a></h2>
<p><code>no_proxy</code>（または<code>NO_PROXY</code>）を使うと、プロキシが使われるべき「でない」ドメインのコンマ区切りリストが設定されます。</p>
<pre><code>no_proxy=example.com
# example.comとそのサブドメインについてはプロキシを迂回します。

no_proxy=www.example.com
# www.example.comとそのサブドメインについてはプロキシを迂回します。
# example.comについては迂回されません。
</code></pre>
<p>ドメインは特定のポート（例えば<code>:80</code>）に制限できます。
またIPアドレスやCIDRの記法でIPアドレスのブロックとして指定することもできます。</p>
<p>IPv6アドレスはhttp_proxy/https_proxyの値と同様、角括弧で囲む必要はありません。
ただしこの形式は受け付けられます。</p>
<p>値を<code>*</code>に設定すると全ての要求に対するプロキシを迂回します。</p>
<blockquote>
<p><strong>補足：</strong>
ドメインの先頭のドットには意味がありません。
処理される前に取り除かれます。</p>
</blockquote>
<h2 id="廃止された環境変数"><a class="header" href="#廃止された環境変数">廃止された環境変数</a></h2>
<p>Composerは元々<code>HTTP_PROXY_REQUEST_FULLURI</code>及び<code>HTTPS_PROXY_REQUEST_FULLURI</code>を提供してプロキシの良くない挙動を緩和しようとしていました。
これらは必要ではなくなり、使われることもありません。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    tagline: バージョンについての説明です。
-->
<h1 id="パッケージと制約"><a class="header" href="#パッケージと制約">パッケージと制約</a></h1>
<h2 id="composerのバージョンとvcsのバージョン"><a class="header" href="#composerのバージョンとvcsのバージョン">ComposerのバージョンとVCSのバージョン</a></h2>
<p>Composerはgitのような版管理システムを活用する方向に大きく舵を切っているため、「バージョン」という用語は少し曖昧です。
版管理システムの意味では、「バージョン」は特定のデータを含む特定のファイルの集まりです。
gitの用語法では、これは「ref」もしくは特定のコミットのことです。
これはブランチのHEADやタグで表されることがあります。
あるバージョン……例えばタグ<code>v1.1</code>やコミット<code>e35fa0d</code>……がVCSにあることを確認するには、単一の既知のファイルの集まりが欲しいものであり、常に同じファイルが取り寄せられます。</p>
<p>Composerで何気なくバージョンとしてよく指すもの……つまり要件の行でパッケージ名に続く文字列（例えば<code>~1.1</code>や<code>1.2.*</code>）……とは実のところ、より具体的にはバージョン制約です。
Composerはバージョン制約を使い、VCSからチェックアウトすべきrefを調べます（もしくは、<code>composer.json</code>中の<code>version</code>指定で静的に維持されたライブラリのときは、与えられたライブラリが許容されるか検証します）。</p>
<h2 id="vcsのタグとブランチ"><a class="header" href="#vcsのタグとブランチ">VCSのタグとブランチ</a></h2>
<p><em>以下の説明では、以下のライブラリリポジトリ例があるとします。</em></p>
<pre><code class="language-shell">~/my-library$ git branch
</code></pre>
<pre><code class="language-text">v1
v2
my-feature
another-feature
</code></pre>
<pre><code class="language-shell">~/my-library$ git tag
</code></pre>
<pre><code class="language-text">v1.0
v1.0.1
v1.0.2
v1.1-BETA
v1.1-RC1
v1.1-RC2
v1.1
v1.1.1
v2.0-BETA
v2.0-RC1
v2.0
v2.0.1
v2.0.2
</code></pre>
<h3 id="タグ"><a class="header" href="#タグ">タグ</a></h3>
<p>通常Composerはタグを扱います（ブランチではありません。
意味するところが分からなければ、<a href="https://en.wikipedia.org/wiki/Version_control#Common_terminology">版管理システム</a>をご一読ください）。
バージョン制約を書くとき、特定のタグ（例えば<code>1.1</code>）を参照することや、有効なタグの範囲（例えば<code>&gt;=1.1 &lt;2.0</code>や<code>~4.0</code>）を参照することがあります。
こうした制約を解決するため、ComposerはまずVCSに全ての利用できるタグを挙げるよう頼みます。
それからこれらのタグに基づいて利用できるバージョンの内部的な一覧を作ります。
上の例では、composerの内部リストにはバージョン<code>1.0</code>、<code>1.0.1</code>、<code>1.0.2</code>、<code>1.1</code>のベータリリース、<code>1.1</code>の1つ目と2つ目のリリース候補、<code>1.1</code>の最終リリースバージョンなどが含まれます（なおComposerは最終的に有効なバージョン番号を得るため、自動的に実際のタグ名から<code>v</code>接頭辞を除きます）。</p>
<p>ComposerにVCSで利用できるバージョンの完全な一覧ができたら、プロジェクトの全てのバージョン制約に合致する最も大きいバージョンを探します（他のパッケージが自分で指定したものよりそのライブラリのバージョンをより限定されたものを要件とすることがあります。
そのため選ばれるバージョンは入手できるバージョンのうち最大のものであるとは限りません）。
またそのタグのzipアーカイブをダウンロードして<code>vendor</code>ディレクトリの正しい場所に開封します。</p>
<h3 id="ブランチ"><a class="header" href="#ブランチ">ブランチ</a></h3>
<p>タグではなくブランチをチェックアウトしたいときは、特別な<code>dev-*</code>接頭辞（接尾辞のときもあります。後述）を使ってブランチを指す必要があります。
ブランチをチェックアウトすると、ブランチで<em>作業</em>したいと仮定し、実際にリポジトリを<code>vendor</code>ディレクトリの正しい場所にクローンします。
タグについては、実際にはリポジトリをクローンせず、正しいファイルを複製します（--prefer-sourceや--prefer-distでこの挙動を変えられます。
<a href="doc/articles/../03-cli.html#install">インストールオプション</a>を参照してください）。</p>
<p>上の例では<code>my-feature</code>ブランチをチェックアウトしたいため、<code>require</code>節のバージョン制約として<code>dev-my-feature</code>を指定することになります。
こうすると<code>my-liberay</code>リポジトリが<code>vendor</code>ディレクトリにクローンされ、<code>my-feature</code>ブランチがチェックアウトされます。</p>
<p>ブランチ名がバージョンのように見えるとき、タグではなくブランチをチェックアウトしようとしていることをはっきりしなければなりません。
上の例では2つのバージョンブランチ<code>v1</code>と<code>v2</code>があります。
これらのブランチをチェックアウトするには<code>v1.x-dev</code>のようにバージョン制約を指定しなければなりません。
<code>.x</code>は任意の文字列で、<code>v1</code>タグではなく<code>v1</code>ブランチについて書いていることをComposerに伝えます（代替としてブランチに<code>v1</code>ではなく<code>v1.x</code>と名前を付けられます）。
この場合のバージョンのような名前（この場合は<code>v1</code>）を持つブランチでは、<code>dev-</code>を接頭辞として使うのではなく、接尾辞として<code>-dev</code>を付けます。</p>
<h3 id="安定性"><a class="header" href="#安定性">安定性</a></h3>
<p>Composerは次の安定性を（この順で）認識します。
すなわちdev、alpha、beta、RC、stableです。
ここでRCはリリース候補 (release candidate) を表します。
バージョンの安定性は接尾辞で定義されます。
例えばバージョン<code>v1.1-BETA</code>には<code>beta</code>の安定性があり、<code>v1.1-RC1</code>には<code>RC</code>の安定性があります。
そのような接尾辞がないときは、バージョンが<code>stable</code>だと見做します。
例えば<code>v1.1</code>です。
これに加えて全ての番号のブランチに<code>-dev</code>接尾辞を自動的に加え、VCSリポジトリからインポートしたその他全てのブランチに<code>dev-</code>の接頭辞を加えます。
両方の場合とも安定性<code>dev</code>が割り当たります。</p>
<p>このことを念頭に置くと、次の節を読む助けになります。</p>
<h3 id="最小安定性"><a class="header" href="#最小安定性">最小安定性</a></h3>
<p>チェックアウトされてプロジェクトに加わるライブラリのVCSの、ファイルに作用する点はもう1つあります。
Composerでは安定性の制約を指定し、正当と見做すタグを制限できます。
上の例で、最終的な公式リリースの前に、バージョン<code>1.1</code>にベータ版と2つのリリース候補が、ライブラリでリリースされていることにご注目ください。
<code>composer install</code>や<code>composer update</code>を走らせるときにこれらのバージョンを取得するには、リリース候補やベータリリース（または所望であればアルファリリース）で良いことをComposerに陽に伝えなければなりません。
これにはプロジェクト範囲の<code>minimum-stability</code>値を<code>composer.json</code>に使うか、バージョン制約に「安定性フラグ」を使います。
詳しくは<a href="doc/articles/../04-schema.html#minimum-stability">スキーマのページ</a>をお読みください。</p>
<h2 id="パッケージ制約を書く"><a class="header" href="#パッケージ制約を書く">パッケージ制約を書く</a></h2>
<p>Composerでのバージョンの捉え方が分かったところで、プロジェクトの依存関係でバージョン制約を指定する方法についてお話ししましょう。</p>
<h3 id="厳密なパッケージ制約"><a class="header" href="#厳密なパッケージ制約">厳密なパッケージ制約</a></h3>
<p>パッケージの厳密なバージョンを指定できます。
こうすると、このバージョンを、それもこのバージョンだけを、Composerにインストールするよう伝えます。
他の依存関係で違うバージョンが必要なとき、解決器は最終的に失敗し、インストールや更新の処理を途絶します。</p>
<p>例：<code>1.0.2</code></p>
<h3 id="バージョンの範囲"><a class="header" href="#バージョンの範囲">バージョンの範囲</a></h3>
<p>比較演算子を使うと、正当なバージョンの範囲を指定できます。
正当な演算子は<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>!=</code>です。</p>
<p>複数の範囲を定義できます。
空白 (<code> </code>) やコンマで区切られた範囲は<strong>論理積</strong>として扱われます。
二重パイプ (<code>||</code>) は<strong>論理和</strong>として扱われます。
積は和より優先されます。</p>
<blockquote>
<p><strong>補足：</strong>
境界のない範囲を使うときはご注意ください。
後方互換性を壊すバージョンを予期せずインストールすることがあるからです。
安全のため、代わりに<a href="doc/articles/versions.html#caret-version-range-">キャレット</a>演算子を使うことをご検討ください。</p>
</blockquote>
<!--blank line followed by comment markup to separate the block quotes-->
<blockquote>
<p><strong>補足：</strong>
Composerの古いバージョンでは、単一の棒 (<code>|</code>) は<strong>論理和</strong>の推奨される代替案でした。
そのため後方互換性のため、単一の棒 (<code>|</code>) は<strong>論理和</strong>として扱われたままになっています。</p>
</blockquote>
<p>例：</p>
<ul>
<li><code>&gt;=1.0</code></li>
<li><code>&gt;=1.0 &lt;2.0</code></li>
<li><code>&gt;=1.0 &lt;1.1 || &gt;=1.2</code></li>
</ul>
<h3 id="ハイフン版のバージョン範囲--"><a class="header" href="#ハイフン版のバージョン範囲--">ハイフン版のバージョン範囲 (<code>-</code>)</a></h3>
<p>含まれるバージョンの集合です。
含まれるバージョンの右部分はワイルドカードが補完されます。
例えば<code>1.0 - 2.0</code>は、<code>2.0</code>が<code>2.0.*</code>になるため、<code>&gt;=1.0.0 &lt;2.1</code>と等価です。
他方で<code>1.0.0 - 2.1.0</code>は<code>&gt;=1.0.0 &lt;=2.1.0</code>と等価です。</p>
<p>例：<code>1.0 - 2.0</code></p>
<h3 id="ワイルドカードのバージョン範囲-"><a class="header" href="#ワイルドカードのバージョン範囲-">ワイルドカードのバージョン範囲 (<code>.*</code>)</a></h3>
<p><code>*</code>ワイルドカードでパターンを指定できます。
<code>1.0.*</code>は<code>&gt;=1.0 &lt;1.1</code>と等価です。</p>
<p>例：<code>1.0.*</code></p>
<h2 id="次の大規模リリースの演算子"><a class="header" href="#次の大規模リリースの演算子">次の大規模リリースの演算子</a></h2>
<h3 id="チルダのバージョン範囲-"><a class="header" href="#チルダのバージョン範囲-">チルダのバージョン範囲 (<code>~</code>)</a></h3>
<p><code>~</code>演算子は例で説明するのが1番です。
<code>~1.2</code>は<code>&gt;=1.2 &lt;2.0.0</code>と等価です。
一方、<code>~1.2.3</code>は<code>&gt;=1.2.3 &lt;1.3.0</code>と等価です。
見て分かる通り、<a href="https://semver.org/">セマンティックバージョニング</a>を尊重するプロジェクトで特に有用です。
よくある使い方は、<code>~1.2</code>のように（こうすると2.0までの全バージョン、ただし2.0は含まれないものにできます）、依存する最小の小規模バージョンの印を付けることでしょう。
理論上は2.0まで後方互換性の破壊はないでしょうから、うまくいきます。
別の見方は、<code>~</code>を使って最小バージョンを指定するというものです。
ただし指定された最後の桁は上げられます。</p>
<p>例：<code>~1.2</code></p>
<blockquote>
<p><strong>補足：:</strong>
<code>2.0-beta.1</code>は<code>2.0</code>より厳密には前ですが、<code>~1.2</code>のようなバージョン制約ではインストールされません。
前述の通り、<code>~1.2</code>とは<code>.2</code>が変わることがありますが、<code>1.</code>の部分は固定されるという意味です。</p>
</blockquote>
<blockquote>
<p><strong>補足：</strong>
<code>~</code>演算子にはメジャーリリース番号に関して挙動に例外があります。
つまり、例えば<code>~1</code>は<code>~1.0</code>と同じですが、これは後方互換性を保とうとする上で、メジャー番号を増やせないからです。</p>
</blockquote>
<h3 id="キャレットバージョン範囲-"><a class="header" href="#キャレットバージョン範囲-">キャレットバージョン範囲 (<code>^</code>)</a></h3>
<p><code>^</code>演算子はとてもよく似た挙動ですが、よりセマンティックバージョニングに密接しており、破壊的でない更新は常に許されます。
例えば<code>^1.2.3</code>は<code>&gt;=1.2.3 &lt;2.0.0</code>と等価です。
2.0までのリリースで後方互換性を壊すものはないからです。
1.0より前のバージョンについては、安全性に留意した動作となっており、<code>^0.3</code>は<code>&gt;=0.3.0 &lt;0.4.0</code>として、<code>^0.0.3</code>は<code>&gt;=0.0.3 &lt;0.0.4</code>として扱います。</p>
<p>これはライブラリのコードを書く際に、最も相互運用性を高くするため推奨される演算子です。</p>
<p>例：<code>^1.2.3</code></p>
<blockquote>
<p><strong>補足：</strong>
WindowsでPowerShellを使っているとき、例えば<code>composer require</code>コマンドを使う際は、CLIで引数としてキャレットを使うときにエスケープしなければなりません。
キャレットがComposerに確実に正しく渡されるようにするため、例えば<code>^^^^1.2.3</code>のように、4つの連続するキャレット演算子を使わなければなりません。</p>
</blockquote>
<h2 id="安定性の制約"><a class="header" href="#安定性の制約">安定性の制約</a></h2>
<p>安定性を陽に定義しない制約を使うとき、使われた演算子により、Composerは内部的に既定を<code>-dev</code>または<code>-stable</code>にします。
これは透過的に起こります。</p>
<p>比較で安定リリースのみを陽に検討したいときは<code>-stable</code>接尾辞を加えてください。</p>
<p>例：</p>
<div class="table-wrapper"><table><thead><tr><th>制約</th><th>内部</th></tr></thead><tbody>
<tr><td><code>1.2.3</code></td><td><code>=1.2.3.0-stable</code></td></tr>
<tr><td><code>&gt;1.2</code></td><td><code>&gt;1.2.0.0-stable</code></td></tr>
<tr><td><code>&gt;=1.2</code></td><td><code>&gt;=1.2.0.0-dev</code></td></tr>
<tr><td><code>&gt;=1.2-stable</code></td><td><code>&gt;=1.2.0.0-stable</code></td></tr>
<tr><td><code>&lt;1.3</code></td><td><code>&lt;1.3.0.0-dev</code></td></tr>
<tr><td><code>&lt;=1.3</code></td><td><code>&lt;=1.3.0.0-stable</code></td></tr>
<tr><td><code>1 - 2</code></td><td><code>&gt;=1.0.0.0-dev &lt;3.0.0.0-dev</code></td></tr>
<tr><td><code>~1.3</code></td><td><code>&gt;=1.3.0.0-dev &lt;2.0.0.0-dev</code></td></tr>
<tr><td><code>1.4.*</code></td><td><code>&gt;=1.4.0.0-dev &lt;1.5.0.0-dev</code></td></tr>
</tbody></table>
</div>
<p>しかし制約の水準に強制せず様々な安定性を許すには、<code>@&lt;安定性&gt;</code>（例：<code>@dev</code>）のように<a href="doc/articles/../04-schema.html#package-links">安定性フラグ</a>を使い、与えられたパッケージが既定の最小安定性の設定とは違う安定性でインストールできることをComposerに知らせます。
使える全ての安定性フラグは<a href="doc/articles/../04-schema.html#minimum-stability">スキーマのページ</a>の最小安定性の節に挙がっています。</p>
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<pre><code class="language-jsonc">"require": {
    "vendor/package": "1.3.2", // 1.3.2ぴったり

    // &gt;, &lt;, &gt;=, &lt;= | 上限と下限を指定
    "vendor/package": "&gt;=1.3.2", // 1.3.2以上の全バージョン
    "vendor/package": "&lt;1.3.2", // 1.3.2より小さい全バージョン

    // * | ワイルドカード
    "vendor/package": "1.3.*", // &gt;=1.3.0 &lt;1.4.0

    // ~ | 最後の桁は上げられます
    "vendor/package": "~1.3.2", // &gt;=1.3.2 &lt;1.4.0
    "vendor/package": "~1.3", // &gt;=1.3.0 &lt;2.0.0

    // ^ | 破壊的な変更を許しません（セマンティックバージョニングに従い、メジャーバージョンは固定です）
    "vendor/package": "^1.3.2", // &gt;=1.3.2 &lt;2.0.0
    "vendor/package": "^0.3.2", // &gt;=0.3.2 &lt;0.4.0 // メジャーバージョンが0のときは例外
}
</code></pre>
<h2 id="パッケージ制約の確認"><a class="header" href="#パッケージ制約の確認">パッケージ制約の確認</a></h2>
<p><a href="https://semver.madewithlove.com">semver.madewithlove.com</a>を使ってバージョン制約を確認できます。
パッケージ名を埋めると、Composerにより<code>composer.json</code>ファイルに加わる既定のバージョン制約が自動で埋まります。
バージョン制約を調整すると、ツールにより、合致する全てのリリースが強調されます。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="285-2025-01-21"><a class="header" href="#285-2025-01-21"><a href="https://github.com/composer/composer/compare/2.8.4...2.8.5">2.8.5</a> 2025-01-21</a></h3>
<ul>
<li>
<p>Added build provenance attestation so you can also now download and
verify phar files from GitHub releases:</p>
<pre><code>gh release --repo composer/composer download --pattern composer.phar
gh attestation verify --repo composer/composer composer.phar
</code></pre>
</li>
<li>
<p>非対応の<code>funding</code>の値により、パッケージの解析エラーが起こっていた点を修正 (#12247)</p>
</li>
<li>
<p>新しい寄付の書式への対応を修正 (#12257)</p>
</li>
<li>
<p><code>reload()</code>を使うときの、2.8.4であったInstalledVersionsの退行問題を修正 (#12269)</p>
</li>
<li>
<p>psr-0/psr-4の規則が、<code>vendor/composer/autoload*.php</code>において不定の順番になっていた点を修正
(#12263)</p>
</li>
<li>
<p>特定の状況下で、誤って起こっていた警告を修正 (#12284, #12268, #12283)</p>
</li>
</ul>
<h3 id="284-2024-12-11"><a class="header" href="#284-2024-12-11"><a href="https://github.com/composer/composer/compare/2.8.3...2.8.4">2.8.4</a> 2024-12-11</a></h3>
<ul>
<li><code>audit</code>コマンドの終了コードに意味がなかった点を修正しました（脆弱性のとき1、放棄されているときは2、両方では3になりました）
(#12203)</li>
<li>複数のクラスが定義されている場合の、プラグインの更新時の問題を修正しました (#12226)</li>
<li>phpの設定によって、出力に現れていた重複するエラーを修正しました (#12214)</li>
<li>InstalledVersionsがある場合に重複するデータを返していた点を修正しました (#12225)</li>
<li>installed.phpを修正し、整列が決定的になるようにしました (#12197)</li>
<li>インラインの制約を使っているときに<code>bump-after-update</code>が失敗する点を修正しました (#12223)</li>
<li><code>create-project</code>コマンドを修正しました。
パスリポジトリを引数に使った場合、シンボリックリンクを無効にするようになりました (#12222)</li>
<li><code>validate --no-check-publish</code>を修正し、全面的に公開のエラーを隠すようにしました。
無関係なエラーのためです (#12196)</li>
<li>composer auditが失敗したとき、<code>audit</code>コマンドが失敗コードを返していた点を修正しました。
ビルドの失敗を引き起こすべきではないためです。
ただ、ビルドの一過程でauditを走らせること自体、あまり感心しません (#12196)</li>
<li>curlの使い方を修正し、プロキシが使われているときに壊れたバージョンで多重化を無効にするようにしました (#12207)</li>
</ul>
<h3 id="283-2024-11-17"><a class="header" href="#283-2024-11-17"><a href="https://github.com/composer/composer/compare/2.8.2...2.8.3">2.8.3</a> 2024-11-17</a></h3>
<ul>
<li>Windowsでのプロセス探索の扱いを修正 (#12180)</li>
<li>react/promiseの要件で2.xのインストールができるように改めて修正 (#12188)</li>
<li>lock:falseがrequireコマンドやbumpコマンドで設定されたときの問題を修正</li>
</ul>
<h3 id="282-2024-10-29"><a class="header" href="#282-2024-10-29"><a href="https://github.com/composer/composer/compare/2.8.1...2.8.2">2.8.2</a> 2024-10-29</a></h3>
<ul>
<li>プロバイダに説明がないとき、プロバイダの提案時にクラッシュしていた点を修正 (#12152)</li>
<li>特定の状況で、スキーマに違反する固定ファイルが作られる問題を修正 (#12149)</li>
<li>相対パスのリポジトリのパスを使う際に、2.8.1で生じた<code>create-project</code>の退行問題を修正 (#12150)</li>
<li>ctrl-Cで中断する操作が、テキストプロンプトで機能していなかった点を修正 (#12106)</li>
<li>所有権の違反でgitによりリポジトリが読み込めなかったときに、gitがひとりでに失敗していた点を修正 (#12178)</li>
<li>プロキシを介してPHPでないバイナリを実行しているときの、シグナルの扱いを修正しました (#11716)</li>
</ul>
<h3 id="281-2024-10-04"><a class="header" href="#281-2024-10-04"><a href="https://github.com/composer/composer/compare/2.8.0...2.8.1">2.8.1</a> 2024-10-04</a></h3>
<ul>
<li><code>init</code>コマンドを修正し、使用許諾が与えられなかったときの退行問題を修正しました (#12145)</li>
<li><code>--strict-ambiguous</code>フラグの扱いを修正しました。
全ての問題を報告しないことがありました (#12148)</li>
<li><code>create-project</code>を修正し、インストールされるプロジェクトファイルのフォルダのパーミッションを継承するようにしました
(#12146)</li>
<li>親ディレクトリのcomposer.jsonを使うときのプロンプトが、正しく動かない場合があった点を修正しました (#8023)</li>
</ul>
<h3 id="280-2024-10-02"><a class="header" href="#280-2024-10-02"><a href="https://github.com/composer/composer/compare/2.7.9...2.8.0">2.8.0</a> 2024-10-02</a></h3>
<ul>
<li>後方互換性についての警告：<code>https_proxy</code>環境変数が<code>http_proxy</code>の値にフォールバックする点を修正しました。
2.7.3のリリースノートの通り、フォールバックと警告は削除されました (#11938, #11915)。</li>
<li><code>update</code>コマンドに<code>--patch-only</code>フラグを追加しました。
これにより、更新をパッチバージョンに制限し、全ての依存関係がより安全な方へ更新されます (#12122)</li>
<li><code>audit</code>コマンドに<code>--abandoned</code>フラグに追加しました。
放棄されたパッケージの扱い方が構成されます。
<code>audit.abandoned</code>構成設定を上塗りします (#12091)</li>
<li><code>audit</code>コマンドに<code>--ignore-severity</code>フラグを追加しました。
1つ以上の勧告の深刻度を無視します (#12132)</li>
<li><code>update</code>コマンドに<code>--bump-after-update</code>フラグを追加します。
更新が完了した後にbumpを走らせます (#11942)</li>
<li><code>scripts</code>のうち、どれが追加のCLIの引数を受け取るかを制御する方法を追加しました。
また、コマンドのどこに入れるかも制御できます。
<a href="https://getcomposer.org/doc/articles/scripts.md#controlling-additional-arguments">ドキュメント</a>を参照してください
(#12086)</li>
<li><code>allow-missing-requirements</code>構成設定を追加しました。
固定ファイルがcomposer.jsonの依存関係を満たさないときのエラーを飛ばすものです (#11966)</li>
<li>composer.lockファイルのJSONスキーマを追加しました (#12123)</li>
<li>Bitbucketのアプリパスワード対応を改善しました。
リポジトリをクローンしたりソースからインストールしたりする部分です (#12103)</li>
<li><code>reinstall</code>コマンドに<code>--type</code>フラグを追加し、種別でパッケージを絞り込めるようにしました (#12114)</li>
<li><code>dump-autoload</code>コマンドに<code>--strict-ambiguous</code>フラグを追加しました。
重複するクラスが見つかったときにエラーコードを返すようにします (#12119)</li>
<li>ベンダーファイルが削除されたときに<code>dump-autoload</code>で出す警告を加えました (#12139)</li>
<li><code>create-project</code>を走らせる際、欠けている各プラットフォームパッケージに警告を追加しました。
何度も走らせなくていいようにするためです (#12120)</li>
<li><code>sort-packages</code>が有効のとき、allow-pluginsにパッケージの整列を追加しました (#11348)</li>
<li>extやlibのパッケージが欠けているときの、プロバイダパッケージやポリフィルの提案を追加しました (#12113)</li>
<li>最初に全てのパッケージと取り得る更新情報を出力し、対話的なパッケージの更新の選択を改善しました (#11990)</li>
<li>決定論的で（しばしば）論理的な方法で出力を整列し、依存関係の解決の失敗の出力を改善しました (#12111)</li>
<li>PHP 8.4の<code>E_STRICT</code>の非推奨の警告を修正しました (#12116)</li>
<li><code>init</code>コマンドを修正し、与えられた使用許諾の識別子を検証するようにしました (#12115)</li>
<li>機能パッケージが2つの主線ブランチのどちらかに由来する可能性があると思われるとき、バージョンの推定を、機能ブランチに基づいてより決定論的になるよう修正しました
(#12129)</li>
<li>COMPOSER_ROOT_VERSION環境変数の扱いを修正しました。
例えば1.1の扱いは1.2.x-devと同じにし、1.2.0とは違うようにしました (#12109)</li>
<li>requireコマンドを修正し、固定ファイルの新しい安定性フラグを飛ばすようにしました。
以前は固定ファイルの不当な差分が生じていました (#12112)</li>
<li>php://stdin を修正しました。
Composerをプラグラムで走らせているときに複数回開く可能性がありました (#12107)</li>
<li>プラットフォームパッケージの扱いを修正しました。
why-notコマンドと部分更新の部分です (#12110)</li>
<li>2.7.8で入った「transport-options.sslについて、ローカルの証明書の認証がロックファイルに保管されて、可搬でなかった点を修正しました
(#12019)」が壊れていたため、差し戻しました。</li>
</ul>
<h3 id="279-2024-09-04"><a class="header" href="#279-2024-09-04"><a href="https://github.com/composer/composer/compare/2.7.8...2.7.9">2.7.9</a> 2024-09-04</a></h3>
<ul>
<li>制約のある環境でのDockerの検出が壊れていた点を修正しました (#12095)</li>
<li>bash補完スクリプトの上流の問題を修正しました。
<code>completion</code>コマンドで更新することをお勧めします (#12015)</li>
</ul>
<h3 id="278-2024-08-22"><a class="header" href="#278-2024-08-22"><a href="https://github.com/composer/composer/compare/2.7.7...2.7.8">2.7.8</a> 2024-08-22</a></h3>
<ul>
<li><code>outdated</code>のJSON出力に<code>release-age</code>と<code>release-date</code>と<code>latest-release-date</code>を加えました
(#12053)</li>
<li>PHP 8.4の非推奨の警告を修正しました。</li>
<li>ブランチを解決する部分を修正し、<code>#</code>記号を含むものでも機能するようにしました  (#12042)</li>
<li><code>bump</code>コマンドについて、<code>~</code>制約が正しく扱われていなかった点を直しました (#11889)</li>
<li>COMPOSER_AUTHが./auth.jsonより優先度が上でなかった点を修正しました (#12084)</li>
<li><code>relative: true</code>について、パスのリポジトリのシンボリックリンクが考慮されないことがあった点を修正しました (#12092)</li>
<li>キャッシュからの複製について、VirtualBoxの共有フォルダを使うときに失敗することがあった点を修正しました (#12057)</li>
<li>PSR-4の自動読み込み順序について、エッジケースの退行問題を修正しました (#12063)</li>
<li>重複するlib-*パッケージにより、peclとcoreのバージョンの同じPHP拡張があるときに問題が生じていた点を修正しました (#12093)</li>
<li>transport-options.sslについて、ローカルの証明書の認証がロックファイルに保管されて、可搬でなかった点を修正しました
(#12019)</li>
<li>メモリに関して、大きなバイナリをインストールするときの問題を修正しました (#12032)</li>
<li><code>archive</code>コマンドについて、windowsでパスのrealpathが取れないときにクラッシュする点を修正しました (#11544)</li>
<li>API: BasePackage::STABILITIESをもって、BasePackage::$stabilitiesを廃止しました
(685add70ec)</li>
<li>Dockerの検出を改善しました (#12062)</li>
</ul>
<h3 id="277-2024-06-10"><a class="header" href="#277-2024-06-10"><a href="https://github.com/composer/composer/compare/2.7.6...2.7.7">2.7.7</a> 2024-06-10</a></h3>
<ul>
<li>セキュリティ：悪意のあるgitブランチ名を介したコマンドインジェクションに対して修正しました (GHSA-47f6-5gq3-vx9c /
CVE-2024-35241)。</li>
<li>セキュリティ：悪意のあるgit/hgブランチ名を介した複数のコマンドインジェクションに対して修正しました
(GHSA-v9qv-c7wm-wgmf / CVE-2024-35242)。</li>
<li>セキュリティ：不正なURLの形式を使って迂回される可能性のあったsecure-http検査を修正しました (fa3b9582c)。</li>
<li>セキュリティ：linuxにおけるwindows固有の検査を含むFilesystem::isLocalPathを修正しました
(3c37a67c)。</li>
<li>セキュリティ：perforceへの引数のエスケープを修正しました (3773f775)。</li>
<li>セキュリティ：アーカイブを解凍するときのzip爆弾の扱いを修正しました (de5f7e32)。</li>
<li>セキュリティ：Windowsのコマンドの仮引数のエスケープを修正し、エンコーディングの変換の最尤一致によるユニコード文字の濫用を防止しました
(3130a7455, 04a63b324)。</li>
<li>隠された規則の名前空間に合致しないクラスに対するPSR違反を修正しました。
これにより新たに違反項目が見つかるかもしれません (#11957)。</li>
<li>プラグインがベンダーディレクトリにあるものの、ブランチを変えた後に必要でなくなったり使えなくなったりしたときのUXを修正しました
(#12000)。</li>
<li>固定ファイルが古いとき、composer.jsonの新しいプラットフォーム要件が検査されない点を修正しました (#12001)。</li>
<li><code>config</code>コマンドがautoloadキーを削除する機能を修正しました (#11967)。</li>
<li><code>init</code>コマンドでの空の<code>type</code>への対応を修正しました (#11999)。</li>
<li>gitの構成で<code>safe.bareRepository</code>が<code>strict</code>に設定されているときのgitクローンのエラーを修正しました
(#11969)。</li>
<li>PHP &lt;8.1でネットワークエラーが表示される退行問題を修正しました (#11974)。</li>
<li>一部の警告でのカラーブリードを修正しました (#11972)。</li>
</ul>
<h3 id="276-2024-05-04"><a class="header" href="#276-2024-05-04"><a href="https://github.com/composer/composer/compare/2.7.5...2.7.6">2.7.6</a> 2024-05-04</a></h3>
<ul>
<li>スクリプト制御子が私有コールバックを使う自動読み込み器を加えるときの退行問題を修正しました (#11960)。</li>
</ul>
<h3 id="275-2024-05-03"><a class="header" href="#275-2024-05-03"><a href="https://github.com/composer/composer/compare/2.7.4...2.7.5">2.7.5</a> 2024-05-03</a></h3>
<ul>
<li><code>remove</code>コマンドに<code>uninstall</code>の別称を加えました (#11951)。</li>
<li>転送で例外を起こすcurlの壊れたバージョン8.7.0/8.7.1のための対処法を加えました (#11913)。</li>
<li>Podmanコンテナ内で表示される、rootを使うときの警告を修正しました (#11946)。</li>
<li>configコマンドがある状況で正しくオブジェクトを扱っていなかった点を修正しました (#11945)。</li>
<li>プロジェクトディレクトリがシンボリックリンクのとき、バイナリプロキシが正しいパスを含んでいなかった点を修正しました (#11947)。</li>
<li>イベント制御子（scriptsとplugins）から読み込まれたときに、Composerの自動読み込み器がプロジェクトの自動読み込み器から無視される点を修正しました
(#11955)。</li>
<li>TransportException（httpの失敗）が個別の終了コードでなかった点を修正しました (#11954)。
<code>100</code>のコードで終わるようになりました。</li>
</ul>
<h3 id="274-2024-04-22"><a class="header" href="#274-2024-04-22"><a href="https://github.com/composer/composer/compare/2.7.3...2.7.4">2.7.4</a> 2024-04-22</a></h3>
<ul>
<li>composer/composerのバージョンpre-2.7.3を要件とするプロジェクトでの退行問題（<code>Call to undefined method ProxyManager::needsTransitionWarning()</code>）を修正しました (#11943, #11940)。</li>
</ul>
<h3 id="273-2024-04-19"><a class="header" href="#273-2024-04-19"><a href="https://github.com/composer/composer/compare/2.7.2...2.7.3">2.7.3</a> 2024-04-19</a></h3>
<ul>
<li>後方互換性についての警告：<code>https_proxy</code>環境変数が<code>http_proxy</code>の値にフォールバックする点を修正しました。
まだそのままになっていますが、警告を伴うようになりました。
https_proxyを空に設定してフォールバックを除くことができるようになりました。
Composer 2.8.0ではフォールバックを削除するため、本警告にご注意ください (#11915)。</li>
<li><code>show</code>コマンドと<code>outdated</code>コマンドを修正し、パッケージの一覧を表示するときの先頭の<code>v</code>を除きました。
例えば<code>v1.2.3</code>のような見た目をしていました (#11925)。</li>
<li><code>audit</code>コマンドを修正し、CVEが存在しないときに識別番号を表示しないようにしました。
勧告識別番号が表示されるようになりました (#11892)。</li>
<li><code>project</code>種別を持つパッケージで表示される既定のバージョンが欠けていることについての警告を修正しました。
これらのパッケージは大抵バージョン管理されておらず、循環参照がないためです (#11885)。</li>
<li>PHP 8.4の非推奨の警告を修正しました。</li>
<li><code>clear-cache</code>コマンドを修正し、ローカルのcomposer.jsonのconfig.cache-dir設定を考慮するようにしました
(#11921)。</li>
<li><code>status</code>コマンドが失敗したダウンロードとインストールのプロミスを正しく扱っていなかった点を修正しました (#11889)。</li>
<li>GitHubの寄付ファイルの<code>buy_me_a_coffee</code>への対応を追加しました (#11902)。</li>
<li>SSHのURLに<code>hg</code>の対応を追加しました (#11878)。</li>
<li>幾つかの環境変数を修正し、整数値がクラッシュを起こさないようにしました (#11908)。</li>
<li>IOInterfaceをPSR-3ロガーとして使う際に文脈データが出力されないように修正しました (#11882)。</li>
</ul>
<h3 id="272-2024-03-11"><a class="header" href="#272-2024-03-11"><a href="https://github.com/composer/composer/compare/2.7.1...2.7.2">2.7.2</a> 2024-03-11</a></h3>
<ul>
<li><code>composer --version</code>を走らせる際に、PHPのバージョンについての情報を追加しました (#11866)。</li>
<li>根幹のバージョンが見合たらなかったときの警告を追加しました (#11858)。</li>
<li>ルート権限で走らせる際に、幾つかの状況下では依然としてプラグインが有効だった問題を修正しました (c3efff91f)。</li>
<li><code>outdated --ignore ...</code>が依然として無視されたパッケージの最新版を読み込もうとしていた問題を修正しました
(#11863)。</li>
<li>インストールパスの途中でシンボリックリンクが壊れたときの対処について修正しました (#11864)。</li>
<li><code>update --lock</code>が依然として幾つかのメタ情報を間違った内容で更新していた問題を修正しました (#11850, #11787)。</li>
</ul>
<h3 id="271-2024-02-09"><a class="header" href="#271-2024-02-09"><a href="https://github.com/composer/composer/compare/2.7.0...2.7.1">2.7.1</a> 2024-02-09</a></h3>
<ul>
<li>2.7.0で利用者が出喰わすよくある問題に対して補足を入れるために、プラグインが無効化されたときの警告を幾つか追加しました (#11842)。</li>
<li>pharから走らせたときに<code>diagnose</code>でのComposerの依存関係の監査が失敗する問題を修正しました。</li>
</ul>
<h3 id="270-2024-02-08"><a class="header" href="#270-2024-02-08"><a href="https://github.com/composer/composer/compare/2.6.6...2.7.0">2.7.0</a> 2024-02-08</a></h3>
<ul>
<li>セキュリティ：危殆化したベンダーディレクトリの内容を介したコードの実行と権限昇格の可能性を修正しました (GHSA-7c6p-848j-wh5h
/ CVE-2024-24821)。</li>
<li><code>audit.abandoned</code>構成設定の期待値を<code>fail</code>に変更しました。
望ましくなければ<code>report</code>や<code>ignore</code>に設定してください。
または<code>COMPOSER_AUDIT_ABANDONED</code>環境変数も使えます (#11643)。</li>
<li><code>update</code>/<code>require</code>/<code>remove</code>コマンドに--minimal-changes (-m)
フラグを追加し、--with-dependenciesで部分的な更新を掛けつつ、推移的な依存関係で絶対に必要なものだけを変更できるようにしました
(#11665)。</li>
<li><code>outdated</code>/<code>show</code>コマンドに--sort-by-age (-A)
フラグを追加し、それぞれリリース日による整列（古いものが最初に来ます）とリリース日の表示ができるようにしました (#11762)。</li>
<li><code>show</code>コマンドで<code>--self</code>を<code>--installed</code>や<code>--locked</code>と組み合わせる対応を追加しました。
根幹パッケージを出力されるパッケージの一覧に追加できるようにするための変更です (#11785)。</li>
<li>深刻度の情報を<code>audit</code>コマンドの出力に追加しました (#11702)。</li>
<li>composer.jsonに<code>scripts-aliases</code>最上位キーを追加しました。
定義した自前のスクリプトに別称を定義できます (#11666)。</li>
<li>接続が時間切れになったときにIPv4にフォールバックする対応を加えました。
また、IPv4やIPv6に強制するための環境変数<code>COMPOSER_IPRESOLVE</code>も追加しました。
それぞれ<code>4</code>および<code>6</code>に設定できます (#11791)。</li>
<li><code>outdated</code>の--ignore引数にワイルドカードの対応を追加しました (#11831)。</li>
<li><code>bump</code>コマンドに、<code>*</code>を<code>&gt;=現在のバージョン</code>に上げる対応を追加しました (#11694)。</li>
<li><code>validate</code>コマンドに、どうあっても照合する可能性のない制約の検出を追加しました (#11829)。</li>
<li>とても冗長なモード (-vv) で走らせているときに、パッケージのソース情報を<code>install</code>の出力に追加するようにしました。</li>
<li><code>diagnose</code>コマンドでComposer自体に含まれる依存関係の監査を追加しました (#11761)。</li>
<li><code>diagnose</code>コマンドの出力にGitHubトークンの失効日を追加しました (#11688)。</li>
<li>why/why-notコマンドに非ゼロの状態コードを追加しました (#11796)。</li>
<li><code>show --direct &lt;package&gt;</code>を間接ないし推移的な依存関係で呼び出したときのエラーを追加しました (#11728)。</li>
<li><code>COMPOSER_FUND=0</code>環境変数を追加し、募金の呼び掛けを隠せるようにしました (#11779)。</li>
<li><code>bump</code>コマンドを修正し、<code>v</code>前置詞が必要なパッケージのバージョンを上げないようにしました (#11764)。</li>
<li>ルートユーザーとして非対話的に走らせているときに、プラグインが自動的に無効になる事象を修正しました。</li>
<li><code>update --lock</code>を修正し、distのreference/url/checksumがピン留めされたままになっていなかった点を修正しました
(#11787)。</li>
<li>固定ファイルが存在していない場合に<code>require</code>コマンドが最後にクラッシュする問題を修正しました (#11814)。</li>
<li>固定された依存関係を監査するときにルートの別称が問題を起こす点を修正しました (#11771)。</li>
<li><code>require</code>コマンドで4つのコンポーネントでバージョンを扱うときの問題を修正しました (#11716)。</li>
<li>Symfony 7の互換性の問題を修正しました。</li>
<li><code>require</code>コマンドの--dry-runの後、composer.jsonが最新の状態に追従できない問題を修正しました (#11747)。</li>
<li>特定の状況下で警告が間違って表示されていた点を修正しました (#11786, #11760, #11803)。</li>
</ul>
<h3 id="266-2023-12-08"><a class="header" href="#266-2023-12-08"><a href="https://github.com/composer/composer/compare/2.6.5...2.6.6">2.6.6</a> 2023-12-08</a></h3>
<ul>
<li>要件symfony/consoleから7.xを除外するように修正しました。
Composer 2.6とは互換性が無いからです。
2.7では互換性があるでしょう (#11741)</li>
<li>libpqの解析を修正し、可能であれば大域定数を使うようにしました (#11684)</li>
<li>一時制約の失敗があった更新でのエラー出力を修正しました (#11692)</li>
</ul>
<h3 id="265-2023-10-06"><a class="header" href="#265-2023-10-06"><a href="https://github.com/composer/composer/compare/2.6.4...2.6.5">2.6.5</a> 2023-10-06</a></h3>
<ul>
<li>vendorディレクトリに壊れたシンボリックリンクが含まれる場合の失敗を修正しました (#11670)。</li>
<li>Composerのzipアーカイブから欠けていたcomposer.lockを修正しました (#11674)。</li>
<li>2.6.4で変わったAutoloadGenerator::dump()の非BCシグネチャを修正しました (cb363b0e8)。</li>
</ul>
<h3 id="264-2023-09-29"><a class="header" href="#264-2023-09-29"><a href="https://github.com/composer/composer/compare/2.6.3...2.6.4">2.6.4</a> 2023-09-29</a></h3>
<ul>
<li>セキュリティ：composer.pharが公開されててアクセスでき、PHPとして実行でき、php.iniでregister_argc_argvが有効なとき、遠隔コード実行の脆弱性がありえた点を直しました
(GHSA-jm6m-4632-36hf / CVE-2023-43655)。</li>
<li>auditコマンドで放棄されたパッケージのjson出力を直しました (#11647)。</li>
<li>プール最適化の工程を効率良くしました (#11638)。</li>
<li><code>show -a &lt;パッケージ名&gt;</code>の効率良くしました (#11659)。</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
