# composer.jsonのスキーマ

この章では`composer.json`で利用できる全てのフィールドについて説明します。

## JSONスキーマ

形式をドキュメント化する[JSON
schema](https://json-schema.org)があり、`composer.json`を検証するのにも使えます。実際、`validate`コマンドによって使われています。
https://getcomposer.org/schema.json から取得できます。

## ルートパッケージ

ルートパッケージは`composer.json`でプロジェクトのルートに定義されたパッケージのことです。プロジェクトの要件を定義しているのがメインの`composer.json`なのです。

フィールドの中にはルートパッケージの文脈でのみ適用されるものがあります。この一例は`config`フィールドです。ルートパッケージのみが設定を定義できます。依存関係の設定は無視されます。このようにして`config`フィールドは`root-only`になるのです。

> **補足：**パッケージは文脈によってルートパッケージになったりならなかったりします。例えばプロジェクトが`monolog`ライブラリに依存している場合、そのプロジェクトはルートパッケージです。しかしもしバグ修正のためにGitHubから`monolog`をクローンしてきたとすれば、`monolog`はルートパッケージになります。

## プロパティ

### name

パッケージ名です。ベンダー名とプロジェクト名から構成され、`/`で区切られます。例えば：

* monolog/monolog
* igorw/event-source

名前は小文字で、単語は`-`や`.`や`_`で区切られていなくてはなりません。名前全体は`^[a-z0-9]([_.-]?[a-z0-9]+)*/[a-z0-9](([_.]?|-{0,2})[a-z0-9]+)*$`に照合するでしょう。

`name`プロパティは公開されるパッケージ（ライブラリ）には必須です。

> **補足：**Composerのバージョン2.0より前は、名前には空白込みでどんな文字も含められました。

### description

パッケージの短い説明です。大抵これは1行分の長さです。

公開されるパッケージ（ライブラリ）には必須です。

### version

パッケージのバージョンです。ほとんどの場合これは必須ではなく省略すべきです（後述）。

これは`X.Y.Z`や`vX.Y.Z`の形式にしたがっていなければなりません。オプションで`-dev`、`-patch` (`-p`)、`-alpha`
(`-a`)、`-beta`
(`-b`)、`-RC`を接尾辞に付けても構いません。また、patch、alpha、beta、RCの接尾辞には数字が続けても大丈夫です。

例：

- 1.0.0
- 1.0.2
- 1.1.0
- 0.2.5
- 1.0.0-dev
- 1.0.0-alpha3
- 1.0.0-beta2
- 1.0.0-RC5
- v2.0.4-p1

パッケージのリポジトリのどこかしらからバージョンが推測できるのであればこのプロパティはオプションです。例えばVCSリポジトリのVCSのタグ名などです。その場合は省略することが推奨されます。

> **補足：** PackagistはVCSリポジトリを使うため、上の記載はPackagistにも全く同じことが言えます。自分でバージョンを指定するとほぼ確実にいつかヒューマンエラーにより問題が生じることでしょう。

### type

パッケージの種別です。既定は`library`です。

パッケージの種別は独自のインストールの仕組みに使われます。何らかの特別な仕組みが必要なパッケージがあるとき、独自の種別を定義することができます。これは`symfony-bundle`、`wordpress-plugin`、`typo3-cms-extension`とできます。これらの種別は全て特定のプロジェクトに特有のものであって、その種別のパッケージのインストールができるようなインストーラを提供する必要があります。

その中でも特にComposerは4つの種別に対応しています。

- **library:**これは既定です。ファイルを`vendor`に複製します。
- **project:**これは、ライブラリではなくプロジェクトであることを示しています。例えば[Symfony標準エディション](https://github.com/symfony/symfony-standard)のようなアプリケーションのシェル、[SilverStripeインストーラ](https://github.com/silverstripe/silverstripe-installer)のようなCMS、あるいはパッケージとして配布される完全なアプリケーションがこれにあたります。例としてIDEから新しいワークスペースを作る際に初期化するプロジェクトの一覧を提供するのに使うことができます。
- **metapackage:**要件を含む空のパッケージでありインストールの条件になりますが、ファイルを含んでおらずファイルシステムに何も書き込まないものです。そうしたわけなので、インストールできるdistやsourceキーを必要としません。
- **composer-plugin:**種別`composer-plugin`のパッケージは独自の種別を持つ他のパッケージのインストーラを提供することがあります。詳細は[専門記事](articles/custom-installers.md)を参照してください。

インストール時に独自の仕組みが必要な場合にのみ独自の種別を使ってください。このフィールドを省略し既定の`library`にするのがお勧めです。

### keywords

パッケージに関係するキーワードの配列です。検索と絞り込みに使えます。

例：

- logging
- events
- database
- redis
- templating

> **補足**：`--dev`オプションなしで`composer require`するようにし、パッケージを`require`ではなく`require-dev`に追加してもよいか利用者にプロンプトを出す特別なキーワードがあります。`dev`、`testing`、`static analysis`がそれです。

任意のものです。

### homepage

プロジェクトのwebサイトへのURLです。

任意のものです。

### readme

readmeドキュメントへの相対パスです。
既定では`README.md`です。

これは主にパッケージがGitHubにないときに有用です。
GitHubパッケージについて、Packagist.orgではGitHub側で検出されたものを取得するreadme APIを使うからです。

任意のものです。

### time

当該バージョンのリリース日です。

`YYYY-MM-DD`または`YYYY-MM-DD HH:MM:SS`の形式でなければなりません。

任意のものです。

### license

パッケージの利用許諾です。これは文字列または文字列の配列にできます。

最頻出の利用許諾についての推奨される記法は以下の通り（辞書順）。

- Apache-2.0
- BSD-2-Clause
- BSD-3-Clause
- BSD-4-Clause
- GPL-2.0-only / GPL-2.0-or-later
- GPL-3.0-only / GPL-3.0-or-later
- LGPL-2.1-only / LGPL-2.1-or-later
- LGPL-3.0-only / LGPL-3.0-or-later
- MIT

オプションにはなりますが、このプロパティを付けることは強く推奨されます。他の識別子は[SPDX Open Source License
Registry](https://spdx.org/licenses/)に一覧になっています。

> **Note:** ソースが閉鎖的なソフトウェアについては利用許諾の識別子として `"proprietary"` を使うことができます。

一例：

```json
{
    "license": "MIT"
}
```

あるパッケージについて、複数の利用許諾から選択できる場合（「離接的利用許諾」）、複数のものを配列として指定できます。

離接的利用許諾の例です。

```json
{
    "license": [
        "LGPL-2.1-only",
        "GPL-3.0-or-later"
    ]
}
```

代わりに「or」で区切って括弧で囲むこともできます。

```json
{
    "license": "(LGPL-2.1-only or GPL-3.0-or-later)"
}
```

これに似ていますが、複数の利用許諾が適用される必要があるときは（「結合的利用許諾」）、「and」で区切って（）で囲むことになります。

### authors

パッケージの作者です。これはオブジェクトの配列です。

それぞれの作者オブジェクトは以下のプロパティを持つことができます。

* **name:** 作者名です。大抵は実名です。
* **email:** 作者のEメールアドレスです。
* **homepage:** 作者のwebサイトへのURLです。
* **role:** プロジェクトにおける作者の役割です（例：開発者や翻訳者）

一例：

```json
{
    "authors": [
        {
            "name": "Nils Adermann",
            "email": "naderman@naderman.de",
            "homepage": "https://www.naderman.de",
            "role": "Developer"
        },
        {
            "name": "Jordi Boggiano",
            "email": "j.boggiano@seld.be",
            "homepage": "https://seld.be",
            "role": "Developer"
        }
    ]
}
```

任意のプロパティですが、付けることを強く推奨します。

### support

プロジェクトについてのサポートを得るための様々な情報です。

サポート情報には以下が含まれます。

* **email:** サポート用Eメールアドレスです。
* **issues:** 課題管理表へのURLです。
* **forum:** フォーラムへのURLです。
* **wiki:** wikiへのURLです。
* **irc:** irc://server/channel のような、サポート用IRCチャンネルです。
* **source:** ソースを閲覧したりダウンロードしたりするURLです。
* **docs:** ドキュメントへのURLです。
* **rss:** RSSフィードへのURLです。
* **chat:** チャットチャンネルへのURLです。
* **security:** 脆弱性公表ポリシー (vulnerability disclosure policy; VDP) へのURLです。

一例：

```json
{
    "support": {
        "email": "support@example.org",
        "irc": "irc://irc.freenode.org/composer"
    }
}
```

任意のものです。

### funding

パッケージの作者が維持管理と新しい機能の開発を行えるよう投資を提供するためのURLの一覧です。

それぞれの項目は以下のものからなります。

* **type:**
  投資の種別、または投資を行えるプラットフォームです。例えばpatreon、opencollective、tidelift、githubです。
* **url:** 詳細が記載されたwebサイトへのURLとパッケージに投資する方法です。

一例：

```json
{
    "funding": [
        {
            "type": "patreon",
            "url": "https://www.patreon.com/phpdoctrine"
        },
        {
            "type": "tidelift",
            "url": "https://tidelift.com/subscription/pkg/packagist-doctrine_doctrine-bundle"
        },
        {
            "type": "other",
            "url": "https://www.doctrine-project.org/sponsorship.html"
        }
    ]
}
```

任意のものです。

### パッケージのリンク

以下の全てはバージョン制約を介してパッケージ名とパッケージのバージョンを対応付けるオブジェクトを取ります。バージョンについての詳細は[こちら](articles/versions.md)をお読みください。

例：

```json
{
    "require": {
        "monolog/monolog": "1.0.*"
    }
}
```

全てのリンクは任意で付けてよいフィールドです。

`require`と`require-dev`は追加で _安定性フラグ_
（[ルート限定](04-schema.md#root-package)）に対応しています。"_constraint_@_stability flag_"
の形式を取っています。これらによりパッケージの安定性を、[最小安定性](#minimum-stability)の範疇を超え、さらに制限したり拡張したりすることができます。こうしたフラグは制約や空の
_制約_ に適用することができます。後者は例えば依存関係に不安定なパッケージを許容したい場合などです。

例：

```json
{
    "require": {
        "monolog/monolog": "1.0.*@beta",
        "acme/foo": "@dev"
    }
}
```

依存関係のうち不安定なパッケージに依存しているものがあれば、同様に明示的に必要安定性フラグと共に要件に加えなければなりません。

例：

`doctrine/doctrine-fixtures-bundle`が`"doctrine/data-fixtures":
"dev-master"`を要件としているとすると、ルートのcomposer.jsonの中で以下の2行目を加えて`doctrine/data-fixtures`パッケージの開発版リリースを許容する必要があります。

```json
{
    "require": {
        "doctrine/doctrine-fixtures-bundle": "dev-master",
        "doctrine/data-fixtures": "@dev"
    }
}
```

`require`と`require-dev`は追加で明示的な参照（つまりコミット）に対応しており、たとえ更新を走らせたとしても開発版のバージョンが与えられた状態で確実に固定されているようにします。これは明示的に開発版を要件にして参照に`#<ref>`を付けたときにのみ動作します。これはまた[ルート限定](04-schema.md#root-package)の機能であり依存関係では無視されます。

例：

```json
{
    "require": {
        "monolog/monolog": "dev-master#2eb0c0978d290a1c45346a1955188929cb4e5db7",
        "acme/foo": "1.0.x-dev#abc123"
    }
}
```

> **補足：**この機能には厳しい技術的制約があり、composer.jsonのメタデータはハッシュの前に指定されたブランチ名から読み込んでしまいます。したがってこの機能は一時的な問題を矯正するためにタグ付けされたリリースに切り替えられるまでに開発時に一時的に取る解決法とするべきです。Composerチームはこの機能に活発に対応しておらずこれに関するバグ報告を受け付けません。

パッケージ制約をインラインエイリアスすることも可能で、そうでなければ合致しない制約に合致させられます。詳細については[エイリアスの記事を参照してください](articles/aliases.md)。

`require`と`require-dev`はまた、プロジェクトを正常に走らせるために必要な特定のPHPとPHPの拡張のバージョンとへの参照に対応しています。

例：

```json
{
    "require": {
        "php": ">=7.4",
        "ext-mbstring": "*"
    }
}
```

> **補足：**プロジェクトが要件とするPHP拡張を一覧にすることは重要です。PHPのインストールが全て同じようになされるとは限りません。標準と考えている拡張が欠けているものもあるでしょう（例えば`ext-mysqli`はFedora/CentOSの最小インストールシステムでは既定ではインストールされません）。必要なPHPの要件を一覧にし損ねると利用者体験が悪化することに繋がります。Composerはパケージをインストールするときはエラーを1つも出さないものの、実行時に失敗するからです。`composer show --platform`コマンドはシステムで利用できる全てのPHP拡張を一覧にします。これを使えば、使用する拡張の一覧をコンパイルして要件に加える補助になるでしょう。代えてサードパーティーツールを使ってプロジェクトを解析し、使用されている拡張の一覧が得られるかもしれません。

#### require

このパッケージが必要とするパッケージの対応付けです。これらの要件が満たされない限りパッケージはインストールされません。

#### require-dev <span>([root-only](04-schema.md#root-package))</span>

このパッケージの開発したりテストを走らせたりなどするのに必要なパッケージへの対応付けです。ルートパッケージの開発要件は既定でインストールされます。`install`と`update`の両方とも`--no-dev`オプションに対応しており開発依存関係がインストールされるのを阻止できます。

#### conflict

このバージョンのパッケージと競合するパッケージへの対応付けです。それらのパッケージがこのパッケージと共にインストールされるのを許容しないようにします。

なお、`conflict`リンクで`<1.0 >=1.1`のような範囲を指定する場合、1.0より小さく*且つ*同時に1.1かそれより新しい全てのバージョンと競合しているという意味になります。これは恐らくやりたいことではないでしょう。この場合は`<1.0 || >=1.1`としたいことでしょう。

#### replace

このパッケージが置き換えるパッケージへの対応付けです。これによりパッケージをフォークし、独自のバージョン番号を持つ異なる名前で公開することができます。また元のパッケージが置き換わっているため、元のパッケージを要件とするパッケージはフォークしたパッケージを使って動作し続けることになります。

これは副パッケージを含むパッケージについても有用です。例えばメインのsymfony/symfonyパッケージには個々のパッケージとしても使える全てのSymfony
Componentが含まれています。メインパッケージを要件にすると自動的に個々のコンポーネントのうちどれか1つの要件が充足されます。メインパッケージがコンポーネントを置き換えるからです。

上記で説明した副パッケージの目的で置き換えを使う際は忠告があります。メインパッケージがその厳密なバージョンの副パッケージのみを置き換えるようにするため、通常は`self.version`をバージョン制約として使い置き換えるだけで、他のバージョンは変えないようにするべきです。他のバージョンが変わるとおかしなことになるでしょう。

#### provide

このパッケージにより提供されるパッケージの対応付けです。これが大体において役立つのは共通化されたインターフェースの実装です。何らかのパッケージが仮想的なパッケージに依存することができるようになるでしょう。例として`psr/logger-implementation`で、このロガーインターフェースを実装するライブラリは`provide`に挙げることになります。実装しているパッケージは[Packagist.org](https://packagist.org/providers/psr/log-implementation)で探すことができます。

仮想的なパッケージではなく実際のパッケージの名前で`provide`を使うことはそのパッケージのコードも世に出しているということを暗示しています。その場合一般的には`replace`がより良い選択です。インターフェースを提供して実装を提供する他のパッケージに任せる際（例えばPSRのインターフェース）のよくある慣習は、インターフェースパッケージに対応する仮想パッケージの名前に`-implementation`後置詞を使うことです。

#### suggest

このパッケージを向上させたりいい感じに動かせたりするようなお勧めのパッケージです。これらはお知らせ的なもので、パッケージがインストールされた後に表示されます。利用者にもっとパッケージを加えてもらえるような手掛かりを与えるためのもので、厳密には必要でなかったとしても大丈夫です。

形式は上述のパッケージリンクと同様ですが、値が自由な内容のテキストでバージョン制約ではない点は異なります。

例：

```json
{
    "suggest": {
        "monolog/monolog": "Allows more advanced logging of the application flow",
        "ext-xml": "Needed to support XML format in class Foo"
    }
}
```

### autoload

PHPの自動読み込み器用の自動読み込みの対応付けです。

[`PSR-4`](https://www.php-fig.org/psr/psr-4/)と[`PSR-0`](http://www.php-fig.org/psr/psr-0/)の自動読み込み、`classmap`生成、`files`による包含に対応しています。

PSR-4はより大幅に簡単に使えるためお勧めの方法です（クラスを追加したときに自動読み込み器を再生成する必要がありません）。

#### PSR-4

`psr-4`キー配下では名前空間からパスへの対応付けを定義します。パスはパッケージのルートから相対的なものです。`Foo\\Bar\\Baz`のようなクラスを自動読み込みする場合、ディレクトリ`src/`を指す名前空間の前部分`Foo\\`は、自動読み込み器が`src/Bar/Baz.php`という名前のファイルを探索しもしあれば含めるという意味です。なお比較的古いPSR-0の様式とは反対に、前部分
(`Foo\\`) はファイルパスに存在**しません**。

名前空間の前置詞は似た前置詞との競合を避けるため、`\\`で終わっていなければなりません。例えば`Foo`は`FooBar`名前空間のクラスに照合するので、後ろにバックスラッシュを付けると問題が解決します。`Foo\\`と`FooBar\\`は独立しています。

PSR-4の参照は、installやupdateの際に、単一のキー=>バリュー配列に全て結合されます。生成されるファイル`vendor/composer/autoload_psr4.php`で確認できます。

例：

```json
{
    "autoload": {
        "psr-4": {
            "Monolog\\": "src/",
            "Vendor\\Namespace\\": ""
        }
    }
}
```

複数のディレクトリで同じ前置詞を検索する必要がある場合は、以下のように配列として指定することができます。

```json
{
    "autoload": {
        "psr-4": { "Monolog\\": ["src/", "lib/"] }
    }
}
```

どの名前空間も見付かるようなフォールバックディレクトリを持たせたければ、次のように空の前置詞を使うことができます。

```json
{
    "autoload": {
        "psr-4": { "": "src/" }
    }
}
```

#### PSR-0

`psr-0`キーの配下では名前空間からパスへの対応付けを定義します。このパスはパッケージのルートから相対的です。なおこれはPEARの様式の名前空間が付いていない変換にも対応しています。

注意していただきたいのは、自動読み込み器が厳密に応答するよう、名前空間の宣言が`\\`で終わらないようにすべきということです。例えば`Foo`は`FooBar`に照合してしまうため、後ろにバックスラッシュを付けると問題が解決するでしょう。`Foo\\`と`FooBar\\`は独立しています。

PSR-0の参照はinstallやupdateの際に全て単一のキー=>配列値に束ねられます。これは生成されたファイル`vendor/composer/autoload_namespaces.php`で確認できます。

例：

```json
{
    "autoload": {
        "psr-0": {
            "Monolog\\": "src/",
            "Vendor\\Namespace\\": "src/",
            "Vendor_Namespace_": "src/"
        }
    }
}
```

複数のディレクトリで同じ前置詞を検索する必要がある場合は、以下のように配列として指定することができます。

```json
{
    "autoload": {
        "psr-0": { "Monolog\\": ["src/", "lib/"] }
    }
}
```

PSR-0の様式は名前空間の宣言のみに留まらず、クラス水準にまで指定することができます。これは大域的な名前空間でただ1つのクラスを持つライブラリについては便利かもしれません。例えばphpのソースファイルがパッケージのルートに位置している場合、このように宣言することができます。

```json
{
    "autoload": {
        "psr-0": { "UniqueGlobalClass": "" }
    }
}
```

どの名前空間にもなれるフォールバックディレクトリを持たせたければ、次のような空の前置詞を使うことができます。

```json
{
    "autoload": {
        "psr-0": { "": "src/" }
    }
}
```

#### クラスマップ

`classmap`参照はinstall/update中に単一のキー=>バリュー配列に全て束ねられ、`vendor/composer/autoload_classmap.php`にファイルが生成されます。この対応付けは与えられたディレクトリやファイルにある全ての`.php`または`.inc`ファイル中のクラスを読み取ることによって構築されます。

クラスマップ生成を使ってPSR-4に従わない全てのライブラリ用の自動読み込み器を定義することができます。これを設定するにはクラスを検索する全てのディレクトリないしファイルを指定します。

例：

```json
{
    "autoload": {
        "classmap": ["src/", "lib/", "Something.php"]
    }
}
```

クラスマップのパスではワイルドカード (`*`) にも対応しており、任意のディレクトリ名に照合するよう展開されます。

例：

```json
{
    "autoload": {
        "classmap": ["src/addons/*/lib/", "3rd-party/*", "Something.php"]
    }
}
```

#### ファイル

必要に応じて特定のファイルを明示的にrequireしたい場合は`files`自動読み込み機構を使うことができます。これはPHPによって自動読み込みできないPHPの関数を含むパッケージがあるときに便利です。

例：

```json
{
    "autoload": {
        "files": ["src/MyLibrary/functions.php"]
    }
}
```

filesの自動読み込みの規則は`vendor/autoload.php`が含まれたときは常に取り込まれ、ちょうど自動読み込み器が登録されたあとになります。取り込み順序はパッケージの依存関係によります。そのためパッケージAがBに依存している場合、パッケージBにあるファイルが最初に取り込まれます。これはパッケージAのファイルが取り込まれた時点でパッケージBが完全に取り込まれて準備ができているようにするためです。

2つのパッケージが同量の依存関係を持つ、あるいは依存関係がない場合、順番は辞書順になります。

ルートパッケージのfilesは常に最後に読み込まれるため、filesを使って依存関係由来の関数を上書きするために自身を自動読み込みさせることはできません。そうしたい場合はComposerの`vendor/autoload.php`を取り込む*前に*独自の関数を取り込むことをお勧めします。

#### クラスマップからファイルを除外する

クラスマップから何らかのファイルやディレクトリを除外したければ`exclude-from-classmap`プロパティを使うことができます。これは例えば実環境でテストクラスを除外するのに便利かもしれません。最適化された自動読み込み器を構築しているときでもクラスマップから読み飛ばされるからです。

クラスマップ生成器はここで設定されたパスにある全てのファイルを無視します。パスはパッケージのルートディレクトリからの絶対位置にあり、スラッシュ以外の全てに照合する`*`と任意のものに照合する`**`に対応しています。`**`はパスの末尾に暗黙に追加されます。

例：

```json
{
    "autoload": {
        "exclude-from-classmap": ["/Tests/", "/test/", "/tests/"]
    }
}
```

#### 自動読み込み器を最適化する

自動読み込み器がリクエスト時間にかなり無視できない影響があることがあります（沢山のクラスを使う大きなフレームワークではリクエストあたり50-100msです）。この影響を低減する方法についての詳細は[自動読み込み器の最適化についての記事](articles/autoloader-optimization.md)を参照してください。

### autoload-dev <span>（[ルート限定](04-schema.md#root-package)）</span>

この節では開発目的の自動読み込み規則を定義することができます。

テストスートを走らせるのに必要なクラスはメインの自動読み込み規則に含めるべきではありません。実運用や他の人がパッケージを依存関係として使う際に自動読み込み器を汚染するのを避けるためです。

したがって単体試験専用のパスを用意してautoload-dev節内に追加するのは良いことです。

例：

```json
{
    "autoload": {
        "psr-4": { "MyLibrary\\": "src/" }
    },
    "autoload-dev": {
        "psr-4": { "MyLibrary\\Tests\\": "tests/" }
    }
}
```

### include-path

> **時代遅れ**：これは古びたプロジェクトに対応するためだけに存在し、全ての新しいコードでは自動読み込み器の方を使うべきです。そうしたわけでこれは時代遅れなものですが、機能自体はComposerから消えることはきっとないでしょう。

PHPの`include_path`に後付けされるパスのリストです。

例：

```json
{
    "include-path": ["lib/"]
}
```

任意のものです。

### target-dir

> **時代遅れ**：これは古びたPSR-0様式の自動読み込みに対応するためだけに存在しており、全ての新しいコードはtarget-dirなしのPSR-4を使うべきです。PHPの名前空間と共にPSR-0を使っているプロジェクトは代わりにPSR-4への移行が推奨されます。

インストール対象を定義します。

パッケージのルートが名前空間宣言の元にある場合は適切に自動読み込みできません。`target-dir`はこの問題を解決します。

一例はSymfonyです。これにはコンポーネント毎に独立のパッケージがあります。Yamlコンポーネントは`Symfony\Component\Yaml`以下にあります。パッケージルートはその`Yaml`ディレクトリです。自動読み込みできるようにするには、必ず`vendor/symfony/yaml`ではなく`vendor/symfony/yaml/Symfony/Component/Yaml`にインストールされるようにしなければいけません。自動読み込み器が`vendor/symfony/yaml`から読み込めるようにするためです。

そうするために、`autoload`と`target-dir`は以下のように定義されています。

```json
{
    "autoload": {
        "psr-0": { "Symfony\\Component\\Yaml\\": "" }
    },
    "target-dir": "Symfony/Component/Yaml"
}
```

任意のものです。

### minimum-stability <span>([root-only](04-schema.md#root-package))</span>

これは安定性によってパッケージの絞り込みをする既定の挙動を定義します。この既定は`stable`になっているので、`dev`のパッケージに依っている場合は驚くようなことになるのを避けるためにファイルを指定しておくべきです。

各パッケージの全バージョンについて安定性が検査され、`minimum-stability`設定より安定していないものはプロジェクトの依存関係の解決の際に無視されます（なお、`require`ブロック中で指定するバージョン制約中の安定性フラグを使ってパッケージ毎に安定性の要件を指定することもできます（詳細は[パッケージリンク][#package-links]を参照））。

使えるオプションは（安定性の順番で）`dev`、`alpha`、`beta`、`RC`、`stable`です。

### prefer-stable <span>（[ルート限定](04-schema.md#root-package)）</span>

これが有効になっているとき、Composerが互換性のある安定的なパッケージの探索が行えるとき、不安定なものより安定なパッケージをより好むようになります。開発版が必要だったりパッケージでアルファ版しか使えなかったりする場合については、minimum-stabilityが許容するかどうかが考慮された上で選択されます。

有効にするには`"prefer-stable": true`を使ってください。

### repositories <span>（[ルート限定](04-schema.md#root-package)）</span>

独自に使用するパッケージリポジトリです。

既定ではComposerはpackagistリポジトリのみを使います。リポジトリを指定することによってパッケージとどこからでも取得できます。

リポジトリは再帰的に解決されません。メインの`composer.json`に加えることができるだけです。依存関係のリポジトリの`composer.json`にある宣言は無視されます。

以下のリポジトリの種別に対応しています。

* **composer:**
  Composerリポジトリはネットワーク（HTTP、FTP、SSH）越しに提供されている`packages.json`であり、追加の`dist`ないし`source`の情報付きの`composer.json`のリストを含みます。`packages.json`ファイルはPHPのストリームを使って読み込まれます。`options`パラメータを使ってストリームについての追加のオプションを設定することができます。
* **vcs:** パッケージをgit、svn、fossil、hgのリポジトリから取得することができるバージョンコントロールシステムリポジトリです。
* **package:**
  何らのComposer対応がされていないプロジェクトに依存する場合、`package`リポジトリを使ってパッケージの定義を書き下すことができます。基本的に`composer.json`オブジェクトを書き下します。

これらについての詳細な情報については[リポジトリ](05-repositories.md)を参照してください。

例：

```json
{
    "repositories": [
        {
            "type": "composer",
            "url": "http://packages.example.com"
        },
        {
            "type": "composer",
            "url": "https://packages.example.com",
            "options": {
                "ssl": {
                    "verify_peer": "true"
                }
            }
        },
        {
            "type": "vcs",
            "url": "https://github.com/Seldaek/monolog"
        },
        {
            "type": "package",
            "package": {
                "name": "smarty/smarty",
                "version": "3.1.7",
                "dist": {
                    "url": "https://www.smarty.net/files/Smarty-3.1.7.zip",
                    "type": "zip"
                },
                "source": {
                    "url": "https://smarty-php.googlecode.com/svn/",
                    "type": "svn",
                    "reference": "tags/Smarty_3_1_7/distribution/"
                }
            }
        }
    ]
}
```

> **補足：**ここでは順番に意味があります。パッケージを探すとき、Composerは最初から最後までリポジトリを探し、最初に照合したものを拾います。既定ではPackagistが最後に加えられており、つまり独自のリポジトリがPackagistのパッケージより優先されるようにできるということなのです。

JSONオブジェクト記法を使うこともできます。しかしJSONのキーバリュー対は順序なしとして見做されるため一貫した挙動は保証されません。

```json
{
    "repositories": {
        "foo": {
            "type": "composer",
            "url": "http://packages.foo.com"
        }
    }
}
```

### config <span>（[ルート限定](04-schema.md#root-package)）</span>

設定オプションの集合です。プロジェクト限定で使われます。それぞれのオプションについての説明については[設定](06-config.md)を参照してください。

### scripts <span>（[ルート限定](04-schema.md#root-package)）</span>

Composerではスクリプトの使用を通じてインストールの過程の様々な部分でフックを掛けることができます。

イベントについての詳細と例については[スクリプト](articles/scripts.md)を参照してください。

### extra

`scripts`によって消費される任意の追加データです。

これは理論上何でも構いません。スクリプトのイベント制御子中でアクセスするには以下のようにします。

```php
$extra = $event->getComposer()->getPackage()->getExtra();
```

任意のものです。

### bin

バイナリとして扱われるべきファイルの集合で、（設定の）`bin-dir`で使えるようにします。

詳細は[ベンダーバイナリ](articles/vendor-binaries.md)を参照してください。

任意のものです。

### archive

パッケージアーカイブをつくるためのオプションの集合です。

以下のオプションに対応しています。

* **name:**
  アーカイブの基底名を設定できます。既定（設定されていない場合で、かつコマンドライン引数として`--file`が渡されていない場合）では`preg_replace('#[^a-z0-9-_]#i',
  '-', name)`が使われます。

例：

```json
{
    "name": "org/strangeName",
    "archive": {
        "name": "Strange_name"
    }
}
```

* **exclude:**
  除外されるパス用のパターンのリストを設定することができます。パターンの構文は.gitignoreファイルのものと同一です。先頭のびっくりマーク
  (!)
  はそれ以前のパターンが除外していたとしても照合したファイルを含めることになります。先頭のスラッシュはプロジェクトの相対パスの開始部分にのみ照合します。アスタリスクはディレクトリの区切りに展開されません。

例：

```json
{
    "archive": {
        "exclude": ["/foo/bar", "baz", "/*.test", "!/foo/bar/baz"]
    }
}
```

例では`/dir/foo/bar/file`、`/foo/bar/baz`、`/file.php`、`/foo/my.test`を含みますが
`/foo/bar/any`、`/foo/baz`、`/my.test`は除外します。

任意のものです。

### abandoned

このパッケージが放棄されたものかどうかを示します。

真偽値または推奨される代替を指すパッケージ名やURLです。

例：

`"abandoned": true`を使うとこのパッケージが放棄されたことを示します。`"abandoned":
"monolog/monolog"`を使うとこのパッケージが放棄され、推奨される代替が`monolog/monolog`であることが示されます。

既定では偽です。

任意のものです。

### non-feature-branches

数値でないブランチ名の正規表現パターン（例：「latest」など）のリストです。これは機能用ブランチを決して扱いません。これは文字列の配列です。

数値でないブランチ名がある場合、例えば「latest」「current」「latest-stable」などについては、バージョン番号には見えないので、Composerはそうしたブランチを機能用ブランチとして制御します。これはつまりバージョンや特別なブランチ（masterなど）で終わっているような親ブランチを探し、ルートパッケージのバージョン数が親ブランチのバージョンまたは少なくともmasterなどになるということです。

数値でない名前のブランチを、妥当なバージョンやmasterのような特別なブランチ名の親ブランチを探す代わりに、バージョンとして扱うようにするには、開発版ブランチとして制御されるべきブランチ名のパターンを設定することができます。

これは「self.version」を使う依存関係があるときは本当に便利です。このときdev-masterでなくとも同じブランチがインストールされます（例：latest-testing）。

一例：

テストブランチがある場合で、そのブランチがテストフェーズで手厚く維持管理されステージング環境にデプロイされるのであれば、通常`composer show
-s`とすると`versions : * dev-master`になります。

機能用ブランチではないもの用に`latest-.*`をパターンとして設定する場合はこのようにします。

```json
{
    "non-feature-branches": ["latest-.*"]
}
```

それから`composer show -s`とすると`versions : * dev-latest-testing`になります。

任意のものです。

&larr; [コマンドラインインターフェース](03-cli.md)  | [リポジトリ](05-repositories.md) &rarr;
