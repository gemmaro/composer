# composer.jsonのスキーマ

この章では`composer.json`で利用できる全てのフィールドについて説明します。

## JSONスキーマ

形式をドキュメント化する[JSON
schema](https://json-schema.org)があり、`composer.json`を検証するのにも使えます。実際、`validate`コマンドによって使われています。
https://getcomposer.org/schema.json から取得できます。

## 根幹パッケージ

根幹パッケージとは、`composer.json`でプロジェクトの根幹に定義されたパッケージのことです。
プロジェクトの要件を定義しているのが主眼の`composer.json`なのです。

フィールドの中には根幹パッケージの文脈でのみ適用されるものがあります。
この一例は`config`フィールドです。
根幹パッケージのみが設定を定義できます。
依存関係の設定は無視されます。
このようにして`config`フィールドは`root-only`になるのです。

> **補足：**
> パッケージは文脈によって根幹パッケージになったりならなかったりします。
> 例えばプロジェクトが`monolog`ライブラリに依存している場合、そのプロジェクトは根幹パッケージです。
> しかしもし不具合修正のためにGitHubから`monolog`をクローンしてきたとすれば、`monolog`が根幹パッケージになります。

## プロパティ

### name

パッケージ名です。ベンダー名とプロジェクト名から構成され、`/`で区切られます。例えば：

* monolog/monolog
* igorw/event-source

名前は小文字で、単語は`-`や`.`や`_`で区切られていなくてはなりません。
名前全体は`^[a-z0-9]([_.-]?[a-z0-9]+)*/[a-z0-9](([_.]|-{1,2})?[a-z0-9]+)*$`に照合します。

`name`プロパティは公開されるパッケージ（ライブラリ）には必須です。

> **補足：** Composerのバージョン2.0より前は、名前には空白込みでどんな文字も含められました。

### description

パッケージの短い説明です。
大抵1行分の長さです。

公開されるパッケージ（ライブラリ）には必須です。

### version

パッケージのバージョンです。
殆どの場合は必須でなく、省略すべきです（後述）。

`X.Y.Z`や`vX.Y.Z`の形式に従っていなければなりません。
オプションで`-dev`、`-patch` (`-p`)、`-alpha` (`-a`)、`-beta`
(`-b`)、`-RC`を接尾辞に付けても構いません。
また、patch、alpha、beta、RCの接尾辞には数字を続けても大丈夫です。

例：

- 1.0.0
- 1.0.2
- 1.1.0
- 0.2.5
- 1.0.0-dev
- 1.0.0-alpha3
- 1.0.0-beta2
- 1.0.0-RC5
- v2.0.4-p1

パッケージのリポジトリのどこかしらからバージョンが推測できるのであれば、このプロパティはオプションです。
例えばVCSリポジトリのVCSのタグ名などです。
その場合は省略することが推奨されます。

> **補足：** PackagistはVCSリポジトリを使うため、上の記載はPackagistにも全く同じことが言えます。
> 自分でバージョンを指定すると、ほぼ確実にいつか手作業による誤りにより問題が生じることでしょう。

### type

パッケージの種別です。既定は`library`です。

パッケージの種別は独自のインストールの仕組みに使われます。
何らかの特別な仕組みが必要なパッケージがあるとき、`symfony-bundle`、`wordpress-plugin`、`typo3-cms-extension`といった独自の種別を定義できます。
これらの種別は全て特定のプロジェクトに特有のものであって、その種別のパッケージのインストールができるようなインストーラを提供する必要があります。

その中でも特にComposerは4つの種別に対応しています。

- **library:**
  既定です。
  ファイルを`vendor`に複製します。
- **project:**
  ライブラリではなくプロジェクトであることを示します。
  例えば[標準版Symfony](https://github.com/symfony/symfony-standard)のようなアプリケーションのシェル、[Silverstripeインストーラ](https://github.com/silverstripe/silverstripe-installer)のようなCMS、あるいはパッケージとして配布される完全なアプリケーションがこれにあたります。
  例として、IDEから新しいワークスペースを作る際に、初期化するプロジェクトの一覧を提供するのに使えます。
- **metapackage:**
  要件を含む空のパッケージでありインストールの条件になりますが、ファイルを含んでおらずファイルシステムに何も書き込まないものです。
  そうしたわけで、インストールできるdistやsourceキーを必要としません。
- **composer-plugin:**
  種別`composer-plugin`のパッケージは独自の種別を持つ他のパッケージのインストーラを提供することがあります。
  詳細は[専門記事](articles/custom-installers.md)を参照してください。
- **php-ext**と**php-ext-zend**：
  これらの名前はCで書かれたPHPの拡張パッケージ用に予約されています。
  これらの種別はPHPで書かれたパッケージ用に使わないでください。

インストール時に独自の仕組みが必要な場合にのみ独自の種別を使ってください。
このフィールドを省略し、既定の`library`にするのがお勧めです。

### keywords

パッケージに関係するキーワードの配列です。検索と絞り込みに使えます。

例：

- logging
- events
- database
- redis
- templating

> **補足**：`--dev`オプション無しで`composer require`するようにし、パッケージを`require`ではなく`require-dev`に追加しても良いか利用者にプロンプトを出す特別なキーワードがあります。
`dev`、`testing`、`static analysis`がそれです。

> **補足**：文字列内で許される文字の範囲には、ユニコードの英数字、空白`" "`、ドット`.`、下線`_`、ダッシュ`-`（正規表現：`'{^[\p{N}\p{L} ._-]+$}u'`）の制限があります。
> その他の文字を使うと、`composer validate`を走らせるときに警告が出ます。
> またパッケージのPackagist.orgへの更新が失敗する原因となります。

省略可能です。

### homepage

プロジェクトのwebサイトへのURLです。

省略可能です。

### readme

readmeドキュメントへの相対パスです。
既定では`README.md`です。

主にパッケージがGitHubにないときに有用です。
GitHubのパッケージの場合、Packagist.orgではGitHub側で検出されたものを取得するreadme APIを使うからです。

省略可能です。

### time

当該バージョンのリリース日です。

`YYYY-MM-DD`または`YYYY-MM-DD HH:MM:SS`の形式で、UTCタイムゾーンでなければなりません。

省略可能です。

### license

パッケージの利用許諾です。
文字列または文字列の配列にできます。

最頻出の利用許諾についての推奨される記法は以下の通り（辞書順）。

- Apache-2.0
- BSD-2-Clause
- BSD-3-Clause
- BSD-4-Clause
- GPL-2.0-only / GPL-2.0-or-later
- GPL-3.0-only / GPL-3.0-or-later
- LGPL-2.1-only / LGPL-2.1-or-later
- LGPL-3.0-only / LGPL-3.0-or-later
- MIT

オプションにはなりますが、このプロパティを付けることは強く推奨されます。他の識別子は[SPDX Open Source License
Registry](https://spdx.org/licenses/)に一覧になっています。

> **Note:**
> ソースが閉鎖的なソフトウェアについては、利用許諾の識別子として `"proprietary"` を使うことができます。

一例：

```json
{
    "license": "MIT"
}
```

あるパッケージについて、複数の利用許諾から選択できる場合（「離接的利用許諾」）、複数のものを配列として指定できます。

離接的利用許諾の例です。

```json
{
    "license": [
        "LGPL-2.1-only",
        "GPL-3.0-or-later"
    ]
}
```

代わりに「or」で区切って括弧で囲むこともできます。

```json
{
    "license": "(LGPL-2.1-only or GPL-3.0-or-later)"
}
```

これに似ていますが、複数の利用許諾が適用される必要があるときは（「結合的利用許諾」）、「and」で区切って（）で囲むことになります。

### authors

パッケージの作者です。
オブジェクトの配列です。

それぞれの作者オブジェクトは以下のプロパティを持つことができます。

* **name:** 作者名です。大抵は実名です。
* **email:** 作者のEメールアドレスです。
* **homepage:** 作者のwebサイトへのURLです。
* **role:**
  プロジェクトに於ける作者の役割です（例：開発者や翻訳者）

一例：

```json
{
    "authors": [
        {
            "name": "Nils Adermann",
            "email": "naderman@naderman.de",
            "homepage": "https://www.naderman.de",
            "role": "Developer"
        },
        {
            "name": "Jordi Boggiano",
            "email": "j.boggiano@seld.be",
            "homepage": "https://seld.be",
            "role": "Developer"
        }
    ]
}
```

省略可能なプロパティですが、付けることを強く推奨します。

### support

プロジェクトについてのサポートを得るための様々な情報です。

サポート情報には以下が含まれます。

* **email:** サポート用Eメールアドレスです。
* **issues:** 課題管理表へのURLです。
* **forum:** フォーラムへのURLです。
* **wiki:** wikiへのURLです。
* **irc:** <irc://server/channel>のような、サポート用IRCチャンネルです。
* **source:** ソースを閲覧したりダウンロードしたりするURLです。
* **docs:** ドキュメントへのURLです。
* **rss:** RSSフィードへのURLです。
* **chat:** チャットチャンネルへのURLです。
* **security:** 脆弱性公表ポリシー (vulnerability disclosure policy; VDP) へのURLです。

一例：

```json
{
    "support": {
        "email": "support@example.org",
        "irc": "irc://irc.freenode.org/composer"
    }
}
```

省略可能です。

### funding

パッケージの作者が維持管理と新しい機能の開発を行えるよう、投資を提供するためのURLの一覧です。

それぞれの項目は以下のものからなります。

* **type:**
  投資の種別、または投資を行えるプラットフォームです。例えばpatreon、opencollective、tidelift、githubです。
* **url:**
  詳細が記載されたwebサイトへのURLと、パッケージに投資する方法です。

一例：

```json
{
    "funding": [
        {
            "type": "patreon",
            "url": "https://www.patreon.com/phpdoctrine"
        },
        {
            "type": "tidelift",
            "url": "https://tidelift.com/subscription/pkg/packagist-doctrine_doctrine-bundle"
        },
        {
            "type": "other",
            "url": "https://www.doctrine-project.org/sponsorship.html"
        }
    ]
}
```

省略可能です。

### パッケージのリンク

以下の全ては、バージョン制約を介してパッケージ名とパッケージのバージョンを対応付けるオブジェクトを取ります。
バージョンについての詳細は[こちら](articles/versions.md)をお読みください。

例：

```json
{
    "require": {
        "monolog/monolog": "1.0.*"
    }
}
```

全てのリンクは省略可能なフィールドです。

`require`と`require-dev`は追加で*安定性フラグ*（[根幹限定](04-schema.md#root-package)）に対応しています。
"*constraint*@*stability flag*" の形式を取っています。
これらによりパッケージの安定性を、[最小安定性](#minimum-stability)の範疇を超え、更に制限したり拡張したりできます。
こうしたフラグは制約や空の*制約*に適用できます。
後者は例えば依存関係に不安定なパッケージを許容したい場合などです。

例：

```json
{
    "require": {
        "monolog/monolog": "1.0.*@beta",
        "acme/foo": "@dev"
    }
}
```

依存関係のうち、不安定なパッケージに依存しているものがあれば、同様に明示的に必要安定性フラグと共に要件に加えなければなりません。

例：

`doctrine/doctrine-fixtures-bundle`が`"doctrine/data-fixtures":
"dev-master"`を要件としているとすると、根幹のcomposer.jsonの中で以下の2行目を加えて`doctrine/data-fixtures`パッケージの開発版リリースを許容する必要があります。

```json
{
    "require": {
        "doctrine/doctrine-fixtures-bundle": "dev-master",
        "doctrine/data-fixtures": "@dev"
    }
}
```

`require`と`require-dev`は追加で明示的な参照（つまりコミット）に対応しており、たとえ更新を走らせたとしても、開発版のバージョンが与えられた状態で確実に固定されているようにします。
明示的に開発版を要件にして、参照に`#<ref>`を付けたときにのみ動作します。
また[根幹限定](04-schema.md#root-package)の機能であり、依存関係では無視されます。

例：

```json
{
    "require": {
        "monolog/monolog": "dev-master#2eb0c0978d290a1c45346a1955188929cb4e5db7",
        "acme/foo": "1.0.x-dev#abc123"
    }
}
```

> **補足：**
> この機能には厳しい技術的制約があり、composer.jsonのメタデータはハッシュの前に指定されたブランチ名から読み込んでしまいます。
> したがって、この機能は開発時に一時的に取る解決法とするべきです。
> 一時的な問題を矯正するための、タグ付けされたリリースに切り替えるまでの対処法なのです。
> Composerチームはこの機能に活発に対応しておらずこれに関するバグ報告を受け付けません。

パッケージ制約をインラインエイリアスすることも可能で、そうでなければ合致しない制約に合致させられます。詳細については[エイリアスの記事を参照してください](articles/aliases.md)。

`require`と`require-dev`はまた、プロジェクトを正常に走らせるために必要な特定のPHPとPHPの拡張のバージョンとへの参照に対応しています。

例：

```json
{
    "require": {
        "php": ">=7.4",
        "ext-mbstring": "*"
    }
}
```

> **補足：** プロジェクトが要件とするPHP拡張を一覧にすることは重要です。
> PHPのインストールが全て同じようになされるとは限りません。
> 標準と考えている拡張が欠けているものもあるでしょう（例えば`ext-mysqli`は、Fedora/CentOSの最小インストールシステムでは既定ではインストールされません）。
> 必要なPHPの要件を一覧にし損ねると、利用者体験が悪化することに繋がります。
> Composerはパッケージをインストールするときは失敗することなく、実行時に失敗するからです。
> `composer show --platform`コマンドはシステムで利用できる全てのPHP拡張を一覧にします。
> これを使えば、使用する拡張の一覧をコンパイルして要件に加える補助になるでしょう。
> 代えてサードパーティーツールを使ってプロジェクトを解析し、使用されている拡張の一覧が得られるかもしれません。

#### require

このパッケージが必要とするパッケージの対応付けです。
これらの要件が満たされない限り、パッケージはインストールされません。

#### require-dev <span>([根幹限定](04-schema.md#root-package))</span>

このパッケージを開発したり、テストを走らせたりなどするのに必要なパッケージへの対応付けです。
根幹パッケージの開発要件は既定でインストールされます。
`install`と`update`の両方とも`--no-dev`オプションに対応しており、開発依存関係がインストールされるのを阻止できます。

#### conflict

このバージョンのパッケージと競合するパッケージへの対応付けです。
それらのパッケージがこのパッケージと共にインストールされるのを許容しないようにします。

なお、`conflict`リンクで`<1.0 >=1.1`のような範囲を指定する場合、1.0より小さく*且つ*同時に1.1かそれより新しい全てのバージョンと競合しているという意味になります。
恐らくやりたいことではないでしょう。
この場合は`<1.0 || >=1.1`としたいことでしょう。

#### replace

このパッケージが置き換えるパッケージへの対応付けです。
これによりパッケージをフォークし、独自のバージョン番号を持つ異なる名前で公開できます。
また元のパッケージが置き換わっているため、元のパッケージを要件とするパッケージはフォークしたパッケージを使って動作し続けることになります。

副パッケージを含むパッケージについても有用です。
例えば主眼のsymfony/symfonyパッケージには個々のパッケージとしても使える全てのSymfony Componentが含まれています。
主眼のパッケージを要件にすると、自動的に個々のコンポーネントのうち、どれか1つの要件が充足されます。
主眼のパッケージがコンポーネントを置き換えるからです。

上記で説明した副パッケージの目的で置き換えを使う際は忠告があります。
その場合は通常、`self.version`をバージョン制約として使うことで置き換えるだけにしておくべきです。
主眼のパッケージが厳密なバージョンの副パッケージのみを置き換えるようにするためです。
他のバージョンになるとおかしなことになるでしょう。

#### provide

このパッケージにより提供されるパッケージの対応付けです。
これが最も役立つのは、共通化されたインターフェースの実装です。
パッケージは仮想パッケージに依存できます。
例としては`psr/log-implementation`で、このロガーインターフェースを実装する任意のライブラリは`provide`の一覧に加えます。
実装しているパッケージは[Packagist.orgで探せます](https://packagist.org/providers/psr/log-implementation)。

仮想的なパッケージではなく、実際のパッケージの名前で`provide`を使うことは、そのパッケージのコードも世に出ているということを暗示します。
その場合、一般的には`replace`がより良い選択です。
インターフェースを提供して実装を提供する他のパッケージに任せる際（例えばPSRのインターフェース）のよくある慣習は、インターフェースパッケージに対応する仮想パッケージの名前に`-implementation`後置詞を使うことです。

#### suggest

このパッケージを向上させたりいい感じに動かせたりするようなお勧めのパッケージです。
これらは通知のようなもので、パッケージがインストールされた後に表示されます。
利用者にもっとパッケージを加えてもらえるような手掛かりを与えるためのもので、厳密には必要でなかったとしても大丈夫です。

形式は上述のパッケージリンクと同様ですが、値が自由な内容のテキストで、バージョン制約ではない点は異なります。

例：

```json
{
    "suggest": {
        "monolog/monolog": "Allows more advanced logging of the application flow",
        "ext-xml": "Needed to support XML format in class Foo"
    }
}
```

### autoload

PHPの自動読み込み器用の自動読み込みの対応付けです。

[`PSR-4`](https://www.php-fig.org/psr/psr-4/)と[`PSR-0`](http://www.php-fig.org/psr/psr-0/)の自動読み込み、`classmap`生成、`files`による包含に対応しています。

PSR-4はずっと簡単に使えるためお勧めの方法です（クラスを追加したときに自動読み込み器を再生成する必要がありません）。

#### PSR-4

`psr-4`キー配下では名前空間からパスへの対応付けを定義します。
パスはパッケージの根幹から相対的なものです。
`Foo\\Bar\\Baz`のようなクラスを自動読み込みする場合、ディレクトリ`src/`を指す名前空間の前部分`Foo\\`は、自動読み込み器が`src/Bar/Baz.php`という名前のファイルを探索し、もしあれば含めるという意味です。
なお、比較的古いPSR-0の様式とは反対に、前部分 (`Foo\\`) はファイルパスに存在**しません**。

名前空間の前置詞は、似た前置詞との競合を避けるため、`\\`で終わっていなければなりません。
例えば`Foo`は`FooBar`名前空間のクラスに照合するので、後ろにバックスラッシュを付けると問題が解決します。
`Foo\\`と`FooBar\\`は独立しています。

PSR-4の参照は、installやupdateの際に、単一のキー=>バリュー配列に全て結合されます。生成されるファイル`vendor/composer/autoload_psr4.php`で確認できます。

例：

```json
{
    "autoload": {
        "psr-4": {
            "Monolog\\": "src/",
            "Vendor\\Namespace\\": ""
        }
    }
}
```

複数のディレクトリで同じ前置詞を検索する必要がある場合は、以下のように配列として指定できます。

```json
{
    "autoload": {
        "psr-4": { "Monolog\\": ["src/", "lib/"] }
    }
}
```

任意の名前空間が探索されるようなフォールバックディレクトリを持たせたければ、次のように空の前置詞が使えます。

```json
{
    "autoload": {
        "psr-4": { "": "src/" }
    }
}
```

#### PSR-0

`psr-0`キーの配下では名前空間からパスへの対応付けを定義します。
このパスはパッケージの根幹から相対的です。
なお、PEARの様式の名前空間が付いていない変換にも対応しています。

注意していただきたいのは、自動読み込み器が厳密に応答するよう、名前空間の宣言が`\\`で終わるようにすべきということです。
例えば`Foo`は`FooBar`に照合してしまうため、後ろにバックスラッシュを付けると問題が解決するでしょう。
`Foo\\`と`FooBar\\`は独立しています。

PSR-0の参照はinstallやupdateの際に全て単一のキー=>配列値に束ねられます。
生成されたファイル`vendor/composer/autoload_namespaces.php`で確認できます。

例：

```json
{
    "autoload": {
        "psr-0": {
            "Monolog\\": "src/",
            "Vendor\\Namespace\\": "src/",
            "Vendor_Namespace_": "src/"
        }
    }
}
```

複数のディレクトリで同じ前置詞を検索する必要がある場合は、以下のように配列として指定できます。

```json
{
    "autoload": {
        "psr-0": { "Monolog\\": ["src/", "lib/"] }
    }
}
```

PSR-0の様式は名前空間の宣言のみに留まらず、クラス水準にまで指定できます。
大域的な名前空間で、ただ1つのクラスを持つライブラリについては便利かもしれません。
例えばphpのソースファイルがパッケージの根幹に位置している場合、このように宣言できます。

```json
{
    "autoload": {
        "psr-0": { "UniqueGlobalClass": "" }
    }
}
```

どの名前空間にもなれるフォールバックディレクトリを持たせたければ、次のような空の前置詞を使うことができます。

```json
{
    "autoload": {
        "psr-0": { "": "src/" }
    }
}
```

#### クラスマップ

`classmap`参照はinstall/update中に単一のキー=>バリュー配列に全て束ねられ、`vendor/composer/autoload_classmap.php`にファイルが生成されます。この対応付けは与えられたディレクトリやファイルにある全ての`.php`または`.inc`ファイル中のクラスを読み取ることによって構築されます。

クラスマップ生成を使ってPSR-4に従わない全てのライブラリ用の自動読み込み器を定義できます。
これを設定するには、クラスを検索する全てのディレクトリないしファイルを指定します。

例：

```json
{
    "autoload": {
        "classmap": ["src/", "lib/", "Something.php"]
    }
}
```

クラスマップのパスではワイルドカード (`*`) にも対応しており、任意のディレクトリ名に照合するよう展開されます。

例：

```json
{
    "autoload": {
        "classmap": ["src/addons/*/lib/", "3rd-party/*", "Something.php"]
    }
}
```

#### ファイル

必要に応じて特定のファイルを明示的にrequireしたい場合は、`files`自動読み込み機構を使うことができます。
PHPによって自動読み込みできないPHPの関数を含むパッケージがあるときに便利です。

例：

```json
{
    "autoload": {
        "files": ["src/MyLibrary/functions.php"]
    }
}
```

filesの自動読み込みの規則は`vendor/autoload.php`が含まれたときは常に取り込まれ、ちょうど自動読み込み器が登録された後になります。
取り込み順序はパッケージの依存関係によります。
そのためパッケージAがBに依存している場合、パッケージBにあるファイルが最初に取り込まれます。
パッケージAのファイルが取り込まれた時点でパッケージBが完全に取り込まれて準備ができているようにするためです。

2つのパッケージが同量の依存関係を持つ、あるいは依存関係がない場合、順番は辞書順になります。

根幹パッケージのfilesは常に最後に読み込まれるため、filesを使って依存関係由来の関数を上書きするために自身を自動読み込みさせることはできません。
そうしたい場合はComposerの`vendor/autoload.php`を取り込む*前に*独自の関数を取り込むことをお勧めします。

#### クラスマップからファイルを除外する

クラスマップから何らかのファイルやディレクトリを除外したければ`exclude-from-classmap`プロパティを使うことができます。
例えば、実環境でテストクラスを除外するのに便利かもしれません。
最適化された自動読み込み器を構築しているときでも、クラスマップから読み飛ばされるからです。

クラスマップ生成器はここで設定されたパスにある全てのファイルを無視します。
パスはパッケージの根幹ディレクトリからの絶対位置にあり、スラッシュ以外の全てに照合する`*`と任意のものに照合する`**`に対応しています。
`**`はパスの末尾に暗黙に追加されます。

例：

```json
{
    "autoload": {
        "exclude-from-classmap": ["/Tests/", "/test/", "/tests/"]
    }
}
```

#### 自動読み込み器を最適化する

自動読み込み器がリクエスト時間にかなり無視できない影響があることがあります（沢山のクラスを使う大きなフレームワークではリクエストあたり50-100msです）。
この影響を低減する方法についての詳細は[自動読み込み器の最適化についての記事](articles/autoloader-optimization.md)を参照してください。

### autoload-dev <span>（[根幹限定](04-schema.md#root-package)）</span>

この節では開発目的の自動読み込み規則を定義できます。

テストスートを走らせるのに必要なクラスは、主眼のの自動読み込み規則に含めるべきではありません。
実運用や他の人がパッケージを依存関係として使う際に、自動読み込み器を汚染するのを避けるためです。

したがって単体試験専用のパスを用意してautoload-dev節内に追加するのは良いことです。

例：

```json
{
    "autoload": {
        "psr-4": { "MyLibrary\\": "src/" }
    },
    "autoload-dev": {
        "psr-4": { "MyLibrary\\Tests\\": "tests/" }
    }
}
```

### include-path

> **時代遅れ** ：
古びたプロジェクトに対応するためだけに存在し、全ての新しいコードでは自動読み込み器の方を使うべきです。
そうしたわけで時代遅れなものですが、機能自体はComposerから消えることはきっとないでしょう。

PHPの`include_path`に後付けされるパスのリストです。

例：

```json
{
    "include-path": ["lib/"]
}
```

省略可能です。

### target-dir

> **時代遅れ** ：
> 古びたPSR-0様式の自動読み込みに対応するためだけに存在しており、全ての新しいコードはtarget-dir無しのPSR-4を使うべきです。
> PHPの名前空間と共にPSR-0を使っているプロジェクトは代わりにPSR-4への移行が推奨されます。

インストール対象を定義します。

パッケージの根幹が名前空間宣言の元にある場合は適切に自動読み込みできません。
`target-dir`はこの問題を解決します。

一例はSymfonyです。これにはコンポーネント毎に独立のパッケージがあります。
Yamlコンポーネントは`Symfony\Component\Yaml`以下にあります。
パッケージの根幹はその`Yaml`ディレクトリです。
自動読み込みできるようにするには、必ず`vendor/symfony/yaml`ではなく`vendor/symfony/yaml/Symfony/Component/Yaml`にインストールされるようにしなければいけません。
自動読み込み器が`vendor/symfony/yaml`から読み込めるようにするためです。

そうするために、`autoload`と`target-dir`は以下のように定義されています。

```json
{
    "autoload": {
        "psr-0": { "Symfony\\Component\\Yaml\\": "" }
    },
    "target-dir": "Symfony/Component/Yaml"
}
```

省略可能です。

### minimum-stability <span>([根幹限定](04-schema.md#root-package))</span>

安定性によってパッケージの絞り込みをする既定の挙動を定義します。
この既定は`stable`になっているので、`dev`のパッケージに依っている場合は、驚くようなことになるのを避けるためにファイルを指定しておくべきです。

各パッケージの全バージョンについて安定性が検査され、`minimum-stability`設定より安定していないものは、プロジェクトの依存関係の解決の際に無視されます（なお、`require`ブロック中で指定するバージョン制約中の安定性フラグを使って、パッケージ毎に安定性の要件を指定することもできます（詳細は[パッケージリンク](#package-links)を参照））。

使えるオプションは（安定性の順番で）`dev`、`alpha`、`beta`、`RC`、`stable`です。

### prefer-stable <span>（[根幹限定](04-schema.md#root-package)）</span>

これが有効になっているとき、互換性のある安定的なパッケージが使える場合に、不安定なものより安定なパッケージを贔屓します。
開発版が必要だったりパッケージでアルファ版しか使えなかったりする場合については、minimum-stabilityが許容するかどうかが考慮された上で選択されます。

有効にするには`"prefer-stable": true`を使ってください。

### repositories <span>（[根幹限定](04-schema.md#root-package)）</span>

独自に使用するパッケージリポジトリです。

既定ではComposerはpackagistリポジトリのみを使います。
リポジトリを指定することによって、パッケージをどこからでも取得できます。

リポジトリは再帰的に解決されません。
主眼の`composer.json`に加えることができるだけです。
依存関係のリポジトリの`composer.json`にある宣言は無視されます。

以下のリポジトリの種別に対応しています。

* **composer:**
  Composerリポジトリはネットワーク（HTTP、FTP、SSH）越しに提供されている`packages.json`であり、追加の`dist`ないし`source`の情報付きの`composer.json`のリストを含みます。
  `packages.json`ファイルはPHPのストリームを使って読み込まれます。
  `options`パラメータを使ってストリームについての追加のオプションを設定できます。
* **vcs:** パッケージをgit、svn、fossil、hgのリポジトリから取得できるバージョン管理システムリポジトリです。
* **package:**
  何らのComposer対応がされていないプロジェクトに依存する場合、`package`リポジトリを使ってパッケージの定義を書き下すことができます。基本的に`composer.json`オブジェクトを書き下します。

これらについての詳細な情報については[リポジトリ](05-repositories.md)を参照してください。

例：

```json
{
    "repositories": [
        {
            "type": "composer",
            "url": "http://packages.example.com"
        },
        {
            "type": "composer",
            "url": "https://packages.example.com",
            "options": {
                "ssl": {
                    "verify_peer": "true"
                }
            }
        },
        {
            "type": "vcs",
            "url": "https://github.com/Seldaek/monolog"
        },
        {
            "type": "package",
            "package": {
                "name": "smarty/smarty",
                "version": "3.1.7",
                "dist": {
                    "url": "https://www.smarty.net/files/Smarty-3.1.7.zip",
                    "type": "zip"
                },
                "source": {
                    "url": "https://smarty-php.googlecode.com/svn/",
                    "type": "svn",
                    "reference": "tags/Smarty_3_1_7/distribution/"
                }
            }
        }
    ]
}
```

> **補足：** ここでは順番に意味があります。
> パッケージを探すとき、Composerは最初から最後までリポジトリを探し、最初に照合したものを拾います。
> 既定ではPackagistが最後に加えられており、つまり独自のリポジトリがPackagistのパッケージより優先されるのです。

JSONオブジェクト記法を使うこともできます。
しかしJSONのキーバリュー対は順序なしとして見做されるため、一貫した挙動は保証されません。

```json
{
    "repositories": {
        "foo": {
            "type": "composer",
            "url": "http://packages.foo.com"
        }
    }
}
```

### config <span>（[根幹限定](04-schema.md#root-package)）</span>

設定オプションの集合です。プロジェクト限定で使われます。それぞれのオプションについての説明については[設定](06-config.md)を参照してください。

### scripts <span>（[根幹限定](04-schema.md#root-package)）</span>

Composerではスクリプトの使用を通じてインストールの過程の様々な部分でフックを掛けることができます。

イベントについての詳細と例については[スクリプト](articles/scripts.md)を参照してください。

### extra

`scripts`によって消費される任意の追加データです。

理論上何でも構いません。
スクリプトのイベント制御子中でアクセスするには以下のようにします。

```php
$extra = $event->getComposer()->getPackage()->getExtra();
```

省略可能です。

### bin

バイナリとして扱われるべきファイルの集合で、（設定の）`bin-dir`で使えるようにします。

詳細は[ベンダーバイナリ](articles/vendor-binaries.md)を参照してください。

省略可能です。

### archive

パッケージアーカイブをつくるためのオプションの集合です。

以下のオプションに対応しています。

* **name:**
  アーカイブの基底名を設定できます。既定（設定されていない場合で、かつコマンドライン引数として`--file`が渡されていない場合）では`preg_replace('#[^a-z0-9-_]#i',
  '-', name)`が使われます。

例：

```json
{
    "name": "org/strangeName",
    "archive": {
        "name": "Strange_name"
    }
}
```

* **exclude:** 除外されるパス用のパターンのリストを設定できます。
  パターンの構文は.gitignoreファイルのものと同一です。
  先頭のびっくりマーク (!) はそれ以前のパターンが除外していたとしても照合したファイルを含めることになります。
  先頭のスラッシュはプロジェクトの相対パスの開始部分にのみ照合します。
  アスタリスクはディレクトリの区切りに展開されません。

例：

```json
{
    "archive": {
        "exclude": ["/foo/bar", "baz", "/*.test", "!/foo/bar/baz"]
    }
}
```

例では`/dir/foo/bar/file`、`/foo/bar/baz`、`/file.php`、`/foo/my.test`を含みますが、`/foo/bar/any`、`/foo/baz`、`/my.test`は除外します。

省略可能です。

### abandoned

このパッケージが放棄されたものかどうかを示します。

真偽値または推奨される代替を指すパッケージ名やURLです。

例：

`"abandoned": true`を使うと、このパッケージが放棄されたことを示します。
`"abandoned":
"monolog/monolog"`を使うと、このパッケージが放棄され、推奨される代替が`monolog/monolog`であることが示されます。

既定では偽です。

省略可能です。

### _comment

コメントを入れておく場所として使える最上位のキーです（文字列または文字列の配列にできます）。

```json
{
    "_comment": [
        "パッケージfoo/barはビジネスロジックに必要でした",
        "foo/barを削除するときはfoo/bazパッケージを削除してください"
    ]
}
```

既定では空です。

省略可能です。

### non-feature-branches

数値でないブランチ名の正規表現パターン（例：「latest」など）のリストです。
機能用ブランチを決して扱いません。
文字列の配列です。

数値でないブランチ名がある場合、例えば「latest」「current」「latest-stable」などについては、バージョン番号には見えないので、Composerはそうしたブランチを機能用ブランチとして制御します。
つまりバージョンや特別なブランチ（masterなど）で終わっているような親ブランチを探し、根幹パッケージのバージョン数が親ブランチのバージョンまたは少なくともmasterなどになるということです。

数値でない名前のブランチを、妥当なバージョンやmasterのような特別なブランチ名の親ブランチを探す代わりに、バージョンとして扱うようにするには、開発版ブランチとして制御されるべきブランチ名のパターンを設定できます。

「self.version」を使う依存関係があるときは本当に便利です。
このときdev-masterでなくとも同じブランチがインストールされます（例：latest-testing）。

一例：

テストブランチがある場合で、そのブランチがテストフェーズで手厚く維持管理され、ステージング環境にデプロイされるのであれば、通常`composer
show -s`とすると`versions : * dev-master`になります。

機能用ブランチではないもの用に`latest-.*`をパターンとして設定する場合はこのようにします。

```json
{
    "non-feature-branches": ["latest-.*"]
}
```

それから`composer show -s`とすると`versions : * dev-latest-testing`になります。

省略可能です。

&larr; [コマンドラインインターフェース](03-cli.md)  | [リポジトリ](05-repositories.md) &rarr;
