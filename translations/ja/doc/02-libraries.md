# ライブラリ

この章では、ライブラリをComposerでインストールできるようにする方法をお話します。

## 全てのプロジェクトはパッケージである

`composer.json`をディレクトリに配置した時点で、そのディレクトリはパッケージとなります。
[`require`](04-schema.md#require)をプロジェクトに追加する場合は他のパッケージに依存したパッケージを作っています。
プロジェクトとライブラリの唯一の違いは、プロジェクトは名前のないパッケージだということです。

インストール可能なパッケージを作成するためには名前をつける必要があります。
これには`composer.json`に[`name`プロパティ](04-schema.md#name)を追加してください。

```json
{
    "name": "acme/hello-world",
    "require": {
        "monolog/monolog": "1.0.*"
    }
}
```

この例では、プロジェクト名は`acme/hello-world`です。
`acme`はベンダー名です。
ベンダー名を与えることは必須です。

> **注意：** もしベンダー名に何をつけていいかわからない場合は、大抵は自分のGitHubの利用者名をつけるといいでしょう。
> パッケージ名は全て小文字でなければならず、単語の区切りはダッシュにするのが慣習です。

## ライブラリのバージョン

まず間違いなくgit, svn, hg, fossilといった何らかの類のバージョン管理システムを使ってライブラリを管理することでしょう。
こうした場合ComposerはVCSからバージョンを推定するので`composer.json`ファイルではバージョンを指定すべきでは**ありません**（ComposerがVCSのブランチとタグを使ってバージョン制約を解決する方法について学ぶためには[バージョンについての記事](articles/versions.md)を参照してください）。

パッケージの管理を手作業でしている（つまりVCSなし）場合、`composer.json`ファイルに`version`値を加えることでバージョンを明示的に指定する必要があるでしょう。

```json
{
    "version": "1.0.0"
}
```

> **補足：** VCSに埋め込まれたバージョンを加えた場合、バージョンはタグ名と干渉することでしょう。そうするとComposerはバージョン値を決定できなくなります。

### VCSのバージョン管理

ComposerはVCSのブランチとタグの機能を使って[`require`](04-schema.md#require)フィールドで指定したバージョン制約を特定のファイルの集まりまで解決します。
利用できる妥当なバージョンを決定する際、Composerは全てのタグとブランチを見てそれらの名前を内部的なオプションの一覧に翻訳し、それから与えられたバージョン制約に対して照合します。

Composerがタグとブランチを扱う方法とパッケージのバージョン制約を解決する方法についての詳細は[バージョン](articles/versions.md)の記事をお読みください。

## ロックファイル

お望みならライブラリに`composer.lock`ファイルをコミットできます。
これはチームが常に同じ依存バージョンでテストする際の助けになります。
しかし、このロックファイルはこれに依存している他のプロジェクトにいかなる影響ももたらしません。
これはメインのプロジェクトのみに影響します。

もしロックファイルをコミットしたくなくて、且つgitを使っている場合は、`.gitignore`に追加してください。

## VCSに公開する

`composer.json`ファイルを含むVCSリポジトリ（バージョン管理システム、例えばgit）があれば、ライブラリはすでにcomposerでインストール可能です。
この例ではGitHubで`acme/hello-world`ライブラリを`github.com/username/hello-world`として公開するとしましょう。

それでは`acme/hello-world`パッケージのインストールを試すためにローカルに新しいプロジェクトを作成しましょう。
私たちはそれを`acme/blog`とよぶことにします。
このブログは`acme/hello-world`に依存し、それはさらに`monolog/monolog`に依存しています。
これは以下の`composer.json`を含む新しい`blog`ディレクトリを作成することで達成されます。

```json
{
    "name": "acme/blog",
    "require": {
        "acme/hello-world": "dev-master"
    }
}
```

名前はこの場合必須ではありません。
このブログをライブラリとして公開することはないからです。
ここではどの`composer.json`が説明されているのかを明確にするために加えられています。

このブログアプリに依存物`hello-world`の所在を知らせる必要があります。
これにはパッケージのリポジトリ指定をこのブログの`composer.json`に追加します。

```json
{
    "name": "acme/blog",
    "repositories": [
        {
            "type": "vcs",
            "url": "https://github.com/username/hello-world"
        }
    ],
    "require": {
        "acme/hello-world": "dev-master"
    }
}
```

パッケージリポジトリの挙動や他にどのようなタイプが利用できるかについての詳細は、[リポジトリ](05-repositories.md)を参照してください。

これで全てです。
Composerの[`install`](03-cli.md#install)コマンドを実行すれば依存関係をインストールできます！

**まとめ：** `composer.json`を含むあらゆるgit/svn/hg/fossilリポジトリはパッケージリポジトリを指定し`require`フィールドで依存関係を宣言することで、プロジェクトに追加できます。

## Packagistに公開する

よろしい、今やパッケージを公開できるようになりました。
しかし、毎回VCSリポジトリを指定するのはやっかいなことです。
全てのユーザにそんなことはさせたくないでしょう。

`monolog/monolog`のためのパッケージリポジトリを指定しなかったこととにお気付きかもしれません。
これはどのような仕組みなのでしょうか？
答えはPackagistです。

[Packagist](https://packagist.org/)はComposerのメインパッケージリポジトリで、 既定で有効になっています。
Packagistで公開されている全てのものは自動的にComposerで利用可能です。
[monologはPackagistにある](https://packagist.org/packages/monolog/monolog)ので、追加のリポジトリ指定なくして依存できるのです。

`hello-world`を世界に共有したければ、同様にPackagistに公開するのが良いでしょう。

[Packagist](https://packagist.org)を開いて"Submit"ボタンを押します。
まだサインアップしていなかったらその旨の表示がされます。
それからVCSリポジトリのURLを送信できます。
送信した時点でPackagistはクローリングを始めます。
完了すると、パッケージは誰でも使えるようになります！

&larr; [基本的な使い方](01-basic-usage.md) |  [コマンドラインインターフェース](03-cli.md) &rarr;
