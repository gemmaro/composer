# 基本的な使い方

## 導入

基礎的な使い方の導入として、ここではログライブラリである`monolog/monolog`をインストールします。
まだComposerをインストールしていなければ、[はじめに](00-intro.md)章を参照してください。

> **補足：** 簡潔のために、この導入ではComposerの[ローカル](00-intro.md#locally)インストールを実施した前提で進めます。

## `composer.json`: プロジェクトの立ち上げ

プロジェクトでComposerを使い始めるにあたって必要なのは`composer.json`ファイルだけです。
このファイルにはプロジェクトの依存関係が記述され、他のメタデータも含まれることがあります。
大抵プロジェクトやVCSリポジトリの最上位ディレクトリにあります。
技術的にはComposerをどこで実行することもできますが、パッケージをPackagist.orgに公開したいならば、VCSリポジトリの一番上の階層にファイルがなければなりません。

### `require`キー

最初に`composer.json`で指定するものは、[`require`](04-schema.md#require)キーです。
Composerにプロジェクトが依存しているパッケージがどれであるかを伝えるものです。

```json
{
    "require": {
        "monolog/monolog": "2.0.*"
    }
}
```

見ての通り、[`require`](04-schema.md#require)は**パッケージ名**（例：`monolog/monolog`）と
**パッケージバージョン**（例：`1.0.*`）を対応付けるオブジェクトを取ります。

Composerはこの情報を使って、[`repositories`](04-schema.md#repositories)キーからパッケージ「リポジトリ」や、既定のパッケージレジストリである[Packagist.org][p]にある正しいファイル一式を探します。
上の例ではこれといったリポジトリは`composer.json`ファイルに登録されていないので、`monolog/monolog`パッケージはPackagist.orgに登録されているものと推定されます（詳細は[Packagistについて](#packagist)と[リポジトリについて](05-repositories.md)を参照）。

[p]: https://packagist.org

### パッケージ名

パッケージ名はベンダー名とプロジェクト名から成ります。
これらはしばしば同一になります。
すなわち、ベンダー名は命名が衝突するのを避けるためだけにあります。
例えば異なる2人の人物が`json`という名前のライブラリを`igorw/json`と`seldaek/json`とそれぞれ命名して作成できます。

詳細は[パッケージの公開とパッケージの命名](02-libraries.md)を読んでください（なお「プラットフォームパッケージ」を依存関係として指定することも可能で、サーバーのソフトウェアの特定のバージョンを要求できます。
[プラットフォームパッケージ](#platform-packages)で後述します）。

### パッケージバージョン制約

先の例ではバージョン制約[`2.0.*`][v2]のMonologパッケージを要求しています。
これが意味するものは`2.0`の開発ブランチの任意のバージョン、言い換えると2.0以上で2.1より小さい（`>=2.0 <2.1`）任意のバージョンのことを指します。

[v2]: https://semver.mwl.be/#?package=monolog%2Fmonolog&version=2.0.*

バージョンとバージョン間の関連、バージョン制約についてのより詳しい情報は[バージョン][v]を読んでください。

[v]: articles/versions.md

> **どうやってComposerは正しいファイルをダウンロードしているのか。**
> `composer.json`に依存関係を指定したとき、Composerはまず、[`repositories`](04-schema.md#repositories)キーを使って登録された全てのリポジトリを対象に要求されたパッケージの名前を検索します。
> もし1つも追加でリポジトリを登録していなかったり、指定したリポジトリにその名前のパッケージがなかったときは、Packagist.org（[後述](#packagist)）に落ち着きます。
>
> ComposerがPackagist.orgないし指定したリポジトリで正しいパッケージがあったときは、パッケージのVCSのバージョン機能（つまりブランチとタグ）を使って、指定したバージョン制約に最も合致するものを見付け出そうとします。
> 必ず[バージョンについての記事](articles/versions.md)でバージョンとパッケージについて読んでください。

> **補足：** もしパッケージを要求したもののComposerがパッケージの安定性の理由で例外を投げた場合は、指定したバージョンが既定の最小の安定要件に見合わない可能性があります。
> VCSで妥当なパッケージバージョンを探す際、既定では安定リリースのみが考慮されます。
>
> パッケージの開発版、アルファ版、ベータ版、リリース候補のバージョンを要求しようとしたときに、この例外に遭遇するかもしれません。
> 安定性フラグと`minimum-stability`キーについての詳細は[スキーマのページ](04-schema.md)をお読みください。

## 依存物をインストール

定義された依存関係をプロジェクトに初めてインストールするときは、[`update`][u]コマンドを走らせると良いです。

[u]: 03-cli.md#update-u

```shell
php composer.phar update
```

こうするとComposerは2つのことをします。

- `composer.json`ファイルに挙げられている全ての依存関係を解決して、全てのアッケージとその厳密なバージョンを`composer.lock`ファイルに書き込みます。
  このファイルによりプロジェクトが特定のバージョンに固定されます。
  `composer.lock`ファイルはプロジェクトのリポジトリにコミットすべきです。
  そうすればプロジェクトに参画する全員にとって、同じバージョンの依存関係に固定されたものになります（詳細は後述）。
  これが`update`コマンドの主な役割です。
- それから暗黙裡に[`install`](03-cli.md#install-i)コマンドが走ります。
  これにより依存関係のファイルがプロジェクトの`vendor`ディレクトリにダウンロードされます（`vendor`ディレクトリはプロジェクトの全てのサードパーティコード用の定番の場所です）。
  上の例では最終的にMonologのソースファイルが`vendor/monolog/monolog`にあることになります。
  Monologには`psr/log`への依存関係があるため、そのパッケージのファイルもまた`vendor/`の中にあります。

> **コツ：** gitをプロジェクトで使っているのなら、多分`.gitignore`に`vendor`を追加したいでしょう。
> 実際のところ、バージョン管理されたリポジトリにサードパーティ製のコード全てを追加したくはないので。

### `composer.lock`ファイルをバージョン管理にコミットすること

このファイルをバージョン管理にコミットすることは大事です。
なぜならこうすることでプロジェクトの準備をする誰もが、自分が使っているものと全く同じバージョンの依存関係を使えるようになるからです。
CIサーバ、実運用マシン、チーム内の他の開発者、万物万人が同じ依存関係で実行するのです。
これにより特定のデプロイでのみ影響する潜在的なバグが低減されます。
たとえ一人で開発していて、6箇月経ってからプロジェクトを再インストールしたとしても、そして依存関係が多くの新しいバージョンをリリースされていたとしても、インストールされた依存関係がちゃんと動くことは疑いありません（`update`コマンドの使用については以下の補足を参照してください）。

> **補足：** ライブラリの場合、ロックファイルのコミットは不必要です。
> [ライブラリ - ロックファイル](02-libraries.html#lock-file)も参照してください。

### `composer.lock`からインストールする

既に`composer.lock`ファイルがプロジェクトフォルダにあるなら、それは前に自分で`update`コマンドを走らせたか、プロジェクトの誰かが`update`コマンドを走らせて`composer.lock`ファイルをプロジェクトにコミットしたからかのどちらかです（いいことです）。

何れにせよ、`composer.lock`ファイルが存在しているときに`install`を走らせると`composer.lock`に挙がっている全ての依存関係を解決してインストールします。
その際はプロジェクトの作業をしている人全員にとってパッケージのバージョンが必ず一貫したものになるように、Composerは`composer.lock`に挙げられた厳密なバージョンを使用します。
結果として`composer.json`ファイルで要求された全ての依存関係が取得されるのですが、必ずしも利用できるごく最新のバージョンとはなっていないかもしれません（ファイルが作成された後に、`composer.lock`ファイルで挙げられた依存関係のより新しいバージョンがリリースされる可能性があります）。
これは設計上意図されたものであり、依存関係での予期しない変更による不具合がプロジェクトで絶対に発生しないようになっています。

そのためVCSリポジトリから新しい変更を取得したあとは、Composerの`install`を走らせて、vendorディレクトリが`composer.lock`ファイルと同期していることを確かめることをお勧めします。

```shell
php composer.phar install
```

Composerは既定で再生成可能な構築を有効にします。
つまり同じコマンドを複数回走らせると、自動読み込み器のファイルを含め、（*タイムスタンプ以外*）同値なファイルを含む`vendor/`ディレクトリを生成するのです。
厳密な検証過程を要求する環境や、PHPアプリケーションを安全で予測可能なやり方でパッケージ化することを目指すLinuxディストリビューションにおいては、特に有益です。

## 最新版に依存関係を更新する

前述したように、`composer.lock`ファイルは自動的に依存関係の最新版が取得されるのを防ぎます。
最新のバージョンに更新するには[`update`](03-cli.md#update-u)コマンドを使います。
こうすると（`composer.json`ファイルに沿うように）照合する最新バージョンを取得して新しいバージョンでロックファイルを更新します。

```shell
php composer.phar update
```

> **補足：** `composer.json`に依存関係解決に影響し得る変更が加えられた後に`composer.lock`が更新されていなければ、`install`コマンドを実行するときに、Composerが警告を表示します。

1つの依存関係をインストール、更新、削除したいだけなら、引数として明示的に列挙できます。

```shell
php composer.phar update monolog/monolog [...]
```

## Packagist

[Packagist](https://packagist.org/)はメインのComposerリポジトリです。
Composerリポジトリは基本的にはパッケージの源です。
つまりパッケージを取ってくることができる場所のことです。
Packagistは全ての人が利用できる中央リポジトリであることを目指しています。
要はここで利用できるいかなるパッケージも自動的に`require`できるということです。
Composerがパッケージを探す場所を追加で指定しなくて良いのです。

[packagistのWebサイト][p]では、パッケージを閲覧したり検索したりできます。

[p]: https://packagist.org/

Composerを使っているオープンソースプロジェクトはパッケージをPackagist上で公開するべきです。
Composerを使う上で、ライブラリをPackagistに載せる必要はありません。
しかし公開することで、他の開発者がより素早くパッケージを発見して取り入れられるようになります。

## プラットフォームパッケージ

Composerにはプラットフォームパッケージがあります。
システムにインストールされる仮想的なパッケージで、実際にはComposerではインストールされないものを指します。
PHP自身やPHP拡張、システムライブライリが含まれます。

* `php`は利用者のPHPバージョンを表しており、`^7.1`のような制約を適用できます。
  PHPの64bitバージョンを要求するには、`php-64bit`パッケージを指定できます。

* `hhvm`はHHVMランタイムのバージョンを表しており、`^2.3`のように制約を適用できます。

* `ext-<name>`とすることでPHPの拡張を要件にできます（中核拡張を含みます）。
  バージョニングはかなり一貫性がないことがあるので、大体の場合は制約に`*`を設定するのと良いです。
  拡張パッケージ名の例は`ext-gd`です。

* `lib-<name>`はPHPで使われるライブラリのバージョンを制約します。
  次のものが利用できます：`curl`, `iconv`, `icu`, `libxml`, `openssl`, `pcre`, `uuid`,
  `xsl`。

[`show --platform`](03-cli.md#show)を使うと、ローカルで利用できるプラットフォームパッケージの一覧が得られます。

## 自動読み込み

自動読み込み情報を指定するライブラリ用に、Composerは`vendor/autoload.php`ファイルを生成します。
単にこのファイルを含めれば、他に手間を掛けずにそれらのライブラリが提供するクラスを使い始められます。

```php
require __DIR__ . '/vendor/autoload.php';

$log = new Monolog\Logger('name');
$log->pushHandler(new Monolog\Handler\StreamHandler('app.log', Monolog\Logger::WARNING));
$log->warning('Foo');
```

`composer.json`に[`autoload`](04-schema.md#autoload)フィールドを追加すれば、自分のコードについても自動読み込み器に追加できます。

```json
{
    "autoload": {
        "psr-4": {"Acme\\": "src/"}
    }
}
```

ここではComposerが[PSR-4][]自動読み込み器を`Acme`名前空間に登録しています。

[PSR-4]: https://www.php-fig.org/psr/psr-4/

名前空間からディレクトリへの対応付けが定義されます。
`src`ディレクトリはプロジェクトルートにあり、同じ階層に`vendor`もあるとしましょう。
ファイル名の例としては`Acme\Foo`クラスを含む`src/Foo.php`があります。

[`autoload`](04-schema.md#autoload)フィールドを追加したあとは、このコマンドを再び走らせなくてはなりません。

```shell
php composer.phar dump-autoload
```

このコマンドは`vendor/autoload.php`ファイルを再生成します。
詳細は[`dump-autoload`](03-cli.md#dump-autoload-dumpautoload-)節を参照してください。

自動読み込みファイルを含めるとautoloaderインスタンスを返します。
そのためインクルード呼び出しの返り値を変数に保持し、さらに名前空間を追加できます。
テストスイート内での自動読み込みクラスに便利です。
例えば以下です。

```php
$loader = require __DIR__ . '/vendor/autoload.php';
$loader->addPsr4('Acme\\Test\\', __DIR__);
```

PSR-4自動読み込みに加えて、ComposerはPSR-0、クラスマップ、ファイル自動読み込みにも対応しています。
詳細は[`autoload`](04-schema.html#autoload)リファレンスを参照してください。

[autoloaderの最適化](articles/autoloader-optimization.md)についてのドキュメントも参照してください。

> **注意：** Composerは自前の自動読み込み器を提供しています。
> もしそれを使いたくない場合は、単に`vendor/composer/autoload_*.php`ファイルを含められます。
> 自前の自動読み込み器を設定できる連想配列を返します。

&larr; [導入](00-intro.md)  |  [ライブラリ](02-libraries.md) &rarr;
