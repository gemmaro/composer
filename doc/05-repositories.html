<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>リポジトリ - Composer</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Composer</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gemmaro/composer" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="リポジトリ"><a class="header" href="#リポジトリ">リポジトリ</a></h1>
<p>この章ではパッケージとリポジトリの概念、利用できるリポジトリの種類に何があるか、そしてどういう仕組みになっているのかを解説します。</p>
<h2 id="概念"><a class="header" href="#概念">概念</a></h2>
<p>リポジトリのそれぞれの存在する種別を見ていく前に、Composerが立脚する基礎概念を理解する必要があります。</p>
<h3 id="パッケージ"><a class="header" href="#パッケージ">パッケージ</a></h3>
<p>Composerは依存関係管理ツールです。
パッケージをローカルにインストールします。
パッケージは本質的には何かを含むディレクトリです。
この場合はその何かがPHPのコードですが、理論上何でも良いわけです。
そしてパッケージの名前とバージョンを持つパッケージの説明を含みます。
名前とバージョンはパッケージを特定するのに使われます。</p>
<p>実際、内部的にはComposerはそれぞれのバージョンを個別のパッケージとして見做します。
この区別はComposerを使っているときは問題になりませんが、Composer自体を変更したいと思ったときはかなり重要になります。</p>
<p>名前とバージョンに加えて有用なメタデータがあります。
インストールに最も関係する情報はソースの定義で、どこかでパッケージの内容を取得するのかを記述します。
パッケージのデータはパッケージの内容を指します。
そしてここで2つの選択肢があります。
distとsourceです。</p>
<p><strong>dist:</strong> distはパッケージデータのパッケージ化されたバージョンです。大抵はリリースバージョンで、中でも大抵は安定リリースです。</p>
<p><strong>source:</strong> ソースは開発に使われます。
大抵gitのようなソースコードリポジトリを起源とします。
ダウンロードされたパッケージを変更したいときはこれを取得できます。</p>
<p>パッケージはこれらの何れか、または両方を与えられます。
利用者により与えられたオプションやパッケージの安定性などの何らかの要因により、どちらかが相応ということになるでしょう。</p>
<h3 id="リポジトリ-1"><a class="header" href="#リポジトリ-1">リポジトリ</a></h3>
<p>リポジトリはパッケージソースで、パッケージとバージョンのリストです。
Composerは全てのリポジトリを見て回り、プロジェクトに必要なパッケージを見付けてきます。</p>
<p>既定ではPackagist.orgリポジトリがComposerに登録されています。<code>composer.json</code>に宣言することでプロジェクトにもっとリポジトリを加えることができます。</p>
<p>リポジトリは根幹パッケージでのみ利用でき、依存関係で定義されたリポジトリは読み込まれません。
なぜそうなっているかを知りたければ<a href="faqs/why-cant-composer-load-repositories-recursively.html">FAQの項目</a>をお読みください。</p>
<p>依存関係解決をするとき、パッケージはリポジトリを上から下への順で見ていき、どこかにパッケージがあったらComposerは他のリポジトリを見るのを止めます。
詳細は<a href="articles/repository-priorities.html">リポジトリの優先度</a>の記事を読んで、この挙動を変える方法を見てください。</p>
<h2 id="種別"><a class="header" href="#種別">種別</a></h2>
<h3 id="composer"><a class="header" href="#composer">composer</a></h3>
<p>主なリポジトリの種別は<code>composer</code>リポジトリです。全てのパッケージメタデータを含む単一の<code>packages.json</code>ファイルを使っています。</p>
<p>packagistが使っているリポジトリの種別でもあります。
<code>composer</code>リポジトリを参照するには、<code>packages.json</code>ファイルの前にパスを与えてください。
packagistの場合、そのファイルは<code>/packages.json</code>に配置されるので、リポジトリのURLは<code>repo.packagist.org</code>となります。
<code>example.org/packages.json</code>についてはリポジトリのURLは<code>example.org</code>になります。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "composer",
            "url": "https://example.org"
        }
    ]
}
</code></pre>
<h4 id="packages"><a class="header" href="#packages">packages</a></h4>
<p>唯一必要なフィールドは<code>packages</code>です。JSONの構造は以下のようなものです。</p>
<pre><code class="language-json">{
    "packages": {
        "vendor/package-name": {
            "dev-master": { @composer.json },
            "1.0.x-dev": { @composer.json },
            "0.0.1": { @composer.json },
            "1.0.0": { @composer.json }
        }
    }
}
</code></pre>
<p><code>@composer.json</code>の印は、最小のものとして含むパッケージのバージョンに由来する<code>composer.json</code>の内容になります。</p>
<ul>
<li>name</li>
<li>version</li>
<li>distまたはsource</li>
</ul>
<p>以下は最小限のパッケージの定義です。</p>
<pre><code class="language-json">{
    "name": "smarty/smarty",
    "version": "3.1.7",
    "dist": {
        "url": "https://www.smarty.net/files/Smarty-3.1.7.zip",
        "type": "zip"
    }
}
</code></pre>
<p><a href="04-schema.html">スキーマ</a>には指定される他のフィールドの何れかを含められます。</p>
<h4 id="notify-batch"><a class="header" href="#notify-batch">notify-batch</a></h4>
<p><code>notify-batch</code>フィールドでは利用者がパッケージをインストールするときに毎回呼ばれるURLを指定できます。
URLは絶対パス（リポジトリと同じドメイン）ないし完全に修飾されたURLです。</p>
<p>値の一例：</p>
<pre><code class="language-json">{
    "notify-batch": "/downloads/"
}
</code></pre>
<p><code>monolog/monolog</code>パッケージを含む<code>example.org/packages.json</code>について、このようにすると以下のJSON要求本文とともに<code>example.org/downloads/</code>へPOST要求を送ります。</p>
<pre><code class="language-json">{
    "downloads": [
        {"name": "monolog/monolog", "version": "1.2.1.0"}
    ]
}
</code></pre>
<p>バージョンフィールドはバージョン数の正規化された表現を含みます。</p>
<p>このフィールドは省略できます。</p>
<h4 id="metadata-urlavailable-packagesavailable-package-patterns"><a class="header" href="#metadata-urlavailable-packagesavailable-package-patterns">metadata-url、available-packages、available-package-patterns</a></h4>
<p><code>metadata-url</code>フィールドでは、リポジトリにある全てのパッケージを提供するURLテンプレートを与えます。
プレースホルダー<code>%package%</code>を含まなければなりません。</p>
<p>このフィールドはComposer
v2で新しく登場したもので、<code>provider-includes</code>と<code>providers-url</code>が両方とも存在する場合、これらより優先されます。
Composer v1とComposer v2両方の互換性のため、理想的には両方とも提供したいでしょう。
しかし新しいリポジトリの実装はv2対応のみに対応しさえすれば良いです。</p>
<p>一例：</p>
<pre><code class="language-json">{
    "metadata-url": "/p2/%package%.json"
}
</code></pre>
<p>Composerがパッケージを探すときは毎回<code>%package%</code>をパッケージ名で置き換え、そのURLを取得します。開発安定性がそのパッケージについて許容される場合、<code>$packageName~dev</code>で再びURLを読み込むことができます（例：<code>/p2/foo/bar~dev.json</code>は<code>foo/bar</code>の開発版を探します）。</p>
<p>パッケージのバージョンを含む<code>foo/bar.json</code>と<code>foo/bar~dev.json</code>ファイルはfoo/barパッケージのバージョンのみを含まなければなりません。<code>{"packages":{"foo/bar":[……ここにバージョン……]}}</code>のような感じです。</p>
<p>キャッシュはIf-Modified-Sinceヘッダを使うことで行われます。ですから必ずLast-Modifiedヘッダを返して正確な内容であるようにしてください。</p>
<p>バージョンの配列は<a href="https://packagist.org/packages/composer/metadata-minifier">composer/metadata-minifier</a>の<code>Composer\MetadataMinifier\MetadataMinifier::minify()</code>を使って最小化することもできます。
もしそうした場合、最上位に<code>"minified": "composer/2.0"</code>キーを付け、Composerにバージョンのリストを展開して元のデータに戻さなければいけないことを示すべきです。
一例として https://repo.packagist.org/p2/monolog/monolog.json を参照してください。</p>
<p>存在しないパッケージを要求されたら404ステータスコードを返さなければなりません。このステータスコードによりComposerにこのパッケージがリポジトリに存在しないことが示されます。404応答は早く返してComposerがブロックされるのを回避するようにしてください。代替の404ページへのリダイレクトは避けてください。</p>
<p>リポジトリにごく少数のパッケージしかなく、404になる要求を避けたければ<code>packages.json</code>にリポジトリに含まれる全てのパッケージ名が配列になった<code>"available-packages"</code>キーを指定することもできます。代わりにパッケージ名のパターンの配列である<code>"available-package-patterns"</code>キーを指定することもできます（<code>*</code>だと任意の文字列に照合します。例：<code>vendor/*</code>ではComposerはこのリポジトリにある全ての照合したパッケージ名を探します）。</p>
<p>このフィールドは省略できます。</p>
<h4 id="providers-api"><a class="header" href="#providers-api">providers-api</a></h4>
<p><code>providers-api</code>フィールドでは与えられたパッケージ名を提供する全てのパッケージ、ただしその名前のパッケージ以外、を返すURLテンプレートを与えられます。
プレースホルダー<code>%package%</code>を含まなければなりません。</p>
<p>例えば https://packagist.org/providers/monolog/monolog.json はmonolog/monologに
"provide" 規則を持つパッケージを一覧にしますが、monolog/monolog自体は一覧に挙がりません。</p>
<pre><code class="language-json">{
    "providers-api": "https://packagist.org/providers/%package%.json",
}
</code></pre>
<p>このフィールドは省略できます。</p>
<h4 id="list"><a class="header" href="#list">list</a></h4>
<p><code>list</code>フィールドでは与えられたフィールド（もしくはフィルタが存在しなければ全ての名前）に照合するパッケージの名前を返せます。
任意で<code>?filter=xx</code>クエリパラメータを受け付けますが、これには任意の部分文字列に照合するワイルドカードとして<code>*</code>を含められます。</p>
<p>replace/provide規則はここでは考慮すべきではありません。</p>
<p>パッケージ名の配列を返さねばなりません。</p>
<pre><code class="language-json">{
    "packageNames": [
        "a/b",
        "c/d"
    ]
}
</code></pre>
<p>例については<a href="https://packagist.org/packages/list.json?filter=composer/*">https://packagist.org/packages/list.json?filter=composer/*</a>を参照してください。</p>
<p>このフィールドは省略できます。</p>
<h4 id="provider-includesとproviders-url"><a class="header" href="#provider-includesとproviders-url">provider-includesとproviders-url</a></h4>
<p><code>provider-includes</code>フィールドでは、このリポジトリから提供されるパッケージ名を一覧にするファイルの集まりを列挙できます。
この場合ハッシュはファイルのsha256になります。</p>
<p><code>providers-url</code>は提供するファイルをサーバーで見付ける方法を記述します。
リポジトリの根幹からの絶対パスです。
<code>%package%</code>と<code>%hash%</code>のプレースホルダーを含まなければいけません。</p>
<p>これらのフィールドは、Composer v1かリポジトリが<code>metadata-url</code>フィールドを設定していない場合に使われます。</p>
<p>一例：</p>
<pre><code class="language-json">{
    "provider-includes": {
        "providers-a.json": {
            "sha256": "f5b4bc0b354108ef08614e569c1ed01a2782e67641744864a74e788982886f4c"
        },
        "providers-b.json": {
            "sha256": "b38372163fac0573053536f5b8ef11b86f804ea8b016d239e706191203f6efac"
        }
    },
    "providers-url": "/p/%package%$%hash%.json"
}
</code></pre>
<p>これらのファイルにはファイルの完全性を検証するハッシュが含まれます。例えば次の通りです。</p>
<pre><code class="language-json">{
    "providers": {
        "acme/foo": {
            "sha256": "38968de1305c2e17f4de33aea164515bc787c42c7e2d6e25948539a14268bb82"
        },
        "acme/bar": {
            "sha256": "4dd24c930bd6e1103251306d6336ac813b563a220d9ca14f4743c032fb047233"
        }
    }
}
</code></pre>
<p>上のファイルは<code>providers-url</code>で参照されたファイルを読み込むことにより、このリポジトリにacme/fooとacme/barがあることを宣言しています。
ベンダーの名前空間が付いたパッケージ名で<code>%package%</code>を、<code>%hash%</code>をsha256フィールドを、それぞれ置き換えます。
これらのファイル自体には<a href="#packages">上</a>で前述したパッケージの定義が含まれます。</p>
<p>これらのフィールドは省略可能です。
恐らく独自のリポジトリでは必要ないでしょう。</p>
<h4 id="curlとストリームオプション"><a class="header" href="#curlとストリームオプション">cURLとストリームオプション</a></h4>
<p>リポジトリへはcURL（ext-curlが有効なComposer 2）またはPHPストリームの何れかを使ってアクセスします。
<code>options</code>パラメータを使って追加のオプションを設定できます。
PHPストリームについては、任意の妥当なPHPストリームコンテキストオプションを設定できます。
詳細は<a href="https://php.net/manual/en/context.php">コンテキストオプションとパラメータ</a>を参照してください。
cURLが使われているとき、ごく一部の<code>http</code>と<code>ssl</code>オプションしか設定できないように制限されます。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "composer",
            "url": "https://example.org",
            "options": {
                "http": {
                    "timeout": 60
                }
            }
        }
    ],
    "require": {
        "acme/package": "^1.0"
    }
}
</code></pre>
<h3 id="vcs"><a class="header" href="#vcs">VCS</a></h3>
<p>VCSはバージョンコントロールシステム (Version Control System)
から来ています。これにはgit、svn、fossil、hgのようなバージョニングシステムが含まれます。Composerにはこれらのシステムからパッケージをインストールするリポジトリ種別があります。</p>
<h4 id="vcsリポジトリからパッケージを読み込む"><a class="header" href="#vcsリポジトリからパッケージを読み込む">VCSリポジトリからパッケージを読み込む</a></h4>
<p>これにはいくつかの使い途があります。
一番よくあるものとしては、サードパーティライブラリの独自のフォークを維持管理することです。
プロジェクトで或るライブラリを使用していて、ライブラリ内の何かを変更し、プロジェクトでパッチを適用したバージョンを使用しようと思ったとします。
ライブラリがGitHubにある場合（殆どのライブラリが当てはまります）、フォークして、変更をフォークにプッシュできます。
その後、プロジェクトの<code>composer.json</code>を更新します。
する必要があるのは、フォークをリポジトリとして追加し、バージョン制約を更新してカスタム ブランチを指すようにすることだけです。
<code>composer.json</code> でのみ、カスタムブランチ名の前に<code>"dev-"</code>を付けるべきです（実際のブランチ名の一部にしないでください）。
バージョン制約の命名規則については、<a href="02-libraries.html">ライブラリ</a>を参照してください。</p>
<p><code>bugfix</code>ブランチのバグを修正するためにmonologにパッチを当てたときの例は以下です。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "vcs",
            "url": "https://github.com/igorw/monolog"
        }
    ],
    "require": {
        "monolog/monolog": "dev-bugfix"
    }
}
</code></pre>
<p><code>php composer.phar update</code>を実行すると、修正したバージョンの<code>monolog/monolog</code>が取得されます。packagistからのものではありません。</p>
<p>長期的にフォークするつもりがない限り、パッケージを改名しないでください。
また、もし変更するならするで、元のパッケージから完全に離れたものにする必要があります。
独自リポジトリはpackagistよりも優先されるため、Composerは元のパッケージではなく自前のパッケージを正しく選択します。
パッケージを改名する場合、パッケージ名が既定のブランチから取得されるため、機能ブランチではなく、既定の（多くの場合master）ブランチで行う必要があります。</p>
<p>また、フォークされたリポジトリの<code>composer.json</code>ファイルの<code>name</code>プロパティを変更すると、上書きが機能しないことに注意してください。
上書きが機能するには元のものと合致する必要があるからです。</p>
<p>他の依存関係がフォークしたパッケージに依存している場合は、それをインラインエイリアスして、他の方法では一致しない制約に一致させることができます。
詳細については<a href="articles/aliases.html">エイリアスの記事を参照してください</a>。</p>
<h4 id="私有リポジトリを使う"><a class="header" href="#私有リポジトリを使う">私有リポジトリを使う</a></h4>
<p>GitHubとBitbucketの私有リポジトリを全く同じやり方で扱えます。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "vcs",
            "url":  "git@bitbucket.org:vendor/my-private-repo.git"
        }
    ],
    "require": {
        "vendor/my-private-repo": "dev-master"
    }
}
</code></pre>
<p>唯一の要件は、gitクライアント用のSSHキーがインストールされていることです。</p>
<h4 id="gitの代替案"><a class="header" href="#gitの代替案">Gitの代替案</a></h4>
<p>VCSリポジトリで対応しているバージョン管理システムはGitだけではありません。
以下に対応しています。</p>
<ul>
<li><strong>Git:</strong> <a href="https://git-scm.com">git-scm.com</a></li>
<li><strong>Subversion:</strong> <a href="https://subversion.apache.org">subversion.apache.org</a></li>
<li><strong>Mercurial:</strong> <a href="https://www.mercurial-scm.org">mercurial-scm.org</a></li>
<li><strong>Fossil</strong>: <a href="https://www.fossil-scm.org/">fossil-scm.org</a></li>
</ul>
<p>これらのシステムからパッケージを取得するにはそれぞれのクライアントがインストールされてる必要がありますが、これだと不便かもしれません。
このため、GitHubとBitbucketについては、これらのサイトが提供するAPIを使用して、バージョン管理システムをインストールせずにパッケージを取得する特別な対応が入っています。
VCSリポジトリは、パッケージをzipとして取得する<code>dist</code>を提供します。</p>
<ul>
<li><strong>GitHub:</strong> <a href="https://github.com">github.com</a> (Git)</li>
<li><strong>Bitbucket:</strong> <a href="https://bitbucket.org">bitbucket.org</a> (Git)</li>
</ul>
<p>使用するVCSドライバーは、URLに基づいて自動的に検出されます。
ただし、何らかの理由で指定する必要がある場合は、<code>vcs</code>に代えて<code>bitbucket</code>、<code>github</code>、<code>gitlab</code>、<code>perforce</code>、<code>fossil</code>、<code>git</code>、<code>svn</code>、<code>hg</code>がリポジトリの種類として使えます。</p>
<p>githubリポジトリで<code>no-api</code>キーを<code>true</code>に設定すると、GitHub
APIは使用せず、他のgitリポジトリと同様にリポジトリがクローンされます。
ただし、<code>git</code>ドライバーを直接使用する場合とは異なり、Composerは依然としてgithubのzipファイルを使用しようとします。</p>
<p>以下の点に注意してください。</p>
<ul>
<li><strong>Composerに使用するドライバを選ばせるには</strong>、リポジトリの種類は「vcs」として定義されている必要があります</li>
<li><strong>既に私有リポジトリを使っている場合</strong>、Composerはキャッシュへクローンすることになります。
同じパッケージをドライバと一緒にインストールしたい場合、<code>composer clearcache</code>コマンドに続けて<code>composer update</code>とすることでComposerのキャッシュを消去しdistからパッケージをインストールさせられることを覚えておきましょう</li>
<li>VCSドライバ<code>git-bitbucket</code>は<code>bitbucket</code>に取って代わられたため時代遅れです</li>
</ul>
<h4 id="bitbucketドライバ設定"><a class="header" href="#bitbucketドライバ設定">Bitbucketドライバ設定</a></h4>
<blockquote>
<p><strong>Bitbucketのリポジトリのエンドポイントはgitではなくhttpsになっている必要がある点に注意してください。</strong></p>
</blockquote>
<p>bitbucketリポジトリが準備できたら<a href="articles/authentication-for-private-packages.html#bitbucket-oauth">認証の準備</a>もする必要があるでしょう。</p>
<h4 id="subversionのオプション"><a class="header" href="#subversionのオプション">Subversionのオプション</a></h4>
<p>Subversion自体にはブランチとタグの概念がないため、Composerは既定でコードが<code>$url/trunk</code>、<code>$url/branches</code>、<code>$url/tags</code>にあるという前提を置きます。
リポジトリの配置が異なる場合は、それらの値を変更できます。
たとえば、大文字の名前を使用した場合、次のようにリポジトリを構成できます。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "vcs",
            "url": "http://svn.example.org/projectA/",
            "trunk-path": "Trunk",
            "branches-path": "Branches",
            "tags-path": "Tags"
        }
    ]
}
</code></pre>
<p>ブランチのディレクトリもタグのディレクトリもなければ<code>branches-path</code>ないし<code>tags-path</code>を<code>false</code>に設定することで完全に無効にできます。</p>
<p>パッケージが副ディレクトリにある、例えば<code>/trunk/foo/bar/composer.json</code>と<code>/tags/1.0/foo/bar/composer.json</code>にあるなら、<code>"package-path"</code>オプションを副ディレクトリに設定することでComposerがアクセスできるようにさせられます。
この例では<code>"package-path": "foo/bar/"</code>となるでしょう。</p>
<p>私有Subversionリポジトリがあるなら設定のhttp-basic節に資格情報を保存しておけます（<a href="04-schema.html">スキーマ</a>を参照）。</p>
<pre><code class="language-json">{
    "http-basic": {
        "svn.example.org": {
            "username": "username",
            "password": "password"
        }
    }
}
</code></pre>
<p>Subversionクライアントが既定で資格情報を保存するように構成されている場合、これらの資格情報は現在の利用者用に保存され、このサーバー用に保存されている既存の資格情報は上書きされます。
この挙動を変更するには、次のようにリポジトリ構成で<code>"svn-cache-credentials"</code>オプションを設定します。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "vcs",
            "url": "http://svn.example.org/projectA/",
            "svn-cache-credentials": false
        }
    ]
}
</code></pre>
<h3 id="パッケージ-1"><a class="header" href="#パッケージ-1">パッケージ</a></h3>
<p>上記のどの方法でもComposerに対応していないプロジェクトを使いたい場合でも、<code>package</code>リポジトリを使って自分でパッケージを定義できます。</p>
<p>基本的に<code>composer</code>リポジトリの<code>package.json</code>に含まれるのと同じ情報を定義しますが、単一のパッケージ用限定です。
繰り返しますが、最小限必要なフィールドは<code>name</code>、<code>version</code>、そして<code>dist</code>または<code>source</code>の何れかです。</p>
<p>以下はsmartyテンプレートエンジンの例です。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "package",
            "package": {
                "name": "smarty/smarty",
                "version": "3.1.7",
                "dist": {
                    "url": "https://www.smarty.net/files/Smarty-3.1.7.zip",
                    "type": "zip"
                },
                "source": {
                    "url": "http://smarty-php.googlecode.com/svn/",
                    "type": "svn",
                    "reference": "tags/Smarty_3_1_7/distribution/"
                },
                "autoload": {
                    "classmap": ["libs/"]
                }
            }
        }
    ],
    "require": {
        "smarty/smarty": "3.1.*"
    }
}
</code></pre>
<p>source部分は放置しておくのが普通です。本当に必要なことはまずないからです。</p>
<p>sourceキーが含まれているとき、referenceフィールドはインストールされるバージョンへの参照となります。
typeフィールドが<code>git</code>のとき、このフィールドはコミットIDやブランチやタグ名になります。</p>
<blockquote>
<p><strong>補足：</strong>
referenceフィールドにGitのブランチ名を使うことはお勧めしません。
<code>git checkout</code>に対応しているため妥当ではあるのですが、ブランチ名は可変なので固定できないのです。</p>
</blockquote>
<p>フィールドが<code>svn</code>のとき、referenceフィールドには<code>svn co</code>を走らせるときに後ろに付ける参照が含まれます。</p>
<blockquote>
<p><strong>補足</strong>：
このリポジトリ種別には2、3の制約があり、できる限り避けるべきです。</p>
<ul>
<li>Composerは<code>version</code>フィールドを変えない限りパッケージを更新しません。</li>
<li>Composerはコミット参照を更新しません。
そのため、参照として<code>master</code>を使う場合、強制的に更新するためにパッケージを削除し、不安定な固定ファイルに対処しなければならなくなるでしょう。</li>
</ul>
</blockquote>
<p><code>package</code>リポジトリ中の<code>"package"</code>キーには複数バージョンのパッケージを定義する配列を設定できます。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "package",
            "package": [
                {
                    "name": "foo/bar",
                    "version": "1.0.0",
                    ...
                },
                {
                    "name": "foo/bar",
                    "version": "2.0.0",
                    ...
                }
            ]
        }
    ]
}
</code></pre>
<h2 id="自分でホスティングする"><a class="header" href="#自分でホスティングする">自分でホスティングする</a></h2>
<p>多分殆どの場合でパッケージをpackagistに置きたいものと思われますが、自分のリポジトリをホスティングすることによる用途もあります。</p>
<ul>
<li>
<p><strong>企業の私有パッケージ：</strong>
内部的なパッケージ用にComposerを使っている企業に所属しているなら、それらのパッケージを私有としておきたいかもしれません。</p>
</li>
<li>
<p><strong>別のエコシステム:</strong>
独自のエコシステムを持つプロジェクトがあり、より大きなPHPコミュニティからそのパッケージを実際に再利用できない場合は、packagistから分離させておきたいかもしれません。
一例はWordPressプラグインです。</p>
</li>
</ul>
<p>自分のパッケージをホスティングするには、ネイティブな<code>composer</code>の種類のリポジトリが推奨されます。
一番の効率性が齎されるからです。</p>
<p><code>composer</code>リポジトリを作る上で、手助けになるツールはいくつかあります。</p>
<h3 id="私有packagist"><a class="header" href="#私有packagist">私有Packagist</a></h3>
<p><a href="https://packagist.com/">私有Packagist</a>ではGitHub、Packagist.org、その他のパッケージリポジトリのミラーリングと共に私有パッケージのホスティングを提供するアプリケーションです。
Packagistでも立てられていますが、自分で立てることもできます。</p>
<p>詳細は<a href="https://packagist.com/">Packagist.com</a>をご確認ください。</p>
<h3 id="satis"><a class="header" href="#satis">Satis</a></h3>
<p>Satisは静的な<code>composer</code>リポジトリ生成器です。
packagistを超軽量にして、静的なファイルを基盤にしたバージョンのようなものです。</p>
<p>Satisにはリポジトリを含む<code>composer.json</code>を与えます。
リポジトリとしてよくあるのはVCSやパッケージレポジトリの定義です。
<code>require</code>されるパッケージを全て取得し、<code>packages.json</code>を吐き出しますが、これが<code>composer</code>リポジトリになります。</p>
<p>詳細は<a href="https://github.com/composer/satis">satisのGitHubリポジトリ</a>と<a href="articles/handling-private-packages.html">プライベートパッケージを扱うことについての記事</a>をご確認ください。</p>
<h3 id="アーティファクト"><a class="header" href="#アーティファクト">アーティファクト</a></h3>
<p>前述のどのリポジトリの種類もオンラインにできない場合があります。
VCSが使われていたとしても例外ではありません。
よくある例は、ビルドアーティファクトによる組織間のライブラリ交換です。
もちろん殆どの場合で、これらは私有とされます。
これらのアーカイブをそのまま使用するには、これらの私有パッケージのZIPまたはTARアーカイブを含むフォルダーに対して、種別<code>artifact</code>のリポジトリを使用できます。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "artifact",
            "url": "path/to/directory/with/zips/"
        }
    ],
    "require": {
        "private-vendor-one/core": "15.6.2",
        "private-vendor-two/connectivity": "*",
        "acme-corp/parser": "10.3.5"
    }
}
</code></pre>
<p>それぞれのzipアーティファクトとは、根幹のフォルダにある<code>composer.json</code>があるZIPアーカイブです。</p>
<pre><code class="language-shell">unzip -l acme-corp-parser-10.3.5.zip
</code></pre>
<pre><code class="language-text">composer.json
...
</code></pre>
<p>パッケージのバージョンが異なる2つのアーカイブがある場合、両方ともインポートされます。
新しいバージョンのアーカイブがアーティファクトフォルダーに追加された状態で<code>update</code>を実行すると、そのバージョンもインポートされ、Composerは最新版に更新されます。</p>
<h3 id="パス"><a class="header" href="#パス">パス</a></h3>
<p>アーティファクトリポジトリに加えて、絶対パスまたは相対パスのローカルディレクトリに依存するパスを使用できます。
モノリシックリポジトリを扱う場合に特に役立ちます。</p>
<p>例えばリポジトリが以下のディレクトリ構造になっているとします。</p>
<pre><code class="language-text">...
├── apps
│   └── my-app
│       └── composer.json
├── packages
│   └── my-package
│       └── composer.json
...
</code></pre>
<p>そうして依存関係として<code>apps/my-app/composer.json</code>ファイルにパッケージ<code>my/package</code>を加えるには、以下の構成が使えます。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "path",
            "url": "../../packages/my-package"
        }
    ],
    "require": {
        "my/package": "*"
    }
}
</code></pre>
<p>パッケージがローカルのVCSリポジトリである場合、バージョンは現在チェックアウトされているブランチまたはタグによって推測されます。
それ以外の場合は、パッケージの<code>composer.json</code>ファイルでバージョンを明示的に定義すべきです。
これらの方法でバージョンが解決できない場合は、<code>dev-master</code>と見なされます。</p>
<p>バージョンがローカルのVCSリポジトリから推測できない場合、もしくはそのバージョンを上書きしたい場合は、リポジトリの宣言時に<code>versions</code>オプションが使えます。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "path",
            "url": "../../packages/my-package",
            "options": {
                "versions": {
                    "my/package": "4.2-dev"
                }
            }
        }
    ]
}
</code></pre>
<p>可能なときはローカルパッケージがシンボリックリンクされます。
この場合端末の出力は<code>Symlinking from ../../packages/my-package</code>となります。
シンボリックリンクでき<em>ない</em>場合はパッケージが複製されます。
その場合端末の出力は<code>Mirrored from ../../packages/my-package</code>となります。</p>
<p>既定のフォールバック戦略に代えて、<code>"symlink": true</code>としてシンボリックリンクにしたり、<code>"symlink": false</code>オプションでミラーリングしたりすることを強制できます。
ミラーリングを強制すると、モノリシックレポジトリからパッケージをデプロイしたり生成したりする際に便利なことがあります。</p>
<blockquote>
<p><strong>補足：</strong> Windowsでは管理者でない利用者によって作成される可能性があるため、NTFSジャンクションを使ってディレクトリのシンボリックリンクが実装されています。
Windows 7より前のバージョンまたは<code>proc_open</code>が無効にされている場合は常にミラーリングが使用されます。</p>
</blockquote>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "path",
            "url": "../../packages/*",
            "options": {
                "symlink": false
            }
        }
    ]
}
</code></pre>
<p>チルダを先頭に付けると現在の利用者のホームフォルダに展開され、環境変数はWIndowsとLinux/Macの両方の記法で解析されます。
例えば<code>~/git/mypackage</code>は自動的に<code>/home/&lt;利用者名&gt;/git/mypackage</code>からクローンしたmypackageを読み込みます。
<code>$HOME/git/mypackage</code>としたり<code>%USERPROFILE%/git/mypackage</code>としても同じことです。</p>
<blockquote>
<p><strong>補足：</strong> リポジトリのパスは<code>*</code>や<code>?</code>のようなワイルドカードも含められます。
詳細については<a href="https://php.net/glob">PHPのglob関数</a>を参照してください。</p>
</blockquote>
<p>（composer.lockファイルに現れる）パッケージのdistへの参照が構築される方法を構成できます。</p>
<p>以下のモードが存在します。</p>
<ul>
<li><code>none</code>：参照は常に空です。
これにより固定ファイル間の競合を低減する助けになる可能性がありますが、直近に更新があるとパッケージが最新の状態になっているかが比較的不明瞭になります。</li>
<li><code>config</code>：参照はパッケージのcomposer.jsonとリポジトリの設定のハッシュに基づいて構築されます</li>
<li><code>auto</code>（既定で使用されます）：参照は<code>comfig</code>のようなハッシュに基づいて構築されます。
ただしパッケージフォルダがgitリポジトリを含んでいる場合、代わりにHEADコミットのハッシュが参照として使われます。</li>
</ul>
<pre><code class="language-json">{
    "repositories": [
        {
            "type": "path",
            "url": "../../packages/*",
            "options": {
                "reference": "config"
            }
        }
    ]
}
</code></pre>
<h2 id="packagistorgを無効にする"><a class="header" href="#packagistorgを無効にする">Packagist.orgを無効にする</a></h2>
<p>以下を<code>composer.json</code>に加えると既定のPackagist.orgリポジトリを無効にできます。</p>
<pre><code class="language-json">{
    "repositories": [
        {
            "packagist.org": false
        }
    ]
}
</code></pre>
<p>大域的な構成フラグを使うことで、大域的にPackagist.orgを無効にできます。</p>
<pre><code class="language-shell">php composer.phar config -g repo.packagist false
</code></pre>
<p>← <a href="04-schema.html">スキーマ</a>  | <a href="06-config.html">設定</a> →</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../doc/04-schema.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../doc/06-config.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../doc/04-schema.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../doc/06-config.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
